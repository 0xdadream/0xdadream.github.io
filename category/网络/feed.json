{
    "version": "https://jsonfeed.org/version/1",
    "title": "逐梦 • All posts by \"网络\" category",
    "description": "Welcome to my blog",
    "home_page_url": "https://0xdadream.github.io",
    "items": [
        {
            "id": "https://0xdadream.github.io/2025/06/01/ji-yu-x-ui-yu-cloudflare-da-jian-jie-dian/",
            "url": "https://0xdadream.github.io/2025/06/01/ji-yu-x-ui-yu-cloudflare-da-jian-jie-dian/",
            "title": "科学上网节点技术与实践：基于 X-UI 与 Cloudflare 的全面指南",
            "date_published": "2025-06-01T04:25:00.000Z",
            "content_html": "<h1 id=\"科学上网节点技术与实践：基于-X-UI-与-Cloudflare-的全面指南\"><a href=\"#科学上网节点技术与实践：基于-X-UI-与-Cloudflare-的全面指南\" class=\"headerlink\" title=\"科学上网节点技术与实践：基于 X-UI 与 Cloudflare 的全面指南\"></a>科学上网节点技术与实践：基于 X-UI 与 Cloudflare 的全面指南</h1><h2 id=\"第一部分：科学上网节点与核心概念概述\"><a href=\"#第一部分：科学上网节点与核心概念概述\" class=\"headerlink\" title=\"第一部分：科学上网节点与核心概念概述\"></a>第一部分：科学上网节点与核心概念概述</h2><h3 id=\"1-1-科学上网概述及其重要性\"><a href=\"#1-1-科学上网概述及其重要性\" class=\"headerlink\" title=\"1.1 科学上网概述及其重要性\"></a>1.1 科学上网概述及其重要性</h3><p>“科学上网”，通常指通过技术手段绕过互联网审查和地理限制，以访问全球开放信息资源的过程。在当前信息高度互联的时代，获取未经审查的、多元化的信息对于学术研究、技术创新以及文化交流至关重要。然而，常见的网络封锁技术，如IP地址封锁、域名系统 (DNS) 污染和深度包检测 (Deep Packet Inspection, DPI)，对信息的自由流通构成了挑战 。因此，理解和掌握科学上网技术，对于需要无障碍访问全球互联网资源的用户而言，具有实际意义。</p>\n<h3 id=\"1-2-核心技术：Xray-与-x-ui-面板\"><a href=\"#1-2-核心技术：Xray-与-x-ui-面板\" class=\"headerlink\" title=\"1.2 核心技术：Xray 与 x-ui 面板\"></a>1.2 核心技术：Xray 与 x-ui 面板</h3><p>Xray 是一个功能强大且灵活的网络代理核心，被广泛用于构建科学上网节点。它支持多种代理协议和复杂的路由功能，能够有效地帮助用户绕过网络审查 。与 Xray 配合使用的 x-ui (特别是 MHSanaei 维护的 3x-ui 分支) 是一个用户友好的图形化管理面板，它极大地简化了 Xray 节点的配置和管理过程，支持多用户、多协议管理，并提供流量统计、到期时间限制等功能 。</p>\n<h3 id=\"1-3-Cloudflare-的角色\"><a href=\"#1-3-Cloudflare-的角色\" class=\"headerlink\" title=\"1.3 Cloudflare 的角色\"></a>1.3 Cloudflare 的角色</h3><p>Cloudflare 是一家全球性的网络基础设施和安全公司，其提供的服务如内容分发网络 (CDN)、Workers（边缘计算）和 Tunnel（安全隧道）可以被巧妙地用于增强科学上网节点的隐蔽性和稳定性 。通过 Cloudflare，用户可以隐藏其代理服务器的真实IP地址，抵御分布式拒绝服务 (DDoS) 攻击，并在某些情况下改善连接速度和可靠性 。</p>\n<h3 id=\"1-4-关键术语解析\"><a href=\"#1-4-关键术语解析\" class=\"headerlink\" title=\"1.4 关键术语解析\"></a>1.4 关键术语解析</h3><p>理解以下术语对于掌握本教程至关重要：</p>\n<ul>\n<li><strong>TLS (Transport Layer Security) / SSL (Secure Sockets Layer):</strong> TLS 及其前身 SSL 是保障网络通信安全和数据完整性的加密协议 。它们通过在客户端和服务器之间建立加密通道，确保数据传输不被窃听或篡改。在科学上网中，TLS 常用于伪装代理流量，使其看起来像正常的 HTTPS 流量。</li>\n<li><strong>CDN (Content Delivery Network):</strong> 内容分发网络通过在全球部署边缘服务器来缓存网站内容，使用户可以从最近的服务器获取数据，从而提高网站加载速度并减少源服务器负载 。对于代理节点，CDN 可以隐藏源服务器 IP，并可能分散流量特征。</li>\n<li><strong>WebSocket:</strong> 一种在单个 TCP 连接上进行全双工通信的协议 。它允许服务器和客户端之间进行持续的、低延迟的双向数据交换。在代理中，WebSocket 常被用作一种传输方式，可以将代理流量封装在标准的 HTTP/HTTPS 端口（如 80 或 443）上传输，从而更好地伪装流量，并兼容 CDN 。</li>\n<li><strong>gRPC (Google Remote Procedure Call):</strong> 一个高性能、开源的通用 RPC 框架，使用 HTTP/2 作为传输协议，支持多种语言 。gRPC 因其高效的序列化（Protocol Buffers）和多路复用特性，在代理应用中可以提供较低的延迟和带宽消耗，尤其适合移动端应用。Cloudflare 支持 gRPC 流量的代理 。</li>\n<li><strong>REALITY:</strong> Xray 引入的一种新的出站/入站协议特性，旨在通过借用目标网站的 TLS 证书指纹来消除服务器端 TLS 指纹特征，从而增强抗检测能力，同时保持前向保密性 。它允许用户在不购买域名或配置 TLS 服务器的情况下，向审查者呈现一个真实可信的 SNI (Server Name Indication)。</li>\n<li><strong>XTLS:</strong> 一种旨在减少 VLESS 和 Trojan 等协议中 TLS 加密层级所带来性能开销的技术 。它通过在特定条件下（如 <code>flow</code> 设置为 <code>xtls-rprx-vision</code>）直接处理内层数据，避免了多次 TLS 加解密，从而提升传输效率。</li>\n<li><strong>uTLS (μTLS):</strong> 一个 TLS 库，允许应用程序模仿不同浏览器或操作系统的 TLS 指纹 。在代理客户端中使用 uTLS 可以帮助伪装连接发起者的真实身份，使其流量特征更接近普通浏览器行为，从而降被识别的风险。</li>\n</ul>\n<h2 id=\"第二部分：代理协议深度解析\"><a href=\"#第二部分：代理协议深度解析\" class=\"headerlink\" title=\"第二部分：代理协议深度解析\"></a>第二部分：代理协议深度解析</h2><p>本部分将详细探讨几种主流的科学上网代理协议的原理、特性、优缺点及其在 x-ui 中的应用。</p>\n<h3 id=\"2-1-Shadowsocks-SS\"><a href=\"#2-1-Shadowsocks-SS\" class=\"headerlink\" title=\"2.1 Shadowsocks (SS)\"></a>2.1 Shadowsocks (SS)</h3><ul>\n<li><strong>原理与工作机制:</strong> Shadowsocks 是一种基于 SOCKS5 代理的加密传输协议，最初由 clowwindy 于 2012 年为绕过中国的防火长城 (GFW) 而设计 。它通过在客户端和远程服务器之间创建一个加密隧道来工作。客户端将流量通过本地 SOCKS5 代理发送到 Shadowsocks 客户端软件，该软件对流量进行加密后发送到 Shadowsocks 服务器，服务器解密后再将流量转发至目标地址 。</li>\n<li><strong>安全特性:</strong> Shadowsocks 使用用户选择的加密算法（如 AES-256-GCM, ChaCha20-Poly1305）对数据进行加密 。较新的 Shadowsocks AEAD (Authenticated Encryption with Associated Data) 密码套件（如 2022-blake3-aes-256-gcm）提供了更强的安全性和抗重放攻击能力 。</li>\n<li><strong>性能特点:</strong> Shadowsocks 以其轻量级和高效率著称，对网络速度影响较小，能够提供较快的浏览和流媒体体验 。</li>\n<li><strong>混淆能力:</strong> Shadowsocks 本身并不侧重于复杂的流量混淆，其主要目标是加密。然而，由于其流量模式与标准协议不同，在早期能够有效绕过基于简单规则的检测。随着 DPI 技术的发展，单纯的 Shadowsocks 流量可能被识别。</li>\n<li>优缺点:<ul>\n<li><strong>优点:</strong> 设置相对简单，速度快，资源占用低，兼容性广（支持 Windows, macOS, Linux, Android, iOS）。</li>\n<li><strong>缺点:</strong> 协议特征相对明显，容易被高级 DPI 检测；不具备传统 VPN 的所有网络流量封装能力，仅代理通过其 SOCKS5 接口的流量 。</li>\n</ul>\n</li>\n<li><strong>x-ui 中的配置:</strong> 在 x-ui 中配置 Shadowsocks 时，主要参数包括加密方法、密码、监听端口和传输协议（通常是 TCP 和 UDP）。</li>\n</ul>\n<h3 id=\"2-2-VMess-Virtual-Mess\"><a href=\"#2-2-VMess-Virtual-Mess\" class=\"headerlink\" title=\"2.2 VMess (Virtual Mess)\"></a>2.2 VMess (Virtual Mess)</h3><ul>\n<li><strong>原理与工作机制:</strong> VMess 是 V2Ray 项目（Xray 的前身和兼容核心）设计的一种主要代理协议，旨在提供比 Shadowsocks 更强的安全性和混淆性 。它在客户端和服务器之间建立加密连接，并通过动态改变数据包结构来增加流量分析的难度 。</li>\n<li><strong>安全特性:</strong> VMess 使用对称加密（如 AES-128-GCM）和动态生成的会话 ID。它要求客户端和服务器共享精确的用户 ID (UUID) 和 alterId（用于改变加密方式）进行身份验证和加密 。</li>\n<li><strong>性能特点:</strong> VMess 由于其加密和动态特性，相比 Shadowsocks 会有一定的性能开销，但通常仍能提供良好的速度 。</li>\n<li><strong>混淆能力:</strong> VMess 的设计目标之一就是抗检测。其动态协议特性使得流量难以被简单模式匹配。结合 TLS 和 WebSocket 等传输方式可以进一步增强混淆效果 。</li>\n<li>传输方式:<ul>\n<li><strong>TCP:</strong> 基础的 TCP 传输，可配合 TLS 加密。</li>\n<li><strong>WebSocket (WS):</strong> 将 VMess 流量封装在 WebSocket 连接中，通常与 TLS 结合（VMess+WS+TLS），使其看起来像 HTTPS 流量，便于通过 CDN 中转和伪装 。</li>\n<li><strong>gRPC:</strong> 将 VMess 流量封装在 gRPC 连接中，利用 HTTP/2 的多路复用特性，可以提供高效的传输，同样可以结合 TLS 。</li>\n</ul>\n</li>\n<li>优缺点:<ul>\n<li><strong>优点:</strong> 安全性高，抗检测能力强于 Shadowsocks，支持多种传输方式，配置灵活 。</li>\n<li><strong>缺点:</strong> 配置相对复杂，性能开销略高于 Shadowsocks 和 VLESS 。</li>\n</ul>\n</li>\n<li><strong>x-ui 中的配置:</strong> 在 x-ui 中配置 VMess 时，需要设置用户 UUID、alterId、监听端口、传输方式（TCP, WS, gRPC 等），以及相应的 TLS 设置（域名、证书路径）或 WebSocket 设置（路径、Host）。</li>\n</ul>\n<h3 id=\"2-3-VLESS-Virtual-Less\"><a href=\"#2-3-VLESS-Virtual-Less\" class=\"headerlink\" title=\"2.3 VLESS (Virtual Less)\"></a>2.3 VLESS (Virtual Less)</h3><ul>\n<li><p><strong>原理与工作机制:</strong> VLESS 是在 VMess 基础上发展而来的一种更轻量级的传输协议，旨在简化协议本身并提高效率 。与 VMess 不同，VLESS 本身不包含加密和身份验证机制，而是依赖于外部传输层（如 TLS）来提供这些功能 。</p>\n</li>\n<li><p><strong>安全特性:</strong> VLESS 的安全性主要依赖于其底层的传输协议，如 TLS (XTLS) 或 REALITY。当与这些技术结合时，它可以提供非常高的安全性 。VLESS 本身不进行加密，这使得其头部特征更少，更难被检测。</p>\n</li>\n<li><p><strong>性能特点:</strong> 由于其极简设计和无内置加密，VLESS 的性能开销非常低，通常比 VMess 更快，延迟更低，尤其适合对速度要求高的场景 。</p>\n</li>\n<li><p>混淆能力:</p>\n<p> VLESS 的核心优势在于其简洁性，这使得其流量本身更难被识别。当结合 XTLS 或 REALITY 时，其混淆能力非常出色。</p>\n<ul>\n<li><strong>XTLS (XTLS-Vision, XTLS-RPRX-Direct):</strong> XTLS 是一种专为 VLESS 和 Trojan 设计的 TLS 增强技术，旨在通过优化 TLS 握手和数据传输路径，减少加密层级，从而显著提高性能，同时保持强大的安全性 。<code>xtls-rprx-vision</code> 是 XTLS 的一种流控模式。</li>\n<li><strong>REALITY:</strong> 如前所述，REALITY 通过借用真实网站的 TLS 证书指纹来消除服务器端的 TLS 特征，极大地增强了抗检测能力 。VLESS 是 REALITY 的理想搭配协议。</li>\n</ul>\n</li>\n<li><p>传输方式:</p>\n<ul>\n<li><strong>TCP:</strong> VLESS 可以直接通过 TCP 传输，通常与 XTLS 或 REALITY 结合使用。</li>\n<li><strong>WebSocket (WS):</strong> VLESS 同样可以封装在 WebSocket 中，并结合 TLS (VLESS+WS+TLS)，以利用 CDN 和伪装流量 。</li>\n<li><strong>gRPC:</strong> VLESS 也可以通过 gRPC 传输，并结合 TLS (VLESS+gRPC+TLS)，提供高效的多路复用连接。</li>\n</ul>\n</li>\n<li><p>优缺点:</p>\n<ul>\n<li><strong>优点:</strong> 性能极高，延迟低，配置相对 VMess 简单（当不考虑复杂的 XTLS/REALITY 时），灵活性强，抗检测能力强（尤其配合 REALITY）。</li>\n<li><strong>缺点:</strong> 依赖外部加密，如果底层传输（如裸 TCP）未加密则不安全；高级配置（如 REALITY）对理解有一定要求 。</li>\n</ul>\n</li>\n<li><p><strong>x-ui 中的配置:</strong> 在 x-ui 中配置 VLESS 时，主要设置用户 UUID、监听端口、传输方式（TCP, WS, gRPC），以及流控模式（如 <code>xtls-rprx-vision</code> for XTLS，或不设置流控用于普通 TLS/WS）。如果使用 TLS，需要配置域名和证书路径。如果使用 REALITY，需要配置 <code>dest</code>（目标伪装域名:端口）、<code>serverNames</code>（SNI）、<code>privateKey</code>、<code>shortIds</code> 等参数 。</p>\n</li>\n</ul>\n<h3 id=\"2-4-Trojan\"><a href=\"#2-4-Trojan\" class=\"headerlink\" title=\"2.4 Trojan\"></a>2.4 Trojan</h3><ul>\n<li><strong>原理与工作机制:</strong> Trojan 协议的设计目标是模仿互联网上最常见的 HTTPS 流量，使其难以被检测和干扰 。它通过在服务器上监听一个端口（通常是 443），并处理进来的 TLS 连接。如果连接是合法的 Trojan 请求（通过密码验证），则代理流量；否则，将流量转发到服务器上预设的真实网站（如本地 Nginx 服务），从而使服务器在外部探测下表现得像一个普通的 HTTPS 网站 。</li>\n<li><strong>安全特性:</strong> Trojan 强制使用 TLS 对所有流量进行加密，确保了传输的机密性和完整性。身份验证通过预共享的密码完成 。</li>\n<li><strong>性能特点:</strong> 由于其设计直接利用 TLS，避免了额外的封装层，Trojan 通常具有较好的性能，接近于直接的 HTTPS 连接 。</li>\n<li><strong>混淆能力:</strong> Trojan 的核心优势在于其出色的混淆能力。它通过完全模拟 HTTPS 行为，包括 TLS 握手和数据传输，使得 DPI 系统很难将其与正常的 HTTPS 流量区分开来 。</li>\n<li>传输方式:<ul>\n<li><strong>TCP (over TLS):</strong> 这是 Trojan 的标准工作方式，直接在 TLS 加密的 TCP 连接上传输代理数据。</li>\n<li><strong>gRPC:</strong> Trojan 也可以通过 gRPC 传输，并结合 TLS (Trojan+gRPC+TLS)，这可以利用 gRPC 的特性，同时保持 Trojan 的 HTTPS 伪装。</li>\n</ul>\n</li>\n<li>优缺点:<ul>\n<li><strong>优点:</strong> 伪装性极好，抗检测能力强，性能较好，设置相对简单（相比 VMess 的复杂配置）。</li>\n<li><strong>缺点:</strong> 依赖于有效的 TLS 证书和域名配置；如果密码泄露或配置不当，安全性会受影响。</li>\n</ul>\n</li>\n<li><strong>x-ui 中的配置:</strong> 在 x-ui 中配置 Trojan 时，需要设置密码、监听端口（通常 443）、域名（用于 TLS 证书）、证书和私钥路径。对于 gRPC 传输，还需要配置 <code>serviceName</code> 。</li>\n</ul>\n<h3 id=\"2-5-WireGuard\"><a href=\"#2-5-WireGuard\" class=\"headerlink\" title=\"2.5 WireGuard\"></a>2.5 WireGuard</h3><ul>\n<li><strong>原理与工作机制:</strong> WireGuard 是一种现代、高性能的 VPN 协议，旨在提供比传统 VPN 协议（如 OpenVPN, IPsec）更简单、更快速、更安全的解决方案 。它使用最先进的密码学技术，通过 UDP 传输数据，并在内核空间运行以提高效率 。WireGuard 通过公钥加密进行身份验证和密钥交换 。</li>\n<li><strong>安全特性:</strong> WireGuard 使用固定的密码套件，包括 ChaCha20进行对称加密，Poly1305进行消息认证，Curve25519进行椭圆曲线 Diffie-Hellman 密钥交换，BLAKE2s进行哈希 。这种固定的选择减少了因密码套件协商错误导致的安全风险。它还提供完美前向保密。</li>\n<li><strong>性能特点:</strong> WireGuard 以其极高的性能和低延迟著称，代码量小（Linux 内核模块约 4000 行代码），易于审计，且资源消耗低，非常适合移动设备和嵌入式系统 。</li>\n<li><strong>混淆能力:</strong> WireGuard 本身不以流量混淆为主要设计目标。其流量特征（基于 UDP）相对固定，虽然不像 HTTPS 那样普遍，但在某些网络环境下可能被识别或限制。它不具备像 Trojan 或 VLESS+REALITY 那样的 HTTPS 伪装能力。</li>\n<li>优缺点:<ul>\n<li><strong>优点:</strong> 速度极快，延迟低，安全性高，配置简单，代码量小，跨平台支持良好 。</li>\n<li><strong>缺点:</strong> 基于 UDP，可能在对 UDP 不友好的网络中表现不佳；协议相对较新，虽然经过广泛审计，但历史积淀不如 OpenVPN；隐私方面，默认配置下服务器会记录对端 IP，需要服务提供商额外处理以保护用户隐私 。</li>\n</ul>\n</li>\n<li><strong>x-ui 中的配置:</strong> 3x-ui 面板支持 WireGuard 作为一种入站协议 。配置通常涉及设置监听端口、服务器私钥、客户端公钥、分配给客户端的 IP 地址以及允许的 IP 范围等。x-ui 简化了这个过程，但具体的界面选项需要参考面板本身 。</li>\n</ul>\n<h3 id=\"协议资源消耗与演进趋势\"><a href=\"#协议资源消耗与演进趋势\" class=\"headerlink\" title=\"协议资源消耗与演进趋势\"></a>协议资源消耗与演进趋势</h3><p>在资源消耗方面，一般而言，VLESS 由于其极简设计，通常比 VMess 更轻量，CPU 和内存占用更低 。Shadowsocks 也是一种非常轻量级的协议 。WireGuard 因其内核态实现和高效密码学，资源消耗极低 。Trojan 协议由于直接利用 TLS，其资源消耗主要取决于 TLS 的实现，通常也比较高效。相比之下，VMess 由于其内置的加密和动态特性，可能会有稍高的资源占用。实际的资源消耗会受到并发连接数、流量大小、服务器硬件配置以及具体实现（如 Xray 核心的优化程度）等多种因素影响。根据 Istio（使用 Envoy 代理，与 Xray 角色类似）的数据，代理本身每秒处理 1000 个请求大约消耗 0.2 至 0.5 vCPU 和 40MB 至 60MB 内存 ，这可以作为一个大致的参考，但 Xray 的具体表现会有所不同。</p>\n<p>科学上网协议的演进清晰地反映了审查技术与反审查技术之间的持续博弈。最初的 Shadowsocks 提供了基础的加密代理功能。随着 DPI 技术对 Shadowsocks 特征的识别，V2Ray 项目及其核心协议 VMess 应运而生，提供了更强的混淆和灵活性。然而，VMess 的复杂性也带来了一定的性能开销和配置难度。随后，VLESS 协议以其“更少即是更多”的理念出现，通过剥离内置加密，依赖底层传输（如 TLS/XTLS/REALITY）来保证安全，从而实现了更高的性能和更强的隐蔽性 。XTLS 和 REALITY 等技术的出现，进一步提升了 VLESS 和 Trojan 等协议的性能与抗检测能力，代表了当前协议发展的前沿方向 。这种演进趋势表明，未来的协议发展将更加注重性能、安全性和伪装性的平衡，以及对不断变化的审查策略的适应能力。</p>\n<h2 id=\"第三部分：使用-x-ui-与-Cloudflare-搭建节点\"><a href=\"#第三部分：使用-x-ui-与-Cloudflare-搭建节点\" class=\"headerlink\" title=\"第三部分：使用 x-ui 与 Cloudflare 搭建节点\"></a>第三部分：使用 x-ui 与 Cloudflare 搭建节点</h2><p>本部分将详细指导如何在 VPS 上安装 x-ui 面板，并结合 Cloudflare 服务搭建各类型的科学上网节点。</p>\n<h3 id=\"3-1-VPS-与域名准备\"><a href=\"#3-1-VPS-与域名准备\" class=\"headerlink\" title=\"3.1 VPS 与域名准备\"></a>3.1 VPS 与域名准备</h3><ol>\n<li>选择 VPS (Virtual Private Server):<ul>\n<li>选择一个位于审查区域之外的 VPS 提供商。考虑因素包括服务器位置（影响延迟）、带宽、CPU、内存、价格以及提供商的声誉。建议选择 KVM 虚拟化的 VPS 。</li>\n<li>操作系统推荐选择较新的稳定版 Linux 发行版，如 Ubuntu 20.04/22.04, Debian 10/11, CentOS 7+ (尽管 CentOS 7 即将 EOL) 。</li>\n</ul>\n</li>\n<li>注册域名:<ul>\n<li>你需要一个域名用于配置 TLS 加密，特别是当使用 WebSocket、gRPC 或 REALITY 等需要域名验证的场景时。可以选择如 Namecheap, Porkbun 等域名注册商 。</li>\n</ul>\n</li>\n<li>基础服务器设置:<ul>\n<li>通过 SSH 连接到你的 VPS。</li>\n<li>更新系统软件包：<code>sudo apt update &amp;&amp; sudo apt upgrade -y</code> (以 Debian/Ubuntu 为例) 。</li>\n<li>安装必要工具，如 <code>curl</code> 和 <code>socat</code>：<code>sudo apt install curl socat -y</code> 。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-2-安装-x-ui-面板-MHSanaei-3x-ui\"><a href=\"#3-2-安装-x-ui-面板-MHSanaei-3x-ui\" class=\"headerlink\" title=\"3.2 安装 x-ui 面板 (MHSanaei/3x-ui)\"></a>3.2 安装 x-ui 面板 (MHSanaei/3x-ui)</h3><p>MHSanaei 的 3x-ui 是一个功能丰富的 Xray 管理面板。</p>\n<ol>\n<li><p>执行安装脚本:</p>\n<p>通过 SSH 连接到 VPS 后，运行以下命令安装最新版本的 3x-ui ：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">bash &lt;(curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>安装过程中，脚本可能会提示你设置面板的用户名、密码和访问端口 。如果选择不自定义，可能会随机生成。请务必记录这些信息。</p>\n</li>\n<li><p><strong>访问 x-ui 面板:</strong> 安装完成后，通过浏览器访问 <code>http://&lt;你的VPS_IP&gt;:&lt;面板端口&gt;</code> 来打开 x-ui 登录界面 。</p>\n</li>\n<li><p><strong>初始登录与安全设置:</strong> 使用安装时设置或脚本生成的用户名和密码登录。首次登录后，强烈建议立即修改默认的用户名和密码，并考虑修改面板的访问端口和一个随机的 URL 根路径（Web Base Path）以增强安全性 。这些设置通常在 x-ui 的“面板设置”中可以找到。可以通过在 VPS 终端运行 <code>x-ui</code> 命令来访问管理菜单，其中包括重置 Web Base Path 等选项 。</p>\n</li>\n</ol>\n<h3 id=\"3-3-SSL-证书管理\"><a href=\"#3-3-SSL-证书管理\" class=\"headerlink\" title=\"3.3 SSL 证书管理\"></a>3.3 SSL 证书管理</h3><p>为了启用 TLS 加密（对于 HTTPS 伪装和安全至关重要），你需要为你的域名获取 SSL 证书。</p>\n<ol>\n<li><p><strong>使用 x-ui 内置的 ACME 功能 (推荐):</strong></p>\n<ul>\n<li>确保你的域名已正确解析到 VPS 的 IP 地址（A 记录）。</li>\n<li>在 VPS 终端运行 <code>x-ui</code> 命令，选择“SSL 证书管理” (SSL Certificate Management) 。</li>\n<li>按照提示选择“获取 SSL”(Get SSL)，输入你的域名，脚本会自动尝试通过 Let’s Encrypt 等 ACME 提供商申请证书。</li>\n<li>申请成功后，证书和私钥文件通常会保存在服务器的特定路径（如 <code>/root/.acme.sh/yourdomain.com/</code> 或由 x-ui 指定的路径），并在 x-ui 面板中配置入站规则时引用这些路径。</li>\n<li>x-ui 通常支持自动续签申请到的证书 。</li>\n</ul>\n</li>\n<li><p><strong>使用 Certbot 手动申请 (备选方案):</strong></p>\n<ul>\n<li><p>在 VPS 上安装 Certbot ：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo apt install certbot python3-certbot-nginx # (或相应的 Apache 插件)\n# 或者更通用的方式\nsudo apt install software-properties-common\nsudo add-apt-repository ppa:certbot/certbot -y # 可能需要确认\nsudo apt update\nsudo apt install certbot -y<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>申请证书（以 standalone 模式为例，需要临时占用 80 端口；确保 Cloudflare DNS 记录此时为“DNS Only”）：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo certbot certonly --standalone --agree-tos --register-unsafely-without-email -d yourdomain.com<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>将 yourdomain.com 替换为你的域名。</p>\n</li>\n<li><p>成功后，证书和私钥路径通常为 <code>/etc/letsencrypt/live/yourdomain.com/fullchain.pem</code> 和 <code>/etc/letsencrypt/live/yourdomain.com/privkey.pem</code> 。</p>\n</li>\n<li><p>设置自动续签：Certbot 通常会自动创建 systemd timer 或 cron job 来处理续签。可以通过 <code>sudo certbot renew --dry-run</code> 测试续签。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>使用 Cloudflare 源服务器证书 (Origin Certificate):</strong></p>\n<ul>\n<li>在 Cloudflare 仪表盘的 “SSL/TLS” -&gt; “源服务器” 处创建源证书。Cloudflare 会提供证书和私钥。</li>\n<li>将这些证书和私钥内容上传到你的 VPS，并在 x-ui 中配置入站规则时直接粘贴内容或引用文件路径。</li>\n<li>这种方式下，Cloudflare 与你的源服务器之间的连接是加密的，但客户端到 Cloudflare 的连接仍需由 Cloudflare 提供的边缘证书处理。SSL/TLS 模式需设置为 “Full (Strict)”。</li>\n</ul>\n</li>\n<li><p><strong>通过 Cloudflare 获取 SSL (x-ui 功能):</strong></p>\n<ul>\n<li>如果你的域名通过 Cloudflare 解析，x-ui 的某些版本提供了通过 Cloudflare API 直接申请 SSL 证书的功能 。</li>\n<li>这需要你的 Cloudflare 注册邮箱和 Global API Key。在 x-ui 命令行菜单中选择“Cloudflare SSL 证书”并按提示操作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-4-x-ui-基础节点配置-不使用-Cloudflare-CDN-Tunnel\"><a href=\"#3-4-x-ui-基础节点配置-不使用-Cloudflare-CDN-Tunnel\" class=\"headerlink\" title=\"3.4 x-ui 基础节点配置 (不使用 Cloudflare CDN/Tunnel)\"></a>3.4 x-ui 基础节点配置 (不使用 Cloudflare CDN/Tunnel)</h3><p>登录 x-ui 面板后，进入“入站列表”(Inbounds) 页面，点击“添加入站”(Add Inbound) 来创建新的代理节点。以下是一些常见协议的配置要点：</p>\n<h4 id=\"3-4-1-VLESS-TCP-XTLS-Vision-REALITY\"><a href=\"#3-4-1-VLESS-TCP-XTLS-Vision-REALITY\" class=\"headerlink\" title=\"3.4.1 VLESS + TCP + XTLS (Vision/REALITY)\"></a>3.4.1 VLESS + TCP + XTLS (Vision/REALITY)</h4><p>这是目前推荐的高性能、高隐蔽性配置之一。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 给连接起一个描述性名称，如 <code>VLESS-XTLS-Direct</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>vless</code> 。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空表示监听所有可用 IP 地址。</li>\n<li><strong>端口 (Port):</strong> 推荐使用 <code>443</code> 。</li>\n<li><strong>用户ID (ID / UUID):</strong> x-ui 会自动生成一个 UUID，保持默认即可。这是客户端连接的凭证。</li>\n<li>流控 (Flow):<ul>\n<li>对于 XTLS Vision: 选择 <code>xtls-rprx-vision</code> 。</li>\n</ul>\n</li>\n<li><strong>传输 (Transport / Network):</strong> 选择 <code>tcp</code> 。</li>\n<li>TLS 设置:<ul>\n<li><strong>启用 TLS (Enable TLS):</strong> <em>不勾选</em> (因为 XTLS/REALITY 有自己的 TLS 处理机制)。</li>\n<li><strong>启用 XTLS (Enable XTLS):</strong> <em>勾选</em> (如果使用 XTLS Vision)。</li>\n</ul>\n</li>\n<li>REALITY 设置 (如果选择 REALITY 而非 XTLS Vision):<ul>\n<li>在 x-ui 面板中，通常 VLESS 协议下会有专门的 REALITY 安全设置区域 。</li>\n<li><strong>接受代理协议 (Accept Proxy Protocol):</strong> 可能需要勾选此项或类似选项来启用 REALITY 特有的参数 。</li>\n<li><strong>目标地址 (Dest):</strong> 填写一个真实存在的、支持 TLSv1.3 和 H2 的境外网站域名和端口，例如 <code>www.microsoft.com:443</code> 或 <code>dl.google.com:443</code> 。</li>\n<li><strong>Server Names (SNI):</strong> 填写目标地址对应的域名，例如 <code>www.microsoft.com</code> 或 <code>dl.google.com</code> 。</li>\n<li><strong>私钥 (Private Key):</strong> 点击面板上的“生成新证书”或类似按钮生成 X25519 密钥对，这里填入私钥 1。公钥会自动生成或需要一并记录给客户端。</li>\n<li><strong>Short IDs:</strong> 可以留空或生成一个随机的 Short ID，用于区分客户端 。</li>\n<li><strong>uTLS 指纹 (uTLS):</strong> 选择一个浏览器指纹，如 <code>chrome</code> 或 <code>firefox</code> 。</li>\n</ul>\n</li>\n<li><strong>域名 (Domain name):</strong> 对于 XTLS Vision（非 REALITY），你需要填写真实申请过 SSL 证书的域名 。</li>\n<li><strong>证书公钥文件路径 (Certificate File Path / Public key file path):</strong> 填写 SSL 证书的 <code>fullchain.pem</code> 文件路径 。</li>\n<li><strong>证书私钥文件路径 (Key File Path / Private key file path):</strong> 填写 SSL 证书的 <code>privkey.pem</code> 文件路径 。</li>\n</ul>\n<h4 id=\"3-4-2-VMess-TCP-TLS\"><a href=\"#3-4-2-VMess-TCP-TLS\" class=\"headerlink\" title=\"3.4.2 VMess + TCP + TLS\"></a>3.4.2 VMess + TCP + TLS</h4><p>这种配置提供了较好的安全性和伪装性。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 例如 <code>VMess-TCP-TLS</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>vmess</code> 。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空。</li>\n<li><strong>端口 (Port):</strong> 推荐 <code>443</code>。</li>\n<li><strong>用户ID (UUID):</strong> 自动生成，保持默认。</li>\n<li><strong>额外ID (AlterID):</strong> 设置一个数字，如 <code>0</code> (较新版本 Xray 中 alterId 作用减弱，可以设为0或较低值)。</li>\n<li><strong>加密方式 (Security):</strong> 通常保持默认（如 <code>auto</code> 或 <code>aes-128-gcm</code>）。</li>\n<li><strong>传输 (Transport / Network):</strong> 选择 <code>tcp</code>。</li>\n<li>TLS 设置:<ul>\n<li><strong>启用 TLS (Enable TLS):</strong> <em>勾选</em> 。</li>\n<li><strong>域名 (Domain name):</strong> 填写你拥有并已申请 SSL 证书的域名。</li>\n<li><strong>证书公钥文件路径 (Certificate File Path):</strong> 填写 SSL 证书的 <code>fullchain.pem</code> 文件路径。</li>\n<li><strong>证书私钥文件路径 (Key File Path):</strong> 填写 SSL 证书的 <code>privkey.pem</code> 文件路径。</li>\n<li><strong>ALPN:</strong> 可以留空或根据需要填写 (如 <code>h2,http/1.1</code>)。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-4-3-Trojan-TCP-TLS\"><a href=\"#3-4-3-Trojan-TCP-TLS\" class=\"headerlink\" title=\"3.4.3 Trojan + TCP + TLS\"></a>3.4.3 Trojan + TCP + TLS</h4><p>Trojan 以其优秀的 HTTPS 伪装著称。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 例如 <code>Trojan-TCP-TLS</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>trojan</code> 。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空。</li>\n<li><strong>端口 (Port):</strong> 必须是 <code>443</code> 以获得最佳伪装效果。</li>\n<li><strong>密码 (Password):</strong> 设置一个强密码，客户端连接时需要使用。</li>\n<li><strong>传输 (Transport / Network):</strong> 选择 <code>tcp</code>。</li>\n<li>TLS 设置:<ul>\n<li><strong>启用 TLS (Enable TLS):</strong> <em>勾选</em>。</li>\n<li><strong>域名 (Domain name):</strong> 填写你拥有并已申请 SSL 证书的域名。</li>\n<li><strong>证书公钥文件路径 (Certificate File Path):</strong> 填写 SSL 证书的 <code>fullchain.pem</code> 文件路径。</li>\n<li><strong>证书私钥文件路径 (Key File Path):</strong> 填写 SSL 证书的 <code>privkey.pem</code> 文件路径。</li>\n<li><strong>ALPN:</strong> 建议填写 <code>h2,http/1.1</code> 以更好地模拟 HTTPS 流量。</li>\n<li><strong>Fallback (回落):</strong> 可以配置一个回落地址（如本地运行的 Web 服务器 <code>127.0.0.1:80</code>），当非 Trojan 协议访问该端口时，流量会被转发到此地址，增强伪装性。x-ui 中可能有相应配置项。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-4-4-Shadowsocks-AEAD-Ciphers\"><a href=\"#3-4-4-Shadowsocks-AEAD-Ciphers\" class=\"headerlink\" title=\"3.4.4 Shadowsocks (AEAD Ciphers)\"></a>3.4.4 Shadowsocks (AEAD Ciphers)</h4><p>简单高效的选择。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 例如 <code>SS-AEAD</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>shadowsocks</code> 。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空。</li>\n<li><strong>端口 (Port):</strong> 选择一个未被占用的端口。</li>\n<li><strong>密码 (Password):</strong> 设置一个强密码。</li>\n<li><strong>加密方式 (Encryption / Cipher):</strong> 强烈推荐使用 AEAD 加密，如 <code>2022-blake3-aes-256-gcm</code> (如果 x-ui 和客户端支持) 或 <code>aes-256-gcm</code>, <code>chacha20-ietf-poly1305</code> 。避免使用旧的非 AEAD 加密方式。</li>\n<li><strong>传输 (Network):</strong> 可以选择 <code>tcp</code> 或 <code>tcp,udp</code> 。</li>\n</ul>\n<h4 id=\"3-4-5-WireGuard\"><a href=\"#3-4-5-WireGuard\" class=\"headerlink\" title=\"3.4.5 WireGuard\"></a>3.4.5 WireGuard</h4><p>3x-ui 支持 WireGuard 作为入站协议 。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 例如 <code>WireGuard-VPN</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>wireguard</code>。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空。</li>\n<li><strong>端口 (Port):</strong> WireGuard 默认使用 UDP 协议，端口通常为 <code>51820</code>，但可以自定义。</li>\n<li><strong>私钥 (Private Key):</strong> 服务器的 WireGuard 私钥。x-ui 可能会自动生成或提供生成按钮。</li>\n<li><strong>公钥 (Public Key):</strong> 服务器的 WireGuard 公钥（由私钥派生）。</li>\n<li><strong>IP 地址 (Addresses):</strong> 分配给 WireGuard 服务器接口的内部 IP 地址和子网掩码，例如 <code>10.0.8.1/24</code>。</li>\n<li><strong>MTU:</strong> 通常保持默认或根据网络情况调整。</li>\n<li><strong>DNS:</strong> 可以指定推送给客户端的 DNS 服务器。</li>\n<li>对等端 (Peers) / 用户 (Clients):<ul>\n<li>为每个客户端生成独立的密钥对（公钥和私钥）。</li>\n<li>在服务器端添加客户端的公钥。</li>\n<li>为客户端分配一个隧道内的 IP 地址（如 <code>10.0.8.2</code>）。</li>\n<li>配置 <code>AllowedIPs</code>：对于客户端，通常设为 <code>0.0.0.0/0, ::/0</code> 以路由所有流量通过 VPN。在服务器端，对应客户端的 <code>AllowedIPs</code> 设为其分配的隧道 IP (如 <code>10.0.8.2/32</code>)。</li>\n</ul>\n</li>\n</ul>\n<p><strong>重要提示:</strong> 上述 x-ui 面板中的具体选项名称可能因 3x-ui 版本略有不同。请以你实际使用的面板界面为准。配置完成后，务必点击“添加”或“保存”并根据提示重启 Xray 服务使配置生效。</p>\n<h3 id=\"3-5-集成-Cloudflare-CDN-适用于-WebSocket-和-gRPC-节点\"><a href=\"#3-5-集成-Cloudflare-CDN-适用于-WebSocket-和-gRPC-节点\" class=\"headerlink\" title=\"3.5 集成 Cloudflare CDN (适用于 WebSocket 和 gRPC 节点)\"></a>3.5 集成 Cloudflare CDN (适用于 WebSocket 和 gRPC 节点)</h3><p>将 Cloudflare CDN 置于代理服务器之前，可以隐藏源服务器 IP、防御 DDoS 攻击，并可能为特定地区用户加速。这主要适用于基于 WebSocket 或 gRPC 的传输方式，因为它们能更好地兼容 HTTP/HTTPS 流量模式。</p>\n<ol>\n<li><strong>Cloudflare DNS 设置:</strong><ul>\n<li>登录 Cloudflare 账户，选择你的域名。</li>\n<li>进入 “DNS” 管理页面。</li>\n<li>添加一个 A 记录，将你的域名（或子域名，如 <code>proxy.yourdomain.com</code>）指向你的 VPS IP 地址 。</li>\n<li><strong>关键步骤 - SSL 证书申请期间:</strong> 在申请 SSL 证书（无论是通过 x-ui 的 ACME 还是手动用 Certbot）时，必须确保此 DNS 记录的“代理状态”(Proxy status) 为“仅限 DNS”(DNS Only)，即云朵图标为灰色 。这是因为 Let’s Encrypt 等 CA 需要直接验证你的服务器 IP。</li>\n<li><strong>关键步骤 - 启用 CDN:</strong> SSL 证书成功获取并配置到 x-ui 后，回到 Cloudflare DNS 设置页面，将该 A 记录的“代理状态”切换为“已代理”(Proxied)，即云朵图标变为橙色。这样流量才会经过 Cloudflare CDN 。</li>\n</ul>\n</li>\n<li><strong>Cloudflare SSL/TLS 模式:</strong><ul>\n<li>在 Cloudflare 仪表盘的 “SSL/TLS” -&gt; “概述” (Overview) 页面，将 SSL/TLS 加密模式设置为 <strong>“Full (Strict)”</strong> (完全（严格）) 。这确保浏览器到 Cloudflare 以及 Cloudflare 到源服务器的连接都是严格加密和验证的。</li>\n</ul>\n</li>\n<li><strong>在 Cloudflare 网络设置中启用 WebSocket 和 gRPC:</strong><ul>\n<li>在 Cloudflare 仪表盘的 “网络” (Network) 页面：<ul>\n<li>确保 “WebSockets” 开关已打开（通常默认开启）。</li>\n<li>如果使用 gRPC 传输，确保 “gRPC” 开关已打开 。</li>\n</ul>\n</li>\n<li><strong>gRPC 要求:</strong> 源服务器上的 gRPC 端点必须监听 443 端口，支持 TLS 和 HTTP/2，并通过 ALPN 广播 HTTP/2。请求的 <code>Content-Type</code> 头部应为 <code>application/grpc</code> 或 <code>application/grpc+&lt;message_type&gt;</code> 。</li>\n</ul>\n</li>\n<li><strong>x-ui 配置 VLESS + WebSocket + TLS + CDN:</strong><ul>\n<li>在 x-ui 中添加入站：<ul>\n<li><strong>协议 (Protocol):</strong> <code>vless</code>。</li>\n<li><strong>端口 (Port):</strong> 设置一个源服务器上的监听端口，例如 <code>8443</code> (或其他非 443 端口，因为 443 由 Cloudflare 面向公网)。</li>\n<li><strong>传输 (Transport / Network):</strong> 选择 <code>ws</code> (WebSocket) 。</li>\n<li><strong>路径 (Path):</strong> 设置一个 WebSocket 路径，例如 <code>/myvlessws</code>。这个路径需要隐蔽一些，不要使用过于常见的词汇。</li>\n<li><strong>Host (请求头):</strong> 填写你在 Cloudflare DNS 中设置并开启代理的域名（如 <code>proxy.yourdomain.com</code>）。</li>\n<li>TLS 设置:<ul>\n<li><strong>启用 TLS (Enable TLS):</strong> <em>勾选</em>。</li>\n<li><strong>域名 (Domain name):</strong> 填写你的域名（<code>proxy.yourdomain.com</code>）。</li>\n<li><strong>证书公钥文件路径 (Certificate File Path):</strong> 填写之前申请的 SSL 证书的 <code>fullchain.pem</code> 路径。</li>\n<li><strong>证书私钥文件路径 (Key File Path):</strong> 填写 SSL 证书的 <code>privkey.pem</code> 路径。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>客户端连接时，地址填 <code>proxy.yourdomain.com</code>，端口填 <code>443</code> (Cloudflare 的端口)，传输选 WebSocket，路径填 <code>/myvlessws</code>，底层传输安全选 TLS，SNI/Host 填 <code>proxy.yourdomain.com</code>。</li>\n</ul>\n</li>\n<li><strong>x-ui 配置 VMess + WebSocket + TLS + CDN:</strong><ul>\n<li>配置方法与 VLESS+WS+TLS 类似 ：<ul>\n<li><strong>协议 (Protocol):</strong> <code>vmess</code>。</li>\n<li><strong>端口 (Port):</strong> 源服务器监听端口，如 <code>8443</code>。</li>\n<li><strong>传输 (Transport / Network):</strong> <code>ws</code>。</li>\n<li><strong>路径 (Path):</strong> 例如 <code>/myvmessws</code>。</li>\n<li><strong>Host (请求头):</strong> 你的 CDN 域名。</li>\n<li><strong>TLS 设置:</strong> 同上，使用你的域名和证书。</li>\n</ul>\n</li>\n<li>客户端连接参数类似，注意协议选择 VMess 并填写 UUID 和 AlterID。</li>\n</ul>\n</li>\n<li><strong>x-ui 配置 Trojan + gRPC + TLS + CDN:</strong><ul>\n<li><strong>协议 (Protocol):</strong> <code>trojan</code>。</li>\n<li><strong>端口 (Port):</strong> 源服务器监听端口，如 <code>8443</code>。</li>\n<li><strong>传输 (Transport / Network):</strong> <code>grpc</code>。</li>\n<li><strong>gRPC 服务名称 (serviceName / Service Name):</strong> 设置一个服务名称，例如 <code>mytrojangrpc</code>。客户端连接时需要匹配。</li>\n<li><strong>TLS 设置:</strong> 同上，使用你的域名和证书。</li>\n<li>客户端连接时，地址填 CDN 域名，端口 <code>443</code>，传输选 gRPC，服务名称填 <code>mytrojangrpc</code>，底层传输安全选 TLS，SNI 填 CDN 域名。</li>\n<li><strong>Cloudflare gRPC 注意事项:</strong> Cloudflare WAF 对 gRPC 内容的检查有限，主要在连接阶段进行头部检查 。</li>\n</ul>\n</li>\n<li><strong>x-ui 配置 VLESS + gRPC + TLS + CDN:</strong><ul>\n<li>配置方法与 Trojan+gRPC+TLS 类似：<ul>\n<li><strong>协议 (Protocol):</strong> <code>vless</code>。</li>\n<li><strong>端口 (Port):</strong> 源服务器监听端口，如 <code>8443</code>。</li>\n<li><strong>传输 (Transport / Network):</strong> <code>grpc</code>。</li>\n<li><strong>gRPC 服务名称 (serviceName / Service Name):</strong> 例如 <code>myvlessgrpc</code>。</li>\n<li><strong>TLS 设置:</strong> 同上。</li>\n</ul>\n</li>\n<li>客户端连接参数类似。</li>\n</ul>\n</li>\n</ol>\n<p>使用 Cloudflare CDN 的主要好处是隐藏了源服务器的真实 IP 地址，这对于防止 IP 被直接攻击或封锁至关重要。此外，Cloudflare 的全球网络节点可以为地理位置较远的用户提供一定的访问速度优化（通过缓存静态内容和更优的路由，尽管对于动态代理流量，缓存效果有限）。同时，Cloudflare 也提供了基础的 DDoS 防护。然而，所有流量都经过 Cloudflare 网络，意味着 Cloudflare 有能力检查（在一定程度上，特别是对于未加密或解密后的流量）和记录这些流量，并且其自身也可能因为合规原因对特定类型的流量进行限制或阻断 。这是一个需要在便利性和潜在风险之间进行权衡的因素。</p>\n<h3 id=\"3-6-使用-Cloudflare-Workers-作为代理层\"><a href=\"#3-6-使用-Cloudflare-Workers-作为代理层\" class=\"headerlink\" title=\"3.6 使用 Cloudflare Workers 作为代理层\"></a>3.6 使用 Cloudflare Workers 作为代理层</h3><p>Cloudflare Workers 允许在 Cloudflare 的边缘节点上运行 JavaScript (或其他编译到 WebAssembly 的语言) 代码，可以用来拦截和修改请求/响应，或将请求代理到后端服务。</p>\n<ol>\n<li><p><strong>基本原理:</strong> 创建一个 Worker 脚本，该脚本接收来自客户端的请求，然后将这些请求转发到你的 Xray 源服务器。对于 WebSocket 流量，Worker 需要特殊处理以正确建立和维持双向连接。</p>\n</li>\n<li><p>Worker 脚本示例 (通用 WebSocket 代理):</p>\n<p>以下是一个非常基础的通用 WebSocket 代理 Worker 脚本的逻辑框架。请注意，直接代理任意 Xray 协议流量可能违反 Cloudflare 服务条款 ，且此脚本需要根据实际 Xray 配置（如路径、头部）进行调整。</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">//addEventListener(\"fetch\", event =&gt; {\n//  event.respondWith(handleRequest(event.request))\n//})\n//\n//async function handleRequest(request) {\n//  const url = new URL(request.url);\n//  const upgradeHeader = request.headers.get('Upgrade');\n//\n//  // 后端 Xray 服务器地址和端口，以及预期的 WebSocket 路径\n//  const backendHost = 'your_vps_ip_or_hidden_domain'; // 不应是 Cloudflare CDN 域名\n//  const backendPort = your_xray_ws_listen_port; // Xray WS 入站监听的真实端口\n//  const backendPath = '/your_xray_ws_path'; // Xray WS 入站配置的路径\n//\n//  // 构建后端 URL\n//  let backendUrl = `wss://&lt;span class=\"math-inline\"&gt;\\{backendHost\\}\\:&lt;/span&gt;{backendPort}${backendPath}`;\n//  if (url.protocol === 'http:') {\n//      backendUrl = `ws://&lt;span class=\"math-inline\"&gt;\\{backendHost\\}\\:&lt;/span&gt;{backendPort}${backendPath}`;\n//  }\n//\n//  if (upgradeHeader &amp;&amp; upgradeHeader.toLowerCase() === 'websocket') {\n//    // 处理 WebSocket 升级请求\n//    const [client, server] = Object.values(new WebSocketPair());\n//    server.accept();\n//\n//    try {\n//      const wsBackend = new WebSocket(backendUrl, request.headers); // 将原始请求头传给后端\n//\n//      wsBackend.addEventListener('open', () =&gt; {\n//        // 后端连接打开\n//      });\n//\n//      wsBackend.addEventListener('message', event =&gt; {\n//        server.send(event.data); // 从后端收到消息，转发给客户端\n//      });\n//\n//      wsBackend.addEventListener('close', event =&gt; {\n//        server.close(event.code, event.reason); // 后端关闭，关闭客户端连接\n//      });\n//\n//      wsBackend.addEventListener('error', event =&gt; {\n//        server.close(1011, 'Backend WebSocket error'); // 后端错误\n//      });\n//\n//      server.addEventListener('message', event =&gt; {\n//        wsBackend.send(event.data); // 从客户端收到消息，转发给后端\n//      });\n//\n//      server.addEventListener('close', event =&gt; {\n//        wsBackend.close(event.code, event.reason); // 客户端关闭，关闭后端连接\n//      });\n//\n//      server.addEventListener('error', event =&gt; {\n//        wsBackend.close(1011, 'Client WebSocket error'); // 客户端错误\n//      });\n//\n//      return new Response(null, { status: 101, webSocket: client });\n//    } catch (e) {\n//      return new Response('WebSocket backend connection failed: ' + e.toString(), { status: 502 });\n//    }\n//  } else {\n//    // 对于非 WebSocket 请求，可以直接转发或返回错误\n//    // 如果 Xray 配置了 HTTP 回落，这里可以尝试转发 HTTP 请求\n//    // url.hostname = backendHost; // 注意：这仅适用于 HTTP 代理，不适用于 Xray 协议本身\n//    // url.port = backendPort.toString();\n//    // return fetch(new Request(url, request));\n//    return new Response('This Worker is for WebSocket proxying.', { status: 400 });\n//  }\n//}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意:</p>\n<p> 上述脚本是一个高度简化的示例，用于说明概念。实际用于 Xray 的 Worker 脚本可能需要更复杂的逻辑来处理特定的 Xray WebSocket 路径、头部信息（如 Host头部需要正确设置为 Xray 配置中的值）以及可能的认证。</p>\n<p><code>keivanipchihagh/x-ui</code> 仓库中可能包含更具体的 Worker 脚本 (scripts/worker.js)，建议参考其实现 。Cloudflare 官方文档也提供了 WebSocket 处理的示例 。</p>\n</li>\n<li><p>部署和路由设置:</p>\n<ul>\n<li>在 Cloudflare 仪表盘创建 Worker，将上述脚本（或适配后的脚本）粘贴进去并部署 。</li>\n<li>为 Worker 配置一个路由，例如 <code>worker.yourdomain.com/</code>，这样访问此路径的流量会由 Worker 处理。</li>\n</ul>\n</li>\n<li><p>Xray 入站配置:</p>\n<ul>\n<li>Xray 的 WebSocket 入站配置应监听一个本地端口（或可被 Worker 访问的地址），其路径和 Host 设置需要与 Worker 脚本转发时的目标一致。TLS 可以在源服务器上配置，也可以由 Worker 到源服务器的连接处理（如果源服务器配置了 TLS）。</li>\n</ul>\n</li>\n<li><p>优缺点:</p>\n<ul>\n<li><strong>优点:</strong> 灵活性高，可以自定义请求处理逻辑，实现更复杂的伪装。IP 地址由 Cloudflare Worker 提供。</li>\n<li><strong>缺点:</strong> Worker 有执行时间、CPU 时间和内存限制。配置比 CDN 复杂。同样存在 Cloudflare 服务条款的适用问题。</li>\n</ul>\n</li>\n</ol>\n<p>Cloudflare Workers 提供了一种比传统 CDN 更细致的流量控制和伪装能力。例如，Worker 可以根据请求的特定头部或路径，将流量路由到不同的后端 Xray 服务，甚至可以动态修改请求/响应内容以增强混淆。这种可编程性使得 Workers 成为一种强大的工具，但也要求用户具备一定的编程知识。然而，需要强调的是，滥用 Cloudflare 服务（包括 Workers）进行违反其服务条款的活动是被禁止的。</p>\n<h3 id=\"3-7-使用-Cloudflare-Tunnel-Argo-Tunnel-代理-TCP-节点\"><a href=\"#3-7-使用-Cloudflare-Tunnel-Argo-Tunnel-代理-TCP-节点\" class=\"headerlink\" title=\"3.7 使用 Cloudflare Tunnel (Argo Tunnel) 代理 TCP 节点\"></a>3.7 使用 Cloudflare Tunnel (Argo Tunnel) 代理 TCP 节点</h3><p>Cloudflare Tunnel (以前称为 Argo Tunnel) 可以安全地将你的本地服务（包括运行在 VPS 上的 Xray 服务）暴露到互联网，而无需在防火墙上打开入站端口。它通过在你的服务器上运行一个轻量级守护进程 <code>cloudflared</code>，该进程会与 Cloudflare 的边缘网络建立一个持久的、仅出站的加密连接。</p>\n<ol>\n<li><p><strong>基本原理:</strong> <code>cloudflared</code> 守护进程将本地 Xray 服务（如 VLESS+TCP、Trojan+TCP、Shadowsocks+TCP）的流量通过这个安全隧道发送到 Cloudflare 边缘，Cloudflare 再将公网用户的请求通过隧道转发给你的 Xray 服务。</p>\n</li>\n<li><p>安装和配置 <code>cloudflared</code>:</p>\n<ul>\n<li>在你的 VPS 上下载并安装 <code>cloudflared</code> 。</li>\n<li>登录 <code>cloudflared</code>：<code>cloudflared tunnel login</code>，这会在浏览器中打开 Cloudflare 登录页面，授权后 <code>cloudflared</code> 会下载一个证书文件。</li>\n<li>创建隧道：<code>cloudflared tunnel create &lt;your_tunnel_name&gt;</code>。记下返回的隧道 UUID。</li>\n<li>为隧道创建 DNS 记录（指向公共主机名）：<code>cloudflared tunnel route dns &lt;your_tunnel_name_or_UUID&gt; &lt;proxy.yourdomain.com&gt;</code>。</li>\n</ul>\n</li>\n<li><p>配置 <code>cloudflared</code> 以暴露 TCP 服务:</p>\n<ul>\n<li><p>创建一个配置文件（通常是 </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">~/.cloudflared/config.yml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 或在 </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">/etc/cloudflared/<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 目录），内容类似如下 ：</p>\n<pre class=\"line-numbers language-YAML\" data-language=\"YAML\"><code class=\"language-YAML\">tunnel: &lt;your_tunnel_UUID&gt; # 从 'cloudflared tunnel create' 命令获取\ncredentials-file: /root/.cloudflared/&lt;your_tunnel_UUID&gt;.json # 证书文件路径\n\ningress:\n  - hostname: proxy.yourdomain.com # 你希望用户连接的公共域名\n    service: tcp://localhost:&lt;xray_listen_port&gt; # Xray 服务监听的本地地址和端口\n  - service: http_status:404 # 捕获所有其他未匹配的请求<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将 <code>&lt;your_tunnel_UUID&gt;</code>、<code>&lt;proxy.yourdomain.com&gt;</code> 和 <code>&lt;xray_listen_port&gt;</code>替换为实际值。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>运行隧道:</strong> <code>cloudflared tunnel run &lt;your_tunnel_name_or_UUID&gt;</code> 或者，将 <code>cloudflared</code> 安装为系统服务以便开机自启：<code>sudo cloudflared service install</code> (需要先有配置文件)。</p>\n</li>\n<li><p>Xray 入站配置:</p>\n<ul>\n<li>Xray 的 TCP 类型入站（如 VLESS+TCP, Trojan+TCP, Shadowsocks+TCP）应配置为监听 <code>localhost:&lt;xray_listen_port&gt;</code>，与 <code>cloudflared</code> 配置文件中的 <code>service</code> 地址对应。</li>\n<li>由于 TLS 终结发生在 Cloudflare 边缘，Xray 源服务器上的这些 TCP 入站通常不需要再配置 TLS。客户端连接时，地址填写 <code>proxy.yourdomain.com</code>，端口为 Cloudflare 支持的端口（如 443，Cloudflare 会处理 TLS）。</li>\n</ul>\n</li>\n<li><p>优缺点与限制:</p>\n<ul>\n<li><strong>优点:</strong> 无需公网 IP 或开放防火墙端口即可安全暴露服务，IP 地址由 Cloudflare 提供。</li>\n<li>缺点:<ul>\n<li><strong>gRPC 限制:</strong> 通过公共主机名的 Cloudflare Tunnel 目前不支持 gRPC 流量 。gRPC 可以通过隧道的私网路由功能与 WARP 客户端结合使用。</li>\n<li><strong>UDP 限制:</strong> 通过公共主机名代理任意 UDP 流量不是标准功能。UDP 通常需要结合 Cloudflare WARP 客户端和私网路由 。对于 WireGuard (UDP)，直接通过 Tunnel 的公共主机名暴露可能不可行或效果不佳。</li>\n<li><strong>性能:</strong> 相比直接连接或 CDN，Tunnel 增加了一个 <code>cloudflared</code> 进程和到 Cloudflare 边缘的额外网络跃点，可能会引入一些延迟。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>Cloudflare Tunnel 为那些不适合通过 CDN（如原始 TCP 协议）或不希望直接暴露服务器 IP 的场景提供了一个有价值的解决方案。它特别适用于隐藏家庭网络或动态 IP 环境下的服务器。然而，用户必须清楚其对 gRPC 和 UDP 等协议在公共主机名模式下的限制。</p>\n<h3 id=\"3-8-必备表格：Cloudflare-服务用于代理的对比\"><a href=\"#3-8-必备表格：Cloudflare-服务用于代理的对比\" class=\"headerlink\" title=\"3.8 必备表格：Cloudflare 服务用于代理的对比\"></a>3.8 必备表格：Cloudflare 服务用于代理的对比</h3><p>为了帮助用户根据自身需求选择最合适的 Cloudflare 服务来增强其 Xray 节点，下表对 Cloudflare CDN、Workers 和 Tunnel 的关键特性进行了对比：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Cloudflare CDN (Orange Cloud DNS)</strong></th>\n<th><strong>Cloudflare Workers</strong></th>\n<th><strong>Cloudflare Tunnel (Public Hostname)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>主要优势</strong></td>\n<td>隐藏源 IP, DDoS 防护, 静态内容缓存, 广泛的 HTTP(S) 兼容性</td>\n<td>高度灵活, 边缘计算, 可自定义请求/响应逻辑, 动态路由, IP 来自 CF</td>\n<td>无需公网 IP/开放端口, 安全暴露本地服务, IP 来自 CF</td>\n</tr>\n<tr>\n<td><strong>适用协议/传输</strong></td>\n<td>HTTP, HTTPS, WebSocket, gRPC (有限制)</td>\n<td>HTTP, HTTPS, WebSocket (可编程处理)</td>\n<td>TCP, HTTP, HTTPS (gRPC, UDP 在公共主机名模式下受限)</td>\n</tr>\n<tr>\n<td><strong>IP 隐藏</strong></td>\n<td>是 (源服务器 IP)</td>\n<td>是 (源服务器 IP, Worker 本身 IP 是 CF 的)</td>\n<td>是 (源服务器 IP)</td>\n</tr>\n<tr>\n<td><strong>TLS 处理</strong></td>\n<td>浏览器 &lt;-&gt; CF (CF 证书), CF &lt;-&gt; 源服务器 (源服务器证书, 需 Full Strict)</td>\n<td>可自定义 (浏览器 &lt;-&gt; Worker &lt;-&gt; 源)</td>\n<td>浏览器 &lt;-&gt; CF (CF 证书), Tunnel 内部加密, CF &lt;-&gt; 源 (通常无需 TLS)</td>\n</tr>\n<tr>\n<td><strong>性能影响</strong></td>\n<td>取决于地理位置和缓存, 可能增加延迟, Argo 可优化</td>\n<td>Worker 执行有开销, 但边缘执行可减少延迟</td>\n<td>增加 <code>cloudflared</code> 跃点, 可能有额外延迟</td>\n</tr>\n<tr>\n<td><strong>配置复杂度</strong></td>\n<td>较低 (DNS 切换)</td>\n<td>中到高 (需要编写和部署脚本)</td>\n<td>中等 (安装和配置 <code>cloudflared</code>)</td>\n</tr>\n<tr>\n<td><strong>主要限制</strong></td>\n<td>对非 HTTP(S) 协议支持不佳, 可能被 WAF/Bot 管理误判</td>\n<td>执行时间/资源限制, 服务条款约束</td>\n<td>gRPC/UDP 在公共主机名模式下支持不佳</td>\n</tr>\n</tbody></table>\n<p><strong>选择考量:</strong></p>\n<ul>\n<li>如果你的 Xray 节点使用 <strong>WebSocket 或 gRPC</strong> 传输，并且希望利用 CDN 的 IP 隐藏和 DDoS 防护，<strong>Cloudflare CDN</strong> 是首选，配置也最简单。</li>\n<li>如果你需要更高级的流量伪装、自定义路由逻辑，或者希望在边缘处理一些逻辑（例如，根据特定条件选择后端），并且不介意编写代码，<strong>Cloudflare Workers</strong> 提供了极大的灵活性。</li>\n<li>如果你的 Xray 节点使用 <strong>纯 TCP 协议</strong> (如 VLESS/Trojan/SS over TCP)，或者你的服务器没有公网 IP / 不想开放入站端口，<strong>Cloudflare Tunnel</strong> 是一个很好的选择，但要注意其对 gRPC 和 UDP 的限制。</li>\n</ul>\n<h2 id=\"第四部分：安全与优化\"><a href=\"#第四部分：安全与优化\" class=\"headerlink\" title=\"第四部分：安全与优化\"></a>第四部分：安全与优化</h2><p>搭建和使用科学上网节点时，安全性和性能优化是不可忽视的重要环节。</p>\n<h3 id=\"4-1-VPS-服务器安全基础\"><a href=\"#4-1-VPS-服务器安全基础\" class=\"headerlink\" title=\"4.1 VPS 服务器安全基础\"></a>4.1 VPS 服务器安全基础</h3><p>保护承载 Xray 服务的 VPS 是首要任务。</p>\n<ul>\n<li>防火墙配置 (UFW/iptables):<ul>\n<li>UFW (Uncomplicated Firewall) 是一个用户友好的 iptables 前端。启用 UFW 并配置规则可以有效控制服务器的网络访问 。</li>\n<li>基本操作:<ul>\n<li>启用 UFW: <code>sudo ufw enable</code></li>\n<li>查看状态: <code>sudo ufw status verbose</code></li>\n<li>允许特定端口: <code>sudo ufw allow &lt;port&gt;/&lt;protocol&gt;</code></li>\n<li>拒绝特定端口: <code>sudo ufw deny &lt;port&gt;/&lt;protocol&gt;</code></li>\n</ul>\n</li>\n<li>推荐规则 (详见文末表格):<ul>\n<li>默认拒绝所有入站连接: <code>sudo ufw default deny incoming</code></li>\n<li>默认允许所有出站连接: <code>sudo ufw default allow outgoing</code></li>\n<li>允许 SSH 连接（建议使用非标准端口，并限制来源 IP）: <code>sudo ufw allow from &lt;your_trusted_IP&gt; to any port &lt;ssh_port&gt; proto tcp</code> 。</li>\n<li>允许 x-ui 面板访问端口（强烈建议限制来源 IP）: <code>sudo ufw allow from &lt;your_trusted_IP&gt; to any port &lt;xui_panel_port&gt; proto tcp</code>。</li>\n<li>允许代理服务端口（通常是 443/TCP 用于 TLS 节点，以及 WireGuard 的 UDP 端口）: <code>sudo ufw allow 443/tcp</code>, <code>sudo ufw allow &lt;wireguard_udp_port&gt;/udp</code> 。</li>\n<li>如果使用 Certbot 的 HTTP-01 验证，需要临时允许 80/TCP: <code>sudo ufw allow 80/tcp</code> (验证后可考虑移除或限制)。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>SSH 加固:<ul>\n<li><strong>禁用 root 用户密码登录:</strong> 编辑 <code>/etc/ssh/sshd_config</code>，设置 <code>PermitRootLogin prohibit-password</code> (或 <code>no</code>)。</li>\n<li><strong>使用密钥对认证:</strong> 推荐禁用密码认证 (<code>PasswordAuthentication no</code>)，仅使用 SSH 密钥对登录 。</li>\n<li><strong>更改默认 SSH 端口:</strong> 将默认的 22 端口更改为一个不常用的高位端口，以减少自动扫描攻击 。</li>\n</ul>\n</li>\n<li>定期更新:<ul>\n<li>保持操作系统和所有已安装软件包的最新状态，以修复已知的安全漏洞：<code>sudo apt update &amp;&amp; sudo apt upgrade -y</code> 。</li>\n</ul>\n</li>\n<li>其他安全措施:<ul>\n<li><strong>Fail2ban:</strong> 安装并配置 Fail2ban 可以监控日志文件（如 SSH 登录失败、x-ui 面板登录尝试），并在检测到恶意行为（如暴力破解）时自动封禁来源 IP 。3x-ui 面板本身也集成了 IP 限制功能，需要安装 Fail2ban 配合使用 。</li>\n<li><strong>禁用不必要的服务:</strong> 关闭服务器上所有不需要运行的网络服务，以减少攻击面。</li>\n</ul>\n</li>\n</ul>\n<p>采取多层次的安全措施至关重要。仅仅依赖 Cloudflare 的保护或一个强密码是不够的。VPS 自身的安全（防火墙、SSH加固、及时更新）、x-ui 面板的安全（强密码、HTTPS访问、访问IP限制）以及代理协议自身的安全性（如TLS、REALITY）共同构成了一个纵深防御体系。每一层都针对不同类型的威胁提供防护，从而整体上提升节点的安全性。</p>\n<h3 id=\"4-2-Cloudflare-安全设置\"><a href=\"#4-2-Cloudflare-安全设置\" class=\"headerlink\" title=\"4.2 Cloudflare 安全设置\"></a>4.2 Cloudflare 安全设置</h3><p>Cloudflare 提供了多种安全功能，但在用于代理节点时，某些设置可能需要调整以避免对代理流量的干扰。</p>\n<ul>\n<li>WAF 自定义规则 (Web Application Firewall):<ul>\n<li>Cloudflare WAF 可能会将某些代理流量模式识别为可疑并进行拦截。如果遇到这种情况，可以尝试在 Cloudflare WAF 设置中创建自定义规则，针对代理节点的特定路径（如 WebSocket 路径）或来源（如果固定）选择“跳过”(Skip) WAF 的部分或全部分析模块 。</li>\n<li>例如，如果 WebSocket 路径是 <code>/secretpath</code>，可以创建规则：<code>If URI Path equals /secretpath Then Skip (All WAF managed rules, Cloudflare OWASP Core Ruleset)</code>。</li>\n<li><strong>重要警示:</strong> Cloudflare 的服务条款明确禁止未经授权使用其网络提供代理或 VPN 服务 68。虽然技术上可以通过 WAF 规则绕过检查，但这并不意味着这种用法符合服务条款。用户应自行承担相关风险。</li>\n</ul>\n</li>\n<li>页面规则 (Page Rules) (主要用于 WebSocket 优化/绕过):<ul>\n<li>对于 WebSocket 连接使用的特定路径，可以考虑设置页面规则 ：<ul>\n<li>将“缓存级别”(Cache Level) 设置为“绕过”(Bypass)，因为代理流量通常是动态的，不应被缓存。</li>\n<li>在极端情况下，如果 Cloudflare 的安全级别过高导致连接问题，可以考虑将该路径的“安全级别”(Security Level) 设置为“基本关闭”(Essentially Off) 或“禁用安全性”(Disable Security)。但这样做会降低该路径的安全防护，务必谨慎使用，并尽可能缩小规则匹配范围。</li>\n</ul>\n</li>\n<li>确保 Cloudflare “网络” (Network) 设置中的 “WebSockets” 功能已开启（通常默认开启）。</li>\n</ul>\n</li>\n<li>机器人管理 (Bot Management) 注意事项:<ul>\n<li>Cloudflare 的“机器人战斗模式”(Bot Fight Mode) 或“超级机器人战斗模式”(Super Bot Fight Mode) 可能会将代理客户端的连接行为归类为“可能是自动程序”并进行质询或阻止 。</li>\n<li>如果代理连接因此受阻，可能需要禁用机器人战斗模式，或者（如果可能且符合服务条款）创建 WAF 规则来跳过对特定代理主机名或路径的机器人检测。</li>\n</ul>\n</li>\n<li>SSL/TLS 优化器 (SSL/TLS Recommender) 与自动 HTTPS 重写:<ul>\n<li>这些功能通常是有益的，但务必确保最终的 SSL/TLS 加密模式保持在 “Full (Strict)” 。</li>\n</ul>\n</li>\n<li>HTTP/2 到源站 与 HTTP/3:<ul>\n<li>在 Cloudflare “网络” 设置中启用 “HTTP/2 到源站” 通常是推荐的，特别是当源服务器（Xray）也支持 HTTP/2 时（例如使用 gRPC 传输）。HTTP/3 (QUIC) 也可以考虑启用，但要确保 Xray 和客户端都支持。</li>\n</ul>\n</li>\n</ul>\n<p>Cloudflare 的安全功能是一把双刃剑。它们在保护网站免受恶意攻击方面非常有效 7，但其某些启发式检测机制也可能将正常的代理流量误判为可疑活动，从而导致连接问题。因此，用户需要理解这些设置如何工作，并学会在 Cloudflare 仪表盘中进行细致调整，以便在获得 Cloudflare 保护的同时，确保代理服务的顺畅运行。这通常需要在安全性和可用性之间找到一个平衡点。</p>\n<h3 id=\"4-3-进阶抗封锁技巧\"><a href=\"#4-3-进阶抗封锁技巧\" class=\"headerlink\" title=\"4.3 进阶抗封锁技巧\"></a>4.3 进阶抗封锁技巧</h3><p>随着审查技术的不断发展，单一的代理协议和配置可能不足以保证长期稳定。以下是一些进阶的抗封锁思路和技术：</p>\n<ul>\n<li><strong>域名伪装 (Domain Fronting - 概念性):</strong> 传统意义上的域名伪装（通过在 TLS ClientHello 中使用一个 SNI，而在 HTTP Host 头中使用另一个域名，并依赖 CDN 的路由行为）在很大程度上已被主流 CDN 提供商（包括 Cloudflare）限制。然而，Cloudflare Workers 可以在一定程度上实现类似效果：Worker 脚本可以接收来自一个“干净”域名的请求，然后根据内部逻辑（如特定路径或头部）将请求转发到实际的、可能被审查的后端代理服务器。这需要精心设计的 Worker 脚本和 Xray 配置。</li>\n<li><strong>使用“干净”的 IP 地址和信誉良好的 VPS 提供商:</strong> 某些 IP 地址段（例如来自大型、知名云服务商的 IP）可能受到更严格的审查或更容易被列入黑名单。选择一些较小众、信誉良好或专门针对此类应用的 VPS 提供商，并获取相对“干净”的 IP 地址，可能有助于提高节点的存活率 。</li>\n<li><strong>IP 地址轮换 (高级):</strong> 这是一项更复杂的技术，通常涉及拥有多个 VPS 或使用支持 IP 轮换的服务。通过定期更换代理服务器的出口 IP 地址，可以降低单个 IP 因长时间暴露而被封锁的风险。</li>\n<li>模仿真实网站流量:<ul>\n<li><strong>真实的回落网站:</strong> 对于 Trojan 或其他配置了回落 (Fallback) 功能的协议，确保回落指向一个真实、内容丰富且在目标审查区域内访问正常的网站。这个网站应该有合法的 TLS 证书。</li>\n<li><strong>WebSocket 路径与 Host:</strong> 对于 WebSocket 类型的节点，其连接路径 (Path) 和 Host 头部应尽量模仿正常 Web 应用的 API 请求。避免使用过于简单或可识别的路径。</li>\n</ul>\n</li>\n<li><strong>TLS 指纹伪装 (uTLS):</strong> 许多审查系统会分析 TLS 握手过程中的客户端指纹（Client Hello），以识别可疑的非浏览器流量。Xray 核心及其客户端（如 Nekoray, V2RayNG, ShadowRocket 等）通常支持 uTLS 功能，允许客户端在发起 TLS 连接时模仿特定浏览器（如 Chrome, Firefox）或操作系统的 TLS 指纹 。在客户端配置中启用并选择合适的 uTLS 指纹，是增强伪装性的重要手段。对于 REALITY 协议，服务器端也会参与指纹的伪装。</li>\n<li><strong>避免使用常见代理端口 (有限效果):</strong> 虽然将代理服务运行在非标准端口（而不是常见的 80, 443, 1080 等）可能避开一些非常初级的端口扫描，但这对于能够进行深度包检测的审查系统来说几乎没有作用。对于基于 TLS 的代理协议（如 VLESS/VMess/Trojan + TLS/WS/gRPC/REALITY），使用标准的 HTTPS 端口 <code>443</code> 通常是最佳选择，因为它最符合伪装成正常 HTTPS 流量的目的。</li>\n<li><strong>流量分割与分流:</strong> 不在所有流量上都使用代理。例如，可以使用 PAC 文件、浏览器扩展或客户端的路由规则，仅对需要访问受限资源的域名或 IP 地址启用代理，而国内或其他可直连的流量则直接访问。这不仅可以节省代理服务器的带宽，减少不必要的性能开销，还能降低代理服务器因大量非敏感流量通过而被注意到的风险。</li>\n</ul>\n<p>网络审查与反审查技术始终处于动态的“军备竞赛”之中。没有任何一种技术或配置可以保证永久有效。审查方会不断分析和封锁已知的协议特征和服务器 IP，而开发者和用户则会不断寻找新的协议、传输方式和伪装技巧来应对。因此，保持对新技术和封锁动态的关注，并准备好根据需要调整和更新自己的节点配置，是维持科学上网连接稳定的关键。</p>\n<h3 id=\"4-4-性能优化与资源消耗考量\"><a href=\"#4-4-性能优化与资源消耗考量\" class=\"headerlink\" title=\"4.4 性能优化与资源消耗考量\"></a>4.4 性能优化与资源消耗考量</h3><p>节点的性能直接影响用户体验，而资源消耗则关系到 VPS 的成本和承载能力。</p>\n<ul>\n<li>协议选择对性能的影响:<ul>\n<li><strong>VLESS vs VMess:</strong> VLESS 由于其无内置加密和更简洁的头部设计，通常比 VMess 具有更低的延迟和更高的吞吐量，资源消耗也更少 。</li>\n<li><strong>WireGuard:</strong> 以其极高的速度和低资源占用著称，是性能优先场景下的优秀选择，但其基于 UDP，可能受网络环境影响 。</li>\n<li><strong>Shadowsocks:</strong> 作为一种轻量级协议，性能表现良好，资源占用低 。</li>\n<li><strong>Trojan:</strong> 性能接近原生 HTTPS，通常表现不错 。</li>\n</ul>\n</li>\n<li>传输方式对性能的影响:<ul>\n<li><strong>TCP:</strong> 作为基础传输协议，稳定可靠，但纯 TCP 传输（即使套了 TLS）的特征相对容易被识别。</li>\n<li><strong>WebSocket (WS):</strong> 为代理流量增加了额外的 HTTP 头部和 WebSocket 帧封装，会带来一定的性能开销。然而，它是通过 CDN 转发流量的常用方式。Xray 的一些配置（如 VLESS 的回落分流到 WS）据称性能优于传统的 Nginx 反代 WS 。</li>\n<li><strong>gRPC:</strong> 基于 HTTP/2，支持多路复用，可以减少连接建立的开销，对移动端和需要频繁短连接的场景友好，性能通常优于 WebSocket。</li>\n<li><strong>XTLS:</strong> 专门为 VLESS 和 Trojan 设计，通过减少 TLS 加密层级来优化性能，理论上可以达到接近或优于裸 TCP+TLS 的性能 。</li>\n</ul>\n</li>\n<li><strong>服务器硬件配置:</strong> CPU 的核心数和主频、内存大小以及网络带宽都会直接影响 Xray 服务器能处理的并发连接数和总吞吐量。高负载情况下，性能瓶颈可能出现在 CPU（加解密和协议处理）或网络I/O上 47。虽然难以给出精确的 Xray 资源消耗数据，但可以参考类似代理软件（如 Envoy）的指标：每秒处理 1000 个请求（1KB负载）大约需要 0.2-0.5 vCPU 和 40-60MB 内存 。</li>\n<li><strong>Cloudflare 引入的延迟:</strong> 使用 Cloudflare CDN、Workers 或 Tunnel 会在客户端和源服务器之间增加额外的网络跃点，这不可避免地会引入一定的延迟。Cloudflare 的 Argo Smart Routing (付费功能) 声称可以优化路由，减少延迟。对于 WebSocket 流量，Cloudflare 本身对连接的处理也可能影响性能。</li>\n<li><strong>Keepalives (连接保持):</strong> 对于长时间活动的连接，特别是 WebSocket，配置适当的 Keepalive 机制非常重要，可以防止连接因网络中间设备（如 NAT、防火墙）的超时而意外断开 。Xray 和客户端通常都有相关配置。</li>\n<li><strong>启用 BBR 拥塞控制算法:</strong> 在 VPS 服务器上启用 TCP BBR 拥塞控制算法，通常可以显著改善高延迟、有一定丢包率网络环境下的 TCP 连接吞吐量。</li>\n<li><strong>内核参数优化:</strong> 调整 Linux 内核参数，如最大文件描述符数 (<code>ulimit -n</code>)、TCP 连接队列大小 (<code>net.core.somaxconn</code>, <code>net.ipv4.tcp_max_syn_backlog</code>) 等，在高并发场景下可能有助于提升性能。</li>\n</ul>\n<p>性能并非单一因素决定的，而是协议、传输方式、加密强度、服务器负载、网络路径（包括 Cloudflare 的参与）、客户端与服务器硬件，乃至操作系统内核调优等多种因素综合作用的结果。例如，VLESS+XTLS+REALITY 在直连情况下可能速度最快，但对于与服务器地理位置遥远的用户，VLESS+WS+TLS+CDN 由于 CDN 的边缘节点效应，尽管 WebSocket 自身有开销，却可能带来更好的实际访问体验。因此，优化是一个需要综合考虑并根据具体场景进行调整的过程。</p>\n<h3 id=\"必备表格：推荐的-UFW-防火墙规则\"><a href=\"#必备表格：推荐的-UFW-防火墙规则\" class=\"headerlink\" title=\"必备表格：推荐的 UFW 防火墙规则\"></a>必备表格：推荐的 UFW 防火墙规则</h3><p>以下表格提供了一组针对运行 x-ui 和 Xray 代理服务的 VPS 的推荐 UFW 防火墙规则。请根据你的实际端口配置进行调整。</p>\n<table>\n<thead>\n<tr>\n<th><strong>规则描述</strong></th>\n<th><strong>UFW 命令 (示例)</strong></th>\n<th><strong>端口 (示例)</strong></th>\n<th><strong>协议</strong></th>\n<th><strong>注意事项</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>允许来自特定 IP 的 SSH 访问</td>\n<td><code>sudo ufw allow from 1.2.3.4 to any port 2222 proto tcp</code></td>\n<td>2222</td>\n<td>TCP</td>\n<td>将 <code>1.2.3.4</code> 替换为你的可信管理 IP，<code>2222</code> 替换为你的 SSH 端口。</td>\n</tr>\n<tr>\n<td>允许来自特定 IP 的 x-ui 面板访问</td>\n<td><code>sudo ufw allow from 1.2.3.4 to any port 54321 proto tcp</code></td>\n<td>54321</td>\n<td>TCP</td>\n<td>将 <code>1.2.3.4</code> 替换为你的可信管理 IP，<code>54321</code> 替换为你的 x-ui 面板端口。</td>\n</tr>\n<tr>\n<td>允许 HTTPS/TLS 代理流量 (通用)</td>\n<td><code>sudo ufw allow 443/tcp</code></td>\n<td>443</td>\n<td>TCP</td>\n<td>用于 VLESS/VMess/Trojan 等协议的 TLS, WS+TLS, gRPC+TLS, REALITY。</td>\n</tr>\n<tr>\n<td>允许 HTTP 流量 (SSL 证书验证)</td>\n<td><code>sudo ufw allow 80/tcp</code></td>\n<td>80</td>\n<td>TCP</td>\n<td>主要用于 Let’s Encrypt HTTP-01 验证。验证完成后可考虑限制或移除此规则。</td>\n</tr>\n<tr>\n<td>允许 WireGuard 流量</td>\n<td><code>sudo ufw allow 51820/udp</code></td>\n<td>51820</td>\n<td>UDP</td>\n<td>将 <code>51820</code> 替换为你的 WireGuard 监听端口。</td>\n</tr>\n<tr>\n<td>允许 Xray 源服务器监听端口 (如果使用 CDN/Tunnel)</td>\n<td><code>sudo ufw allow 8443/tcp</code></td>\n<td>8443</td>\n<td>TCP</td>\n<td>示例端口，用于 CDN/Tunnel 回源。应仅允许来自 Cloudflare IP 段的访问。</td>\n</tr>\n<tr>\n<td>默认拒绝所有其他入站连接</td>\n<td><code>sudo ufw default deny incoming</code></td>\n<td>N/A</td>\n<td>N/A</td>\n<td>重要的安全基线。</td>\n</tr>\n<tr>\n<td>默认允许所有出站连接</td>\n<td><code>sudo ufw default allow outgoing</code></td>\n<td>N/A</td>\n<td>N/A</td>\n<td>允许服务器主动向外发起连接。</td>\n</tr>\n<tr>\n<td>启用 UFW</td>\n<td><code>sudo ufw enable</code></td>\n<td>N/A</td>\n<td>N/A</td>\n<td>在所有规则配置完成后执行。</td>\n</tr>\n</tbody></table>\n<p><strong>注意:</strong></p>\n<ul>\n<li>在执行 <code>sudo ufw enable</code> 之前，务必确保已添加允许 SSH 访问的规则，否则可能导致无法远程连接服务器。</li>\n<li>对于通过 CDN 或 Tunnel 回源的端口（如上例中的 8443/TCP），更安全的做法是仅允许来自 Cloudflare IP 地址段的流量访问这些端口。Cloudflare 公布了其 IP 范围列表，可以用于配置更精细的防火墙规则。</li>\n<li>定期审查和更新防火墙规则，确保其符合当前的安全需求。</li>\n</ul>\n<p>防火墙是服务器安全的第一道防线，正确配置 UFW 对于保护你的 Xray 节点免受未经授权的访问和潜在攻击至关重要 54。上述规则提供了一个基础模板，用户应根据自己的具体服务端口和安全策略进行调整。</p>\n<h2 id=\"第五部分：客户端配置与使用\"><a href=\"#第五部分：客户端配置与使用\" class=\"headerlink\" title=\"第五部分：客户端配置与使用\"></a>第五部分：客户端配置与使用</h2><p>成功搭建节点后，需要在客户端设备上进行相应配置才能连接和使用。</p>\n<h3 id=\"5-1-主流客户端介绍\"><a href=\"#5-1-主流客户端介绍\" class=\"headerlink\" title=\"5.1 主流客户端介绍\"></a>5.1 主流客户端介绍</h3><p>市面上有众多支持 Xray 核心及其协议的客户端软件，覆盖各类操作系统平台。</p>\n<ul>\n<li>跨平台:<ul>\n<li><strong>Nekoray / Nekobox:</strong> 支持 Windows, Linux, Android，并有非官方 macOS 版本。功能强大，支持 Shadowsocks (包括 SS-2022), VLESS, VMess, Trojan, XTLS-Reality 等多种协议和特性 。</li>\n</ul>\n</li>\n<li>Android:<ul>\n<li><strong>V2RayNG:</strong> 基于 Xray 核心，支持 Xray 的所有协议和功能，界面简洁，广受欢迎 。</li>\n<li><strong>Hiddify (FoXray Hiddify):</strong> 提及与 3X-UI VLESS REALITY 配合使用，可能基于 FoXray 或类似核心 。</li>\n<li><strong>SagerNet / Matsuri:</strong> 同样是功能丰富的 Android 客户端。</li>\n</ul>\n</li>\n<li>iOS:<ul>\n<li><strong>FoXray:</strong> 基于 Xray 核心，支持 Shadowsocks, VLESS, Socks, VMess, XTLS, REALITY, Trojan 以及 TCP, HTTP/2, WebSocket, mKCP, gRPC, QUIC 等多种传输方式 。</li>\n<li><strong>ShadowRocket (小火箭):</strong> 付费应用，功能强大，支持 Shadowsocks (包括 SS-2022), VMess, VLESS, Trojan, TUIC, Hysteria, WireGuard, XTLS-Vision, uTLS 等多种协议和特性 。</li>\n<li><strong>V2BOX:</strong> 支持 Xray 核心的免费 iOS 客户端 。</li>\n<li><strong>Streisand:</strong> 提及与 3x-ui VLESS 配合使用 。</li>\n<li><strong>Quantumult X / Loon / Surge:</strong> 均为功能强大的付费网络工具，支持多种代理协议。</li>\n</ul>\n</li>\n<li>Windows:<ul>\n<li><strong>V2RayN:</strong> 流行的 Windows 客户端，支持 Xray/V2Ray 核心，界面直观 。</li>\n<li><strong>Nekoray / Nekobox:</strong> 如上所述，也支持 Windows。</li>\n<li><strong>Qv2ray:</strong> (项目已停止维护，但仍有用户使用) 跨平台客户端，基于 Qt。</li>\n</ul>\n</li>\n<li>macOS:<ul>\n<li><strong>V2RayX:</strong> (项目可能更新较慢) 针对 macOS 的 V2Ray 客户端。</li>\n<li><strong>Nekoray / Nekobox (非官方):</strong> 如上所述。</li>\n<li><strong>V2BOX:</strong> 如上所述，也支持 macOS 。</li>\n<li><strong>ClashX / Clash for Windows (CFW) (macOS 版本):</strong> 基于 Clash 核心的客户端，支持多种协议，通过配置文件进行管理。</li>\n</ul>\n</li>\n<li>Linux:<ul>\n<li><strong>Nekoray / Nekobox:</strong> 如上所述。</li>\n<li><strong>Qv2ray:</strong> (项目已停止维护)。</li>\n<li><strong>Clash (命令行) / Clash Verge (图形界面):</strong> 基于 Clash 核心。</li>\n</ul>\n</li>\n<li>WireGuard 客户端:<ul>\n<li>WireGuard 官方为各主流平台（Windows, macOS, Linux, Android, iOS）均提供了客户端软件 。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-各协议客户端配置示例\"><a href=\"#5-2-各协议客户端配置示例\" class=\"headerlink\" title=\"5.2 各协议客户端配置示例\"></a>5.2 各协议客户端配置示例</h3><p>从 x-ui 面板导出配置通常是最便捷的方式，支持通过分享链接、二维码或复制配置信息。如果需要手动配置，以下是一些关键参数说明：</p>\n<ul>\n<li>通用参数:<ul>\n<li><strong>地址 (Address/Server):</strong> 填写你的服务器域名（如 <code>proxy.yourdomain.com</code>，如果使用 CDN 或 Worker 域名）或服务器 IP 地址（如果直连）。</li>\n<li><strong>端口 (Port):</strong> 填写服务器监听的端口。对于 CDN/Worker 后的 TLS 节点，通常是 <code>443</code>。对于直连节点，填写 x-ui 中设置的监听端口。</li>\n<li><strong>用户ID (ID/UUID):</strong> 对应 VLESS/VMess 协议中 x-ui 生成的 UUID。</li>\n<li><strong>密码 (Password):</strong> 对应 Trojan 或 Shadowsocks 协议中设置的密码。</li>\n</ul>\n</li>\n<li>VMess 特定参数:<ul>\n<li><strong>额外ID (AlterID):</strong> 对应 x-ui 中设置的 AlterID。</li>\n<li><strong>加密方式 (Security/Cipher):</strong> 客户端选择的加密方式需与服务器端兼容，通常选 <code>auto</code> 或服务器指定的。</li>\n</ul>\n</li>\n<li>VLESS 特定参数:<ul>\n<li><strong>流控 (Flow):</strong> 如果服务器端 VLESS 配置了 <code>flow</code> (如 <code>xtls-rprx-vision</code>)，客户端需要相应配置。对于 REALITY，此项通常不直接配置，而是通过 REALITY 的特定参数。</li>\n</ul>\n</li>\n<li>TLS 相关参数 (适用于 VLESS/VMess/Trojan + TLS/XTLS/REALITY):<ul>\n<li><strong>传输层安全 (TLS/Security):</strong> 选择 <code>tls</code> 或 <code>xtls</code> 或 <code>reality</code>。</li>\n<li><strong>SNI (Server Name Indication) / Peer / Host:</strong> 填写用于 TLS 握手的域名，通常是你的服务器域名或 CDN/Worker 域名。对于 REALITY，这里填写的是你伪装的目标网站域名 。</li>\n<li><strong>允许不安全连接 (Allow Insecure):</strong> 通常应设为 <code>false</code> (不勾选)，除非特殊调试目的且了解风险。</li>\n<li><strong>ALPN (Application-Layer Protocol Negotiation):</strong> 客户端可以指定 ALPN，如 <code>h2,http/1.1</code>，以更好地模拟浏览器行为。</li>\n<li><strong>证书验证 (Skip Cert Verify):</strong> 通常不应跳过证书验证。</li>\n</ul>\n</li>\n<li>WebSocket (WS) 特定参数 (适用于 VLESS/VMess/Trojan + WS):<ul>\n<li><strong>传输协议 (Network/Transport):</strong> 选择 <code>ws</code>。</li>\n<li><strong>路径 (Path):</strong> 填写与 x-ui 中 WebSocket 配置一致的路径 (如 <code>/myvlessws</code>)。</li>\n<li><strong>Host (请求头):</strong> 填写你的服务器域名或 CDN/Worker 域名。</li>\n</ul>\n</li>\n<li>gRPC 特定参数 (适用于 VLESS/VMess/Trojan + gRPC):<ul>\n<li><strong>传输协议 (Network/Transport):</strong> 选择 <code>grpc</code>。</li>\n<li><strong>gRPC 服务名称 (serviceName):</strong> 填写与 x-ui 中 gRPC 配置一致的服务名称 (如 <code>mytrojangrpc</code>)。</li>\n<li><strong>模式 (Mode):</strong> <code>multi</code> (多路复用) 模式通常性能更好。</li>\n</ul>\n</li>\n<li>REALITY 特定参数 (VLESS + REALITY):<ul>\n<li><strong>公钥 (PublicKey):</strong> 填写服务器端 x-ui 生成的 X25519 公钥 。</li>\n<li><strong>ShortID:</strong> 填写服务器端配置的 ShortID (可以为空，如果服务器允许) 。</li>\n<li><strong>SpiderX / Fingerprint:</strong> 客户端通常会自动选择或允许用户选择一个 TLS 指纹 (uTLS) 来模仿，如 <code>chrome</code> 或 <code>firefox</code> 。</li>\n</ul>\n</li>\n<li>Shadowsocks 特定参数:<ul>\n<li><strong>加密方法 (Cipher/Method):</strong> 选择与服务器端一致的 AEAD 加密方法。</li>\n</ul>\n</li>\n<li>WireGuard 特定参数:<ul>\n<li><strong>私钥 (PrivateKey):</strong> 客户端的私钥。</li>\n<li><strong>地址 (Address):</strong> 分配给客户端的隧道内 IP 地址 (如 <code>10.0.8.2/32</code>)。</li>\n<li><strong>DNS:</strong> 可选，指定通过 VPN 使用的 DNS 服务器。</li>\n<li>[Peer] 部分:<ul>\n<li><strong>公钥 (PublicKey):</strong> 服务器的 WireGuard 公钥。</li>\n<li><strong>预共享密钥 (PresharedKey):</strong> 可选，用于增强安全性。</li>\n<li><strong>端点 (Endpoint):</strong> 服务器的公网 IP 地址和 WireGuard 监听端口 (如 <code>your_vps_ip:51820</code>)。</li>\n<li><strong>允许的 IP (AllowedIPs):</strong> 通常设为 <code>0.0.0.0/0, ::/0</code>，表示所有流量都通过 VPN。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>许多现代客户端，特别是那些支持 Xray 核心的，都允许用户精细调整 TLS 握手行为，例如通过 uTLS 设置来模仿特定浏览器的 TLS 指纹 。这对于增强连接的隐蔽性，特别是在连接到使用 REALITY 或其他高级伪装技术的服务器时，非常重要。用户应在客户端设置中寻找类似“TLS 指纹”、“uTLS”、“Fingerprint”或“SpiderX”的选项，并选择一个常见浏览器的指纹（如 Chrome 或 Firefox），以使代理流量更难与普通网页浏览流量区分开来。</p>\n<h2 id=\"结论与展望\"><a href=\"#结论与展望\" class=\"headerlink\" title=\"结论与展望\"></a>结论与展望</h2><p>本教程详细介绍了多种主流科学上网代理协议的原理、特性，并逐步指导了如何使用 x-ui (MHSanaei 3x-ui) 面板在 VPS 上搭建这些节点，以及如何结合 Cloudflare CDN、Workers 和 Tunnel 服务来增强节点的隐蔽性和可用性。同时，也涵盖了服务器安全、Cloudflare 安全配置、进阶抗封锁技巧、性能优化和客户端配置等关键方面。</p>\n<p><strong>核心结论包括：</strong></p>\n<ol>\n<li><strong>协议多样性与演进:</strong> 从 Shadowsocks 的简洁高效，到 VMess 的安全灵活，再到 VLESS 的极致性能与 REALITY 的卓越伪装，以及 Trojan 的 HTTPS 模拟和 WireGuard 的现代高速，用户可以根据自身对安全性、性能、抗检测能力和配置复杂度的不同需求选择合适的协议。协议的演进体现了与审查技术持续对抗的趋势。</li>\n<li><strong>x-ui 的便捷性:</strong> x-ui 面板极大地简化了 Xray 节点的部署和管理，使得即便是初学者也能相对容易地配置和维护多种复杂的代理协议。</li>\n<li><strong>Cloudflare 的双重角色:</strong> Cloudflare 的 CDN、Workers 和 Tunnel 服务为代理节点提供了强大的 IP 隐藏、DDoS 防护和流量中转能力。然而，其安全机制也可能对代理流量造成干扰，需要用户仔细配置 WAF、页面规则和机器人管理等设置。同时，用户需注意 Cloudflare 的服务条款。</li>\n<li><strong>安全是基础:</strong> 无论是 VPS 服务器自身的安全加固（防火墙、SSH 安全、系统更新、Fail2ban），还是 x-ui 面板和代理协议的安全配置（强密码、TLS 加密、uTLS 指纹），都是确保节点稳定和用户数据安全不可或缺的环节。分层安全策略是抵御潜在风险的关键。</li>\n<li><strong>性能与伪装的权衡:</strong> 极致的性能（如 VLESS+XTLS）和极致的伪装（如 VLESS+REALITY 或 Trojan）往往需要更精细的配置。通过 CDN 或 Tunnel 虽然能隐藏 IP，但也可能引入额外延迟。用户需要在这些因素之间做出权衡。</li>\n<li><strong>客户端的重要性:</strong> 选择功能全面、支持最新协议特性（如 uTLS）的客户端，并正确配置，对于发挥节点的全部潜力至关重要。</li>\n</ol>\n<p><strong>未来展望：</strong></p>\n<p>网络审查技术和科学上网技术之间的博弈仍将持续。未来可能会出现更智能、更难被检测的审查手段，同时也会催生出更先进、更具适应性的代理协议和混淆技术。对于用户而言，持续学习、关注技术动态、灵活调整配置策略，将是长期维持稳定、安全科学上网能力的关键。</p>\n<p>希望本教程能为读者在理解和实践科学上网技术方面提供有价值的参考。请务必在遵守当地法律法规的前提下使用相关技术。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"常见问题解答-FAQ\"><a href=\"#常见问题解答-FAQ\" class=\"headerlink\" title=\"常见问题解答 (FAQ)\"></a>常见问题解答 (FAQ)</h3><ul>\n<li><p><strong>问：连接节点时遇到问题（如超时、无法连接）怎么办？</strong></p>\n<ul>\n<li><p>答：</p>\n<p> 首先检查：</p>\n<ul>\n<li>VPS 服务器是否在线，x-ui 和 Xray 服务是否正常运行 (<code>systemctl status x-ui</code>, <code>systemctl status xray</code>)。</li>\n<li>VPS 防火墙 (UFW) 是否允许了相应的代理端口和 x-ui 面板端口的入站连接。</li>\n<li>x-ui 面板中的入站配置是否正确（协议、端口、ID/密码、域名、证书路径、传输设置等）。</li>\n<li>客户端配置是否与服务器端完全一致。</li>\n<li>域名是否正确解析到 VPS IP（如果直连）或 Cloudflare IP（如果使用 CDN）。</li>\n<li>Cloudflare 相关设置：DNS 代理状态（橙色云朵）、SSL/TLS 模式（应为 Full Strict）、WAF 或机器人管理是否拦截了流量（查看 Cloudflare 事件日志）。</li>\n<li>服务器和客户端的时间是否同步。</li>\n<li>尝试更换客户端或网络环境测试。</li>\n<li>查看 x-ui 和 Xray 的日志（通过 x-ui 面板或服务器命令 <code>journalctl -u xray -f</code>）获取错误信息。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>问：如何更新 x-ui 面板和 Xray 核心？</strong></p>\n<ul>\n<li>答：<ul>\n<li><strong>更新 x-ui 面板 (MHSanaei/3x-ui):</strong> 通常可以再次运行官方安装脚本 <code>bash &lt;(curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh)</code>，脚本会自动检测已安装版本并进行升级 。也可以在 x-ui 命令行菜单中选择更新选项。</li>\n<li><strong>更新 Xray 核心:</strong> 3x-ui 面板通常会捆绑特定版本的 Xray 核心。一些 x-ui 分支可能在面板内提供一键更新 Xray 核心的功能。或者，可以从 Xray-core 的 GitHub Releases 页面下载最新的二进制文件，手动替换 VPS 上 x-ui 使用的 Xray 执行文件（通常位于 <code>/usr/local/x-ui/bin/xray-core</code> 或类似路径，请先备份旧版）。替换后需要重启 Xray 服务。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>问：我的 VPS IP 地址被封锁了怎么办？</strong></p>\n<ul>\n<li>答：<ul>\n<li><strong>更换 IP:</strong> 联系 VPS 提供商更换 IP 地址（可能需要额外费用）。</li>\n<li><strong>使用 Cloudflare 隐藏 IP:</strong> 如果之前是直连，可以尝试将节点配置为通过 Cloudflare CDN、Workers 或 Tunnel 接入，这样暴露给外界的是 Cloudflare 的 IP。</li>\n<li><strong>迁移服务器:</strong> 将 x-ui 数据备份后，在新的 VPS 上重新部署。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>问：Cloudflare 是否允许使用其网络进行代理？</strong></p>\n<ul>\n<li><strong>答：</strong> Cloudflare 的服务条款（ToS Section 2.8）通常禁止使用其网络（特别是免费计划）作为大规模、未经授权的代理或 VPN 服务出口 68。虽然技术上可以通过 CDN、Workers 或 Tunnel 搭建代理，但如果流量模式被 Cloudflare 识别为滥用，账户或相关域名可能会受到限制。用户应了解并自行承担此风险。使用 Cloudflare WARP 是其官方推荐的个人安全上网方式。</li>\n</ul>\n</li>\n<li><p><strong>问：REALITY 和 XTLS 有什么区别？</strong></p>\n<ul>\n<li><strong>答：</strong> XTLS 是一种旨在减少 VLESS/Trojan 协议中 TLS 加密层级开销的技术，核心在于优化数据传输路径，提高性能。REALITY 则是一种更侧重于消除服务器端 TLS 指纹、增强抗检测能力的协议特性，它通过“借用”真实网站的 TLS 证书指纹来实现伪装。两者可以独立使用（VLESS+XTLS+TLS 或 VLESS+TCP+REALITY），也可以在某些配置下（如 VLESS over TCP with XTLS-Vision and REALITY）协同工作，但 REALITY 本身通常不与传统的 TLS 证书配置同时用于同一入站。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"相关资源链接\"><a href=\"#相关资源链接\" class=\"headerlink\" title=\"相关资源链接\"></a>相关资源链接</h3><ul>\n<li><strong>Xray-core GitHub:</strong>(<a href=\"https://github.com/XTLS/Xray-core\">https://github.com/XTLS/Xray-core</a>)</li>\n<li><strong>3x-ui (MHSanaei) GitHub:</strong>(<a href=\"https://github.com/MHSanaei/3x-ui\">https://github.com/MHSanaei/3x-ui</a>) 6</li>\n<li><strong>Cloudflare 官方文档:</strong> <a href=\"https://developers.cloudflare.com/\">https://developers.cloudflare.com/</a></li>\n<li><strong>Nekoray 客户端:</strong>(<a href=\"https://github.com/MatsuriDayo/nekoray\">https://github.com/MatsuriDayo/nekoray</a>)</li>\n<li><strong>V2RayNG 客户端 (Android):</strong> <a href=\"https://github.com/2dust/v2rayNG\">https://github.com/2dust/v2rayNG</a></li>\n<li><strong>ShadowRocket (iOS):</strong> App Store (付费应用)</li>\n<li><strong>FoXray (iOS):</strong> App Store</li>\n<li><strong>WireGuard 官方网站:</strong> <a href=\"https://www.wireguard.com/\">https://www.wireguard.com/</a></li>\n</ul>\n",
            "tags": [
                "教程"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/31/cloudflare-dai-li-pei-zhi-duan-kou/",
            "url": "https://0xdadream.github.io/2025/05/31/cloudflare-dai-li-pei-zhi-duan-kou/",
            "title": "Cloudflare代理配置端口",
            "date_published": "2025-05-31T08:25:00.000Z",
            "content_html": "<h1 id=\"Cloudflare代理配置端口\"><a href=\"#Cloudflare代理配置端口\" class=\"headerlink\" title=\"Cloudflare代理配置端口\"></a>Cloudflare代理配置端口</h1><h2 id=\"一、前提条件\"><a href=\"#一、前提条件\" class=\"headerlink\" title=\"一、前提条件\"></a>一、前提条件</h2><ul>\n<li>已有注册好的Cloudflare账号（免费即可）。</li>\n<li>已将你的域名成功接入Cloudflare（DNS已指向Cloudflare的Name Server）。</li>\n</ul>\n<hr>\n<h2 id=\"二、Cloudflare可用端口概述\"><a href=\"#二、Cloudflare可用端口概述\" class=\"headerlink\" title=\"二、Cloudflare可用端口概述\"></a>二、Cloudflare可用端口概述</h2><p>Cloudflare 仅能代理特定的HTTP和HTTPS端口。常用端口总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>可用端口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP</td>\n<td>80, 8080, 8880, 2052, 2082, 2086, 2095</td>\n</tr>\n<tr>\n<td>HTTPS</td>\n<td>443, 8443, 2053, 2083, 2087, 2096</td>\n</tr>\n</tbody></table>\n<p>如果你的应用需要使用其他端口（如SSH、FTP），则必须使用Cloudflare的Spectrum服务（通常为付费企业版服务）。</p>\n<hr>\n<h2 id=\"三、具体配置流程\"><a href=\"#三、具体配置流程\" class=\"headerlink\" title=\"三、具体配置流程\"></a>三、具体配置流程</h2><p>以将服务器的<code>8080</code>端口通过Cloudflare实现域名访问为例：</p>\n<h3 id=\"①-服务器端准备\"><a href=\"#①-服务器端准备\" class=\"headerlink\" title=\"① 服务器端准备\"></a>① 服务器端准备</h3><p>确保你的服务器端应用正常监听指定端口：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 例如：测试8080端口是否开启</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">netstat</span> <span class=\"token parameter variable\">-tunlp</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token number\">8080</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"②-Cloudflare-DNS设置\"><a href=\"#②-Cloudflare-DNS设置\" class=\"headerlink\" title=\"② Cloudflare DNS设置\"></a>② Cloudflare DNS设置</h3><ul>\n<li>登录Cloudflare后台：<a href=\"https://dash.cloudflare.com/\">https://dash.cloudflare.com/</a></li>\n<li>选择已接入Cloudflare的域名。</li>\n<li>点击菜单栏中的<code>DNS</code>选项卡。</li>\n</ul>\n<h4 id=\"添加DNS记录：\"><a href=\"#添加DNS记录：\" class=\"headerlink\" title=\"添加DNS记录：\"></a>添加DNS记录：</h4><ul>\n<li>点击 <code>Add record</code>（添加记录）。</li>\n<li>类型选择 <code>A</code> 或 <code>CNAME</code>：<ul>\n<li>若为IP地址（例如服务器IP），选择<code>A</code>。</li>\n<li>若为其他域名，选择<code>CNAME</code>。</li>\n</ul>\n</li>\n</ul>\n<p>示例：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>示例值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Type</td>\n<td>A</td>\n</tr>\n<tr>\n<td>Name</td>\n<td><code>example</code> （即你希望访问的子域名）</td>\n</tr>\n<tr>\n<td>IPv4 address</td>\n<td><code>你的服务器IP</code></td>\n</tr>\n<tr>\n<td>Proxy status</td>\n<td>选择橙色云图标（✅代理）</td>\n</tr>\n</tbody></table>\n<ul>\n<li>最终访问域名形式如：<code>example.yourdomain.com</code></li>\n</ul>\n<h3 id=\"③-服务端口访问说明\"><a href=\"#③-服务端口访问说明\" class=\"headerlink\" title=\"③ 服务端口访问说明\"></a>③ 服务端口访问说明</h3><p>Cloudflare不会直接显示端口号在URL中。因此：</p>\n<ul>\n<li>如果你的服务器使用Cloudflare默认支持的端口（如8080），你在访问时<strong>不需要明确指定端口号</strong>。<ul>\n<li>实际请求如：<code>http://example.yourdomain.com</code></li>\n</ul>\n</li>\n<li>你的服务器上仍然监听的是8080端口，Cloudflare则自动将访问请求代理至此端口。</li>\n</ul>\n<p><strong>示例场景</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>用户访问URL</th>\n<th>实际服务器监听端口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>http://example.yourdomain.com</code></td>\n<td>8080</td>\n</tr>\n<tr>\n<td><code>https://example.yourdomain.com</code>（HTTPS）</td>\n<td>8443、443等（按需设置）</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"四、HTTPS-配置\"><a href=\"#四、HTTPS-配置\" class=\"headerlink\" title=\"四、HTTPS 配置\"></a>四、HTTPS 配置</h2><p>若你希望使用HTTPS访问：</p>\n<ol>\n<li>到Cloudflare后台 → <code>SSL/TLS</code> 选项：<ul>\n<li>推荐设置为<code>Flexible</code>（最简单）或<code>Full</code>模式。</li>\n</ul>\n</li>\n<li>如果是<code>Full</code>模式（推荐）：<ul>\n<li>服务器上需要配置SSL证书（可以使用免费的证书如Let’s Encrypt）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例-Nginx-配置（Full-模式）：\"><a href=\"#示例-Nginx-配置（Full-模式）：\" class=\"headerlink\" title=\"示例 Nginx 配置（Full 模式）：\"></a>示例 Nginx 配置（Full 模式）：</h3><pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span> <span class=\"token number\">8443</span> ssl</span><span class=\"token punctuation\">;</span> \n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span> example.yourdomain.com</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">ssl_certificate</span>     /path/to/cert.pem</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">ssl_certificate_key</span> /path/to/key.pem</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://localhost:8080</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Host <span class=\"token variable\">$host</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> X-Forwarded-For <span class=\"token variable\">$proxy_add_x_forwarded_for</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> X-Real-IP <span class=\"token variable\">$remote_addr</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>Cloudflare → 8443（HTTPS）→ Nginx → 8080（HTTP内网服务）</li>\n</ul>\n<hr>\n<h2 id=\"五、其他非标准端口（如SSH、FTP）支持方法\"><a href=\"#五、其他非标准端口（如SSH、FTP）支持方法\" class=\"headerlink\" title=\"五、其他非标准端口（如SSH、FTP）支持方法\"></a>五、其他非标准端口（如SSH、FTP）支持方法</h2><ul>\n<li>默认Cloudflare免费版不支持SSH、FTP等非HTTP端口代理。</li>\n<li>若有这类需求，可以购买Cloudflare Spectrum服务：<ul>\n<li>在Cloudflare后台，进入Spectrum（频谱）服务，选择协议和端口映射到你的服务器IP地址即可。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"六、常见问题与解决办法\"><a href=\"#六、常见问题与解决办法\" class=\"headerlink\" title=\"六、常见问题与解决办法\"></a>六、常见问题与解决办法</h2><ul>\n<li><strong>访问失败或返回522错误</strong>：<ul>\n<li>检查服务器端防火墙是否允许Cloudflare IP段访问服务器端口。</li>\n<li>检查服务器程序是否正常运行，端口是否已开启。</li>\n</ul>\n</li>\n<li><strong>SSL问题</strong>：<ul>\n<li>Flexible模式下，无需服务器端SSL证书（Cloudflare自动处理）。</li>\n<li>Full模式必须安装SSL证书。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "cloudflare"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/31/sing-box-da-jian-jie-dian/",
            "url": "https://0xdadream.github.io/2025/05/31/sing-box-da-jian-jie-dian/",
            "title": "Sing-box 搭建您的专属科学上网节点实用指南",
            "date_published": "2025-05-31T04:25:00.000Z",
            "content_html": "<h1 id=\"Sing-box-搭建您的专属“科学上网”节点实用指南\"><a href=\"#Sing-box-搭建您的专属“科学上网”节点实用指南\" class=\"headerlink\" title=\"Sing-box 搭建您的专属“科学上网”节点实用指南\"></a>Sing-box 搭建您的专属“科学上网”节点实用指南</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h3 id=\"Sing-box-简介：强大的通用代理平台\"><a href=\"#Sing-box-简介：强大的通用代理平台\" class=\"headerlink\" title=\"Sing-box 简介：强大的通用代理平台\"></a>Sing-box 简介：强大的通用代理平台</h3><p>Sing-box 是一款新兴且功能强大的通用代理平台，被广泛认为是 V2Ray 和 Xray 等成熟工具的有力替代品 。它凭借其卓越的性能、轻量化的设计、对多种代理协议的广泛支持、高度模块化的架构以及积极的社区开发，迅速获得了用户的青睐 。Sing-box 基于 Go 语言开发，并以开源形式发布，这不仅保证了其透明度和安全性，也促进了社区的共同发展和完善 。</p>\n<h3 id=\"本教程目标\"><a href=\"#本教程目标\" class=\"headerlink\" title=\"本教程目标\"></a>本教程目标</h3><p>本教程旨在提供一个从零开始的详尽指南，帮助具备一定技术背景的用户在自己的服务器上成功安装和配置 sing-box，并部署多种当前流行且高效的代理协议。通过本教程，用户将能够：</p>\n<ul>\n<li>选择合适的服务器并完成 sing-box 的安装。</li>\n<li>理解 sing-box 的核心概念和配置文件结构。</li>\n<li>配置服务器防火墙，确保代理服务的正常运行。</li>\n<li>详细配置 VLESS (配合 Reality)、Trojan (配合 TLS)、Shadowsocks (2022新加密)、Hysteria2 和 TUIC 等主流代理协议。</li>\n<li>了解客户端的基本配置方法和主流客户端软件。</li>\n<li>初步接触如使用 CDN 隐藏服务器 IP、配置基本路由和故障转移等高级技巧。</li>\n</ul>\n<p>尽管本教程力求详尽，但 sing-box 的功能远不止于此。鼓励用户在掌握基础后，进一步查阅其官方文档 ，探索更多高级定制功能，以满足个性化需求。</p>\n<h2 id=\"第一章：理解与安装-Sing-box\"><a href=\"#第一章：理解与安装-Sing-box\" class=\"headerlink\" title=\"第一章：理解与安装 Sing-box\"></a>第一章：理解与安装 Sing-box</h2><h3 id=\"1-1-Sing-box-核心概念：构建代理节点的基石\"><a href=\"#1-1-Sing-box-核心概念：构建代理节点的基石\" class=\"headerlink\" title=\"1.1. Sing-box 核心概念：构建代理节点的基石\"></a>1.1. Sing-box 核心概念：构建代理节点的基石</h3><p>理解 sing-box 的核心组件及其交互方式，是成功配置和高效使用该平台的基础。其模块化设计允许用户灵活组合不同的功能模块，以适应多样化的网络环境和需求。</p>\n<ul>\n<li><p><strong>入站连接 (Inbounds):</strong> 入站连接负责处理从客户端设备（例如您的电脑或手机）传入 sing-box 服务器的连接请求。Sing-box 支持多种入站协议类型，常见的包括 Shadowsocks、Trojan、VLESS、VMess、Hysteria2、TUIC、Naive、ShadowTLS，以及用于创建虚拟网卡的 Tun 和用于透明代理的 Redirect 等 。用户可以根据客户端的支持情况和安全需求选择合适的入站协议。</p>\n</li>\n<li><p><strong>出站连接 (Outbounds):</strong> 出站连接定义了 sing-box 服务器如何处理经过其的数据流，即如何将数据转发到目标互联网地址或其他代理服务器。常见的出站类型有 Direct（直接连接）、Block（阻止连接）、Shadowsocks、Trojan、VLESS、WireGuard、Hysteria2、TUIC，以及专门用于 DNS 查询的 DNS、用于节点选择的 Selector 和用于故障转移的 URLTest 等 。这种设计使得 sing-box 不仅能作为代理服务器，还能作为客户端连接其他代理，或实现复杂的代理链。</p>\n</li>\n<li><p><strong>路由 (Route):</strong> 路由模块是 sing-box 实现精细化流量控制的核心。用户可以通过定义一系列路由规则，根据流量的目标地址（如 GeoIP 数据库判断的地理位置、Geosite 预设的网站域名集合）、域名、协议类型等多种条件，将特定的流量导向不同的出站连接 。例如，可以配置国内网站直连，国外网站通过代理访问，从而优化访问速度和资源利用。</p>\n</li>\n<li><p><strong>DNS 配置:</strong> DNS（域名系统）在网络通信中扮演着将域名转换为 IP 地址的关键角色。Sing-box 内建了强大的 DNS 处理能力，允许用户配置自定义 DNS 服务器、设定 DNS 路由规则，并支持如 FakeIP（虚拟 IP）等高级功能，以防止 DNS 泄露，确保域名解析的准确性和安全性 。</p>\n</li>\n<li><p><strong>配置文件 (<code>config.json</code>):</strong> Sing-box 的所有配置均通过一个 JSON 格式的文件进行管理，通常命名为 <code>config.json</code> 。该文件包含了日志、DNS、入站、出站、路由等所有模块的配置信息。其顶层结构通常如下所示：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"log\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"dns\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"route\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"experimental\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>熟悉 JSON 语法并理解各配置项的含义对于手动配置 sing-box至关重要。</p>\n</li>\n</ul>\n<p>sing-box 的架构设计体现了高度的模块化，官方文档 在其配置结构中明确区分了入站、出站和路由等组件。这种设计带来了显著的灵活性，例如支持同时作为客户端和服务器运行 ，以及实现多协议负载均衡 。这意味着用户可以根据具体需求自由组合这些模块，构建从简单的个人代理到复杂的多跳转发网关等各种应用场景，这相较于一些功能固化的工具是一个显著的优势。</p>\n<h3 id=\"1-2-选择您的服务器-VPS-：地理位置与操作系统考量\"><a href=\"#1-2-选择您的服务器-VPS-：地理位置与操作系统考量\" class=\"headerlink\" title=\"1.2. 选择您的服务器 (VPS)：地理位置与操作系统考量\"></a>1.2. 选择您的服务器 (VPS)：地理位置与操作系统考量</h3><p>选择一台合适的虚拟专用服务器（VPS）是搭建稳定高效代理服务的前提。以下是一些关键考量因素：</p>\n<ul>\n<li><strong>地理位置:</strong> 服务器的地理位置直接影响到您的访问速度和能否顺畅访问特定区域的内容。应选择距离用户较近且能提供良好国际网络连接的地区。</li>\n<li><strong>服务商信誉:</strong> 选择知名且信誉良好的 VPS 服务商，以确保服务的稳定性、可靠的技术支持和合理的资源分配。</li>\n<li><strong>资源需求:</strong> 根据预期的负载情况，选择合适的 CPU、内存（RAM）和带宽。对于个人使用，通常入门级配置即可满足需求，但如果用户较多或流量较大，则需相应提高配置。</li>\n<li><strong>操作系统:</strong> 强烈推荐选用 Linux 发行版，特别是 <strong>Ubuntu 或 Debian</strong>。这两个发行版拥有庞大的用户社区、丰富的文档资源，并且 sing-box 官方提供了便捷的安装脚本和软件包支持 。</li>\n</ul>\n<p>绝大多数关于 sing-box 及类似代理工具的安装指南和社区讨论都集中在 Linux 平台 。这并非偶然，Linux 服务器以其经济高效、命令行环境的强大管理能力以及 <code>systemd</code> 等标准化服务管理工具 1成为自建代理服务的首选。Sing-box 本身也对 Linux 提供了深度支持，包括一些依赖特定操作系统内核的功能（如 TUN 模式） 。因此，对于追求稳定、文档完善且易于维护的服务器端部署而言，选择 Ubuntu 或 Debian Linux 将是最直接且高效的路径。</p>\n<h3 id=\"1-3-在您的服务器上安装-Sing-box-以-Ubuntu-Debian-为例\"><a href=\"#1-3-在您的服务器上安装-Sing-box-以-Ubuntu-Debian-为例\" class=\"headerlink\" title=\"1.3. 在您的服务器上安装 Sing-box (以 Ubuntu/Debian 为例)\"></a>1.3. 在您的服务器上安装 Sing-box (以 Ubuntu/Debian 为例)</h3><p>Sing-box 提供了多种安装方式，对于 Ubuntu/Debian 系统，推荐使用官方提供的安装脚本，操作简便快捷。</p>\n<ul>\n<li><p>使用官方通用安装脚本:</p>\n<p>通过以下命令下载并执行安装脚本，该脚本会自动检测系统并安装最新稳定版的 sing-box：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">curl -fsSL https://sing-box.app/install.sh | sudo bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果偏好专门为 Debian/Ubuntu 优化的脚本，可以使用：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">curl -fsSL https://sing-box.app/deb-install.sh | sudo bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>安装特定版本或 Beta 测试版:</p>\n<p>如果需要安装 Beta 版本以体验最新功能，或指定安装某一特定版本，可以在执行脚本时附加参数：</p>\n<ul>\n<li><p>安装最新 Beta 版：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">curl -fsSL https://sing-box.app/install.sh | sudo bash -s -- --beta<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>安装特定版本 (例如 1.8.0)：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">curl -fsSL https://sing-box.app/install.sh | sudo bash -s -- --version 1.8.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>通过 APT 软件源安装 (适用于 Debian/Ubuntu):</p>\n<p>对于希望通过系统包管理器管理 sing-box 的用户，可以添加 SagerNet 的官方 APT 软件源：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo mkdir -p /etc/apt/keyrings &amp;&amp; \\\nsudo curl -fsSL https://sing-box.app/gpg.key -o /etc/apt/keyrings/sagernet.asc &amp;&amp; \\\nsudo chmod a+r /etc/apt/keyrings/sagernet.asc &amp;&amp; \\\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/sagernet.asc] https://deb.sagernet.org/ * *\" | \\\nsudo tee /etc/apt/sources.list.d/sagernet.list &gt; /dev/null &amp;&amp; \\\nsudo apt-get update &amp;&amp; \\\nsudo apt-get install sing-box<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这种方式便于后续的更新和维护。</p>\n</li>\n<li><p>其他操作系统安装简介:</p>\n<p>尽管本教程主要关注 Linux 服务器，但 sing-box 的命令行版本也支持其他操作系统。例如，macOS 用户可以通过 Homebrew (brew install sing-box) 安装，Windows 用户可以使用 Scoop (scoop install sing-box) 或 Chocolatey (choco install sing-box) 进行安装 。这些主要适用于在本地计算机上使用 sing-box 命令行客户端的场景。</p>\n</li>\n</ul>\n<h3 id=\"1-4-Sing-box-核心命令行工具-CLI\"><a href=\"#1-4-Sing-box-核心命令行工具-CLI\" class=\"headerlink\" title=\"1.4. Sing-box 核心命令行工具 (CLI)\"></a>1.4. Sing-box 核心命令行工具 (CLI)</h3><p>掌握 sing-box 的命令行工具对于服务器管理、配置调试和自动化操作至关重要。以下是一些最常用的命令：</p>\n<ul>\n<li><code>sing-box version</code>: 显示已安装的 sing-box 版本信息，包括构建标签 (build tags) 。构建标签指明了编译时包含了哪些特性，例如 <code>with_reality_server</code> 表示支持 Reality 协议，<code>with_quic</code> 表示支持 QUIC 协议。</li>\n<li><code>sing-box run -c /etc/sing-box/config.json</code>: 使用指定的配置文件启动 sing-box 服务 。默认情况下，sing-box 会查找 <code>/etc/sing-box/config.json</code>。</li>\n<li><code>sing-box check -c /etc/sing-box/config.json</code>: 校验配置文件的语法和基本逻辑是否正确，这是在启动或重启服务前非常重要的一步 。</li>\n<li><code>sing-box format -w -c /etc/sing-box/config.json</code>: 格式化（美化）JSON 配置文件，使其更易读。<code>-w</code> 参数表示直接写入修改到原文件 。</li>\n<li><code>sing-box generate uuid</code>: 生成一个标准的 UUID (通用唯一识别码)，常用于 VLESS、VMess 等协议的用户ID配置 。</li>\n<li><code>sing-box generate reality-keypair</code>: 生成一对公私钥，专用于配置 VLESS Reality 协议 。</li>\n<li><strong>通过 <code>systemd</code> 管理服务 (若已安装为系统服务):</strong><ul>\n<li><code>sudo systemctl start sing-box</code>: 启动服务。</li>\n<li><code>sudo systemctl stop sing-box</code>: 停止服务。</li>\n<li><code>sudo systemctl restart sing-box</code>: 重启服务。</li>\n<li><code>sudo systemctl enable sing-box</code>: 设置服务开机自启。</li>\n<li><code>sudo systemctl status sing-box</code>: 查看服务运行状态。</li>\n<li><code>sudo journalctl -u sing-box -f --output cat</code>: 实时查看服务日志（ <code>-f</code> 表示 follow，<code>--output cat</code> 以简化格式输出） 。</li>\n</ul>\n</li>\n</ul>\n<p>sing-box 提供的一系列命令行工具，覆盖了从运行、配置管理到密钥生成的各个核心环节 。这些工具不仅是手动管理 sing-box 实例的基础，更是实现自动化部署、配置更新等高级操作的基石。例如，<code>generate uuid</code> 和 <code>generate reality-keypair</code> 等命令简化了需要特定加密材料的协议的配置过程。同时，通过 <code>systemctl</code> 与 Linux 标准服务管理体系的集成，确保了 sing-box 服务的稳定可靠运行。因此，即使未来出现更多图形化管理界面，熟练运用这些命令行工具对于任何希望深度掌控和高效运维 sing-box 服务器的管理员来说，都是不可或缺的技能。</p>\n<h3 id=\"1-5-config-json-文件结构解析-再探\"><a href=\"#1-5-config-json-文件结构解析-再探\" class=\"headerlink\" title=\"1.5. config.json 文件结构解析 (再探)\"></a>1.5. <code>config.json</code> 文件结构解析 (再探)</h3><p>再次强调 <code>config.json</code> 的核心地位及其主要构成部分，有助于用户在后续章节中更好地理解和修改配置。</p>\n<ul>\n<li><strong><code>log</code></strong>: 配置日志记录的级别（如 <code>info</code>, <code>warn</code>, <code>error</code>, <code>debug</code>, <code>trace</code>）、输出位置（默认标准输出，可指定文件路径）以及是否添加时间戳等 。</li>\n<li><strong><code>dns</code></strong>: 管理 DNS 解析行为，包括设置上游 DNS 服务器、DNS 策略（如 IPv4_only）、DNS 规则（如根据域名分流到不同 DNS 服务器）、FakeIP 等 。</li>\n<li><strong><code>ntp</code></strong>: 网络时间协议 (NTP) 配置，用于同步服务器时间，确保时间准确性，这对于某些依赖时间戳的加密协议和证书验证非常重要 。</li>\n<li><strong><code>inbounds</code></strong>: 定义一个或多个入站连接处理器。每个入站配置指定了监听的 IP 地址、端口、协议类型（如 VLESS, Trojan）以及该协议所需的用户认证、TLS 等参数 。</li>\n<li><strong><code>outbounds</code></strong>: 定义一个或多个出站连接处理器。每个出站配置指定了连接的目标服务器、端口、协议类型（如 <code>direct</code> 直连, <code>block</code> 阻止, 或具体的代理协议）以及相应的认证和传输参数 。</li>\n<li><strong><code>route</code></strong>: 包含路由规则列表。这些规则决定了符合特定条件的入站流量应该被转发到哪个出站连接。规则可以基于域名、IP、地理位置、端口、进程名等多种条件 。</li>\n<li><strong><code>experimental</code></strong>: 用于配置一些实验性功能，例如 Clash API 兼容接口，允许通过 Clash 兼容的控制面板管理 sing-box 。</li>\n</ul>\n<p>对这些主要部分的理解，将为后续针对不同协议的具体配置打下坚实基础。</p>\n<h2 id=\"第二章：准备您的服务器环境\"><a href=\"#第二章：准备您的服务器环境\" class=\"headerlink\" title=\"第二章：准备您的服务器环境\"></a>第二章：准备您的服务器环境</h2><p>在正式配置 sing-box 代理协议之前，确保服务器环境的安全性与网络通畅性至关重要。</p>\n<h3 id=\"2-1-基础服务器安全加固-简述\"><a href=\"#2-1-基础服务器安全加固-简述\" class=\"headerlink\" title=\"2.1. 基础服务器安全加固 (简述)\"></a>2.1. 基础服务器安全加固 (简述)</h3><p>一台暴露在公网的服务器需要基本的安全防护措施：</p>\n<ul>\n<li><p>系统更新:</p>\n<p> 始终保持操作系统及其软件包为最新版本，以修复已知的安全漏洞。</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo apt update &amp;&amp; sudo apt upgrade -y<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>SSH 安全:</p>\n<ul>\n<li><strong>使用密钥认证:</strong> 强烈建议禁用密码登录，转而使用 SSH 密钥对进行认证，这能极大提高登录安全性。</li>\n<li><strong>禁止 root 登录:</strong> 修改 SSHD 配置 (<code>/etc/ssh/sshd_config</code>)，设置 <code>PermitRootLogin no</code>，并使用普通用户登录后再通过 <code>sudo</code> 执行特权命令。</li>\n<li><strong>(可选) 修改 SSH 默认端口:</strong> 将 SSH 服务从默认的 22 端口迁移到其他非标准端口，可以在一定程度上减少自动化的扫描和爆破尝试，但这更多的是一种“安全靠隐蔽”的次要措施。</li>\n</ul>\n</li>\n</ul>\n<p>本教程不提供详尽的服务器安全指南，以上仅为最基础的建议。用户应根据自身情况参考更专业的安全文档进行加固。</p>\n<h3 id=\"2-2-防火墙配置：为代理协议开放端口\"><a href=\"#2-2-防火墙配置：为代理协议开放端口\" class=\"headerlink\" title=\"2.2. 防火墙配置：为代理协议开放端口\"></a>2.2. 防火墙配置：为代理协议开放端口</h3><p>防火墙是服务器的第一道网络防线，它控制着哪些端口允许外部访问。您必须为计划使用的代理协议开放相应的服务器端口。</p>\n<ul>\n<li><p>在 Ubuntu/Debian 上使用 UFW (Uncomplicated Firewall):</p>\n<p>UFW 是一个用户友好的防火墙管理工具。</p>\n<ol>\n<li><p>安装 UFW (如果尚未安装):</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo apt install ufw<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>设置默认策略:</p>\n<p> 拒绝所有传入连接，允许所有传出连接。</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw default deny incoming\nsudo ufw default allow outgoing<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>允许 SSH 连接 (关键步骤):</p>\n<p> 在启用 UFW 之前，务必先允许 SSH 连接，否则您可能会失去对服务器的访问权限。</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw allow ssh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或者，如果您修改了 SSH 端口：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw allow &lt;您的_SSH_端口&gt;/tcp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>为代理协议开放端口:</p>\n<p> 根据您选择的协议和配置的端口，使用以下命令开放 TCP 和/或 UDP 端口。例如，如果您计划在 8443 端口上运行一个 TCP 协议，在 9000-9005 端口范围运行一个 UDP 协议：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw allow 8443/tcp\nsudo ufw allow 9000:9005/udp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>启用 UFW:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw enable<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>系统会提示操作可能中断现有 SSH 连接，确认即可。 </p>\n</li>\n<li><p>查看状态:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw status verbose<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n</li>\n<li><p>在 CentOS/RHEL/Fedora (及部分 Debian/Ubuntu) 上使用 firewalld:</p>\n<p>firewalld 是另一款常用的动态防火墙管理工具。</p>\n<ol>\n<li><p>查看 <code>firewalld</code> 状态:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --state<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>永久开放端口:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --permanent --add-port=&lt;端口号&gt;/tcp\nsudo firewall-cmd --permanent --add-port=&lt;端口号&gt;/udp\nsudo firewall-cmd --permanent --add-port=&lt;起始端口&gt;-&lt;结束端口&gt;/tcp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>永久开放服务 (例如 HTTPS，如果协议伪装在 443 端口):</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --permanent --add-service=https<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>重新加载 <code>firewalld</code> 配置使其生效:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>查看已开放的端口:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --list-ports<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n</li>\n<li><p><strong>表 2.2.1: 常见代理协议及其默认/推荐端口</strong></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>协议</strong></th>\n<th><strong>默认/常用端口</strong></th>\n<th><strong>TCP/UDP</strong></th>\n<th><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VLESS (Reality)</td>\n<td>443, 80, 其他自定义端口</td>\n<td>TCP</td>\n<td>常使用 443 端口伪装成 HTTPS。Reality 可灵活使用多种端口。</td>\n</tr>\n<tr>\n<td>Trojan (TLS)</td>\n<td>443</td>\n<td>TCP</td>\n<td>通常使用 443 端口进行 TLS 加密通信。</td>\n</tr>\n<tr>\n<td>Shadowsocks</td>\n<td>用户自定义 (如 8388, 443)</td>\n<td>TCP/UDP</td>\n<td>无标准端口；443 端口可用于流量混淆。</td>\n</tr>\n<tr>\n<td>Hysteria2</td>\n<td>用户自定义</td>\n<td>UDP</td>\n<td>基于 QUIC，常使用高位端口或 443/udp。</td>\n</tr>\n<tr>\n<td>TUIC</td>\n<td>用户自定义</td>\n<td>UDP</td>\n<td>基于 QUIC，常使用高位端口或 443/udp。</td>\n</tr>\n<tr>\n<td>VMess</td>\n<td>用户自定义</td>\n<td>TCP/UDP</td>\n<td>无标准端口。</td>\n</tr>\n<tr>\n<td>ShadowTLS</td>\n<td>443 (外层)</td>\n<td>TCP</td>\n<td>包装其他协议，外层连接通常在 443 端口。</td>\n</tr>\n<tr>\n<td>NaiveProxy</td>\n<td>443, 80</td>\n<td>TCP</td>\n<td>模仿标准 Web 流量。</td>\n</tr>\n</tbody></table>\n<p>无论是 UFW  还是 <code>firewalld</code>，其默认策略通常是拒绝所有未经明确允许的入站连接。这是一种基础且重要的安全实践，旨在最小化服务器的潜在攻击面。因此，用户必须显式地为 SSH（远程管理）和计划运行的代理协议开放端口。忽略或错误配置防火墙，不仅可能导致代理服务无法访问，还可能使服务器暴露于不必要的安全风险之下。因此，防火墙的正确配置是保障代理节点正常运作和安全性的前提条件。</p>\n<h2 id=\"第三章：在-Sing-box-中配置热门协议\"><a href=\"#第三章：在-Sing-box-中配置热门协议\" class=\"headerlink\" title=\"第三章：在 Sing-box 中配置热门协议\"></a>第三章：在 Sing-box 中配置热门协议</h2><p>本章节将详细介绍如何在 sing-box 中配置当前流行且在“科学上网”场景下表现优异的几种代理协议。每个协议的配置都将包含服务器端（入站）和客户端（出站）的 JSON 代码片段，并对关键字段进行解释。</p>\n<p><em>通用说明：</em></p>\n<ul>\n<li><em>每个协议小节都会简要介绍其特性、基于的传输方式（TCP/UDP）、加密和混淆技术，以及其在规避审查方面的有效性。</em></li>\n<li><em>所有配置示例均为 sing-box 的 JSON 格式，并附带注释说明。</em></li>\n<li><em>会提及配置该协议可能需要的前提条件，如域名、SSL 证书、生成的密钥对等。</em></li>\n</ul>\n<h3 id=\"3-1-VLESS-配合-Reality-和-或-XTLS-Vision\"><a href=\"#3-1-VLESS-配合-Reality-和-或-XTLS-Vision\" class=\"headerlink\" title=\"3.1. VLESS (配合 Reality 和/或 XTLS-Vision)\"></a>3.1. VLESS (配合 Reality 和/或 XTLS-Vision)</h3><ul>\n<li><p><strong>协议概述:</strong> VLESS 以其高性能和灵活性著称。Reality 是一种先进的流量伪装技术，它使得代理服务器在未授权的探测者看来完全像一个真实的、普通的网站（例如 <code>www.microsoft.com</code>），从而极大地增强了抗审查能力。XTLS-Vision 是一种流控模式，旨在进一步优化性能 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置 (VLESS + Reality):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"tls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"server_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.actual.domain.com\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 你的真实域名，用于申请证书 (如果使用 ACME)</span>\n        <span class=\"token property\">\"reality\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"handshake\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token property\">\"server\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"www.microsoft.com\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 伪装的目标网站域名</span>\n            <span class=\"token property\">\"server_port\"</span><span class=\"token operator\">:</span> <span class=\"token number\">443</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"private_key\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"YOUR_REALITY_PRIVATE_KEY\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 使用 'sing-box generate reality-keypair' 生成</span>\n          <span class=\"token property\">\"short_id\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 1到2个字节的十六进制字符串，例如 \"01\" 或 \"abcd\"</span>\n          <span class=\"token property\">\"max_time_difference\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1m\"</span> <span class=\"token comment\">// 允许客户端与服务器的最大时间差</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 如果不使用 Reality 自签名证书，而是为 your.actual.domain.com 申请真实证书，</span>\n        <span class=\"token comment\">// 则需要配置 ACME 或 certificate_path/key_path</span>\n        <span class=\"token comment\">// \"acme\": {</span>\n        <span class=\"token comment\">//   \"domain\": \"your.actual.domain.com\",</span>\n        <span class=\"token comment\">//   \"email\": \"your-email@example.com\"</span>\n        <span class=\"token comment\">// }</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>uuid</code>: 用户的唯一标识符。</li>\n<li><code>tls.server_name</code>: 对于 Reality 而言，此处的 <code>server_name</code> 是您希望 Reality “伪装”成的目标网站的域名，客户端连接时会使用这个 SNI。</li>\n<li><code>reality.handshake.server</code>: 实际发起 TLS 握手的目标服务器，通常是知名的大型网站，以增加伪装的真实性。</li>\n<li><code>reality.private_key</code>: 通过 <code>sing-box generate reality-keypair</code> 命令生成的私钥。公钥需要配置在客户端。</li>\n<li><code>reality.short_id</code>: 一个或多个短ID（1-2字节的十六进制字符串），客户端连接时需要匹配其中一个。</li>\n<li><code>flow: \"xtls-rprx-vision\"</code>: VLESS 的一种流处理模式，可提升性能 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置 (VLESS + Reality):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>tls.server_name</code>: 客户端在发起 TLS 握手时使用的 SNI，<strong>必须</strong>与服务器端 <code>reality.handshake.server</code> 字段中配置的域名完全一致。</li>\n<li><code>tls.reality.public_key</code>: 服务器端通过 <code>sing-box generate reality-keypair</code> 生成的公钥。</li>\n<li><code>tls.utls.fingerprint</code>: 模拟特定浏览器的 TLS 指纹，例如 “chrome”, “firefox”, “safari” 等，这有助于使流量看起来更像普通浏览器发出的流量，从而进一步抵抗指纹识别 。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Reality 技术的出现，是针对日益复杂的网络审查中主动探测和基于 SNI 封锁的有效回应 。传统的代理协议，即使流量加密，其 TLS 握手特征或服务器行为也可能被主动探测识别。同时，审查系统也可能直接封锁指向可疑服务器 IP 的特定 SNI 请求。Reality 通过“借用”一个高信誉、大流量的知名网站（如 <code>www.microsoft.com</code>）的 TLS 握手信息作为“外壳”，使得 sing-box 服务器在初始连接阶段的行为与该知名网站无法区分，从而有效规避主动探测。在这次“伪装”握手之后，真实的 VLESS 代理流量才通过这对由 <code>private_key</code> 和 <code>public_key</code> 保护的加密通道进行传输。这种机制使得 VLESS + Reality 组合在当前环境下拥有极高的隐蔽性和抗封锁能力，是其广受欢迎的主要原因。</p>\n<h3 id=\"3-2-Trojan-配合-TLS，可选-WebSocket-传输\"><a href=\"#3-2-Trojan-配合-TLS，可选-WebSocket-传输\" class=\"headerlink\" title=\"3.2. Trojan (配合 TLS，可选 WebSocket 传输)\"></a>3.2. Trojan (配合 TLS，可选 WebSocket 传输)</h3><ul>\n<li><p><strong>协议概述:</strong> Trojan 协议通过模仿 HTTPS 流量的特征，使其在网络传输中难以被识别和区分。它通常需要配合一个真实的域名和有效的 SSL/TLS 证书使用。WebSocket (WS) 作为一种可选的传输层协议，可以将 Trojan 流量进一步封装在标准的 HTTP/HTTPS 连接中，这不仅增强了伪装性，还使得流量可以通过 CDN (内容分发网络) 进行中转，隐藏真实服务器 IP 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置 (Trojan + TLS):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"tls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"server_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 你的域名</span>\n        <span class=\"token comment\">// 使用 ACME 自动申请和续签证书 (推荐)</span>\n        <span class=\"token property\">\"acme\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"domain\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your-email@example.com\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 或者手动指定证书路径</span>\n        <span class=\"token comment\">// \"certificate_path\": \"/path/to/your/fullchain.pem\",</span>\n        <span class=\"token comment\">// \"key_path\": \"/path/to/your/private.key\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"multiplex\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 启用多路复用以提高性能</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 如果需要 WebSocket 传输 (例如配合 CDN)</span>\n      <span class=\"token comment\">// \"transport\": {</span>\n      <span class=\"token comment\">//   \"type\": \"ws\",</span>\n      <span class=\"token comment\">//   \"path\": \"/your-secret-websocket-path\" // 自定义 WebSocket 路径</span>\n      <span class=\"token comment\">// }</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>users.password</code>: Trojan 协议的认证密码。</li>\n<li><code>tls.server_name</code>: 必须是您拥有的、并且 DNS 解析指向您服务器 IP 的域名。</li>\n<li><code>tls.acme</code>: 推荐使用 ACME 自动管理 TLS 证书，sing-box 支持 Let’s Encrypt 等机构。</li>\n<li><code>multiplex.enabled</code>: 启用多路复用可以减少连接数，提高并发处理能力 。</li>\n<li><code>transport</code> (可选): 如果配置为 <code>\"ws\"</code>，则启用 WebSocket 传输。<code>path</code> 是 WebSocket 的访问路径，应设置为一个不易被猜到的字符串。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置 (Trojan + TLS):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>29 (WebSocket 部分参考 39)</p>\n<ul>\n<li>关键解释:<ul>\n<li><code>server</code>: 连接的服务器地址，推荐使用域名。</li>\n<li><code>tls.server_name</code>: 客户端进行 TLS 握手时提供的 SNI，必须与服务器证书绑定的域名一致，否则会导致握手失败。</li>\n<li><code>tls.utls.fingerprint</code>: 模拟特定浏览器的 TLS 客户端行为，增强伪装性 。</li>\n<li><code>transport.headers.Host</code> (使用 WS 时): 当通过 CDN 或反向代理连接时，通常需要设置正确的 <code>Host</code> 头，使其指向您的源服务器域名。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Trojan 协议的核心设计理念在于其高度的 HTTPS 流量模拟能力 。配置中对 TLS 参数（如 <code>server_name</code>、<code>certificate_path</code>、<code>key_path</code>）的强调，正是为了实现这种逼真的伪装 。一个与 <code>server_name</code>（即您的域名）匹配的有效 TLS 证书，是构成可信 HTTPS 通信的基础。如果使用自签名证书或 SNI 不匹配，很容易被中间的网络设备识别为异常流量。将 Trojan 服务部署在标准的 HTTPS 端口 443 上，能进一步增强其隐蔽性。因此，选择 Trojan 协议的用户，必须准备好获取一个域名，并为该域名配置有效的 TLS 证书（可以通过 sing-box 内置的 ACME 功能自动申请，或手动配置）。若缺乏这些要素，Trojan 协议主要的伪装特性将大打折扣，其抗审查能力也会显著下降。</p>\n<h3 id=\"3-3-Shadowsocks-重点关注-AEAD-2022-系列加密算法\"><a href=\"#3-3-Shadowsocks-重点关注-AEAD-2022-系列加密算法\" class=\"headerlink\" title=\"3.3. Shadowsocks (重点关注 AEAD 2022 系列加密算法)\"></a>3.3. Shadowsocks (重点关注 AEAD 2022 系列加密算法)</h3><ul>\n<li><p><strong>协议概述:</strong> Shadowsocks 是一种轻量级、广泛应用的代理协议。其 2022 系列的 AEAD (Authenticated Encryption with Associated Data) 加密算法，如 <code>2022-blake3-aes-128-gcm</code>，因其在安全性和抗探测性方面的提升而被官方推荐使用 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>method</code>: 选择一个 2022 系列的 AEAD 加密算法。</li>\n<li><code>password</code>: Shadowsocks 的连接密码。</li>\n<li><code>multiplex.enabled</code>: 启用多路复用。对于 Shadowsocks 而言，这不仅能提升性能，还能改善 UDP 流量的传输和隐蔽性 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>sing-box 官方文档在介绍 Shadowsocks 时，<em>强烈建议</em>开启多路复用功能来传输 UDP 流量，并指出“否则很容易受到被动检测” 。究其原因，传统的 Shadowsocks 实现（尤其是较早的加密方式或未启用多路复用的 UDP 传输）存在一些可被深度包检测（DPI）识别的流量特征 。多路复用技术（如 Shadowsocks 常用的 smux）允许在单个 TCP 连接上承载多个逻辑数据流，这不仅改变了流量模式，使其更难与使用连接池的常规网络流量区分开来，还为在 TCP 连接内隧道化 UDP 数据包提供了一种更为健壮和标准化的方式，这在许多受审查的网络环境中比直接转发原始 UDP 包更为可靠。因此，在 sing-box 中配置 Shadowsocks 时，用户应始终启用多路复用，特别是当需要可靠传输 UDP 流量（例如用于 QUIC 协议的应用、WebRTC 或在线游戏）时。忽视此建议将显著增加协议被探测和封锁的风险。</p>\n<h3 id=\"3-4-Hysteria2-基于-QUIC，高性能\"><a href=\"#3-4-Hysteria2-基于-QUIC，高性能\" class=\"headerlink\" title=\"3.4. Hysteria2 (基于 QUIC，高性能)\"></a>3.4. Hysteria2 (基于 QUIC，高性能)</h3><ul>\n<li><p><strong>协议概述:</strong> Hysteria2 专为在不稳定和高丢包网络环境下提供高速传输而设计。它基于定制的 QUIC 协议，并采用名为 “Brutal” 的拥塞控制算法，力求在恶劣网络条件下榨干带宽。其流量特征旨在伪装成标准的 HTTP/3 流量 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"tls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"server_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 你的域名</span>\n        <span class=\"token comment\">// 使用 ACME 自动申请证书</span>\n        <span class=\"token property\">\"acme\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"domain\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your-email@example.com\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 或手动指定证书</span>\n        <span class=\"token comment\">// \"certificate_path\": \"/path/to/your/fullchain.pem\",</span>\n        <span class=\"token comment\">// \"key_path\": \"/path/to/your/private.key\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"obfs\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 可选的 QUIC 流量混淆</span>\n         <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"salamander\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 目前仅支持 salamander</span>\n         <span class=\"token property\">\"password\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"YOUR_OBFS_PASSWORD\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>up_mbps</code>, <code>down_mbps</code>: 定义服务器的上下行带宽限制。客户端也需要配置相应的值。</li>\n<li><code>users.password</code> (或顶层 <code>password</code>): Hysteria2 的认证密码。注意 sing-box 不支持官方 Hysteria 客户端的 <code>username:password</code> 组合作为 <code>userpass</code> 的别名，需要直接填写组合后的密码 。</li>\n<li><code>tls</code>: Hysteria2 依赖 TLS 进行加密和认证，配置方式与 Trojan 类似，需要域名和证书。</li>\n<li><code>obfs</code> (可选): Salamander 混淆器可以对 QUIC 流量进行额外处理，可能增加抗检测性，但也会带来性能开销 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>Hysteria2 的核心优势在于其基于 UDP (QUIC) 的特性以及独特的 “Brutal” 拥塞控制算法，这使其在网络质量较差、丢包率高的环境下仍能努力维持高吞吐量 。然而，这也可能成为其潜在的弱点。正如 sing-box 文档所警示的，“基于 UDP 的代理……实际上比基于 TCP 的代理具有更明显的特征” 。尽管 QUIC 对大部分头部信息进行了加密，但在某些严格审查的网络中，大量非标准端口的 UDP 通信本身就可能引起注意。此外，“Brutal”拥塞控制算法为了追求带宽最大化，其产生的流量模式可能与常规 Web 流量所使用的标准 TCP 拥塞控制算法（如 Cubic 或 BBR）有所不同，长期来看存在被指纹识别的风险。因此，用户在选择 Hysteria2 时，应权衡其在恶劣网络下的性能优势与这种潜在的可检测性。</p>\n<h3 id=\"3-5-TUIC-基于-QUIC，低延迟\"><a href=\"#3-5-TUIC-基于-QUIC，低延迟\" class=\"headerlink\" title=\"3.5. TUIC (基于 QUIC，低延迟)\"></a>3.5. TUIC (基于 QUIC，低延迟)</h3><ul>\n<li><p><strong>协议概述:</strong> TUIC 是另一款基于 QUIC 的代理协议，其设计重点在于最小化连接握手延迟，并支持 0-RTT 连接建立。它也提供了高效的 UDP 代理能力 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"congestion_control\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bbr\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 拥塞控制算法，可选 \"cubic\", \"new_reno\", \"bbr\"</span>\n      <span class=\"token property\">\"auth_timeout\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"3s\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 认证超时时间</span>\n      <span class=\"token property\">\"heartbeat_interval\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"10s\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 心跳间隔 (sing-box v1.9+ 使用此字段名)</span>\n      <span class=\"token property\">\"tls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"server_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"acme\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"domain\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your-email@example.com\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 或手动指定证书</span>\n        <span class=\"token comment\">// \"certificate_path\": \"/path/to/your/fullchain.pem\",</span>\n        <span class=\"token comment\">// \"key_path\": \"/path/to/your/private.key\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// \"zero_rtt_handshake\": false // 服务端通常不建议开启 0-RTT，有安全风险</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>(字段名 <code>heartbeat_interval</code> 对应新版 sing-box，旧版可能为 <code>heartbeat</code>)</p>\n<ul>\n<li>关键解释:<ul>\n<li><code>users</code>: 包含 <code>uuid</code> 和 <code>password</code> 用于认证。</li>\n<li><code>congestion_control</code>: 选择适合网络环境的 QUIC 拥塞控制算法。</li>\n<li><code>tls</code>: 与 Hysteria2 类似，需要域名和证书。</li>\n<li><code>zero_rtt_handshake</code>: 服务端通常应保持禁用（默认或显式设置为 <code>false</code>），以避免重放攻击的风险 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// QUIC 通常使用 h3 作为 ALPN</span>\n        <span class=\"token property\">\"utls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"fingerprint\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"chrome\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// \"insecure\": true, // 如果服务器使用自签名证书且了解风险</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>TUIC 协议以其 0-RTT（零往返时间）握手能力作为提升连接速度、降低延迟的一大亮点 。0-RTT 允许客户端在第一个数据包中就携带应用数据，这通过复用先前连接中协商好的会话参数来实现。然而，正如 sing-box 官方入站配置文档所强调的，服务端启用 <code>zero_rtt_handshake</code> 存在被重放攻击的风险，并引用了 Cloudflare 关于“克隆人攻击”的文章作为佐证 。这种攻击的原理是，如果攻击者捕获了包含 0-RTT 数据的初始数据包，他们可以将这些数据包重放给服务器。由于服务器在处理 0-RTT 数据时无法轻易判断其新鲜度，这可能导致数据被重复处理或引发其他安全问题。尽管 QUIC 协议自身包含一些针对 0-RTT 的重放缓解措施，但并非万无一失。因此，对于注重安全性的应用场景，普遍建议谨慎对待 0-RTT，或避免将其用于非幂等请求。这意味着，尽管 TUIC 的 0-RTT 特性对延迟敏感型应用很有吸引力，用户必须清醒认识到相关的安全风险。为最大化安全性，服务端通常应禁用 0-RTT，即便这会牺牲部分握手延迟的极致优化。客户端仍可尝试发起 0-RTT 连接，但服务器端是否接受应由用户在充分理解并接受潜在风险后决定。</p>\n<ul>\n<li><strong>表 3.1: 特色协议对比概览</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>特性/协议</strong></th>\n<th><strong>VLESS (+Reality)</strong></th>\n<th><strong>Trojan (+TLS/WSS)</strong></th>\n<th><strong>Shadowsocks (2022)</strong></th>\n<th><strong>Hysteria2</strong></th>\n<th><strong>TUIC</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>基础协议</strong></td>\n<td>TCP (VLESS 本身传输层无关)</td>\n<td>TCP</td>\n<td>TCP (UDP via Mux)</td>\n<td>UDP (QUIC)</td>\n<td>UDP (QUIC)</td>\n</tr>\n<tr>\n<td><strong>主要混淆方式</strong></td>\n<td>TLS (Reality 伪装真实网站)</td>\n<td>TLS (模仿 HTTPS)</td>\n<td>加密流, AEAD 加密</td>\n<td>QUIC 加密 (伪装 HTTP/3)</td>\n<td>QUIC 加密</td>\n</tr>\n<tr>\n<td><strong>隐蔽性 (vs GFW)</strong></td>\n<td>高 (Reality)</td>\n<td>高 (如果配置得当)</td>\n<td>中到高 (2022 + Mux)</td>\n<td>中 (UDP 可能被针对)</td>\n<td>中 (UDP 可能被针对)</td>\n</tr>\n<tr>\n<td><strong>性能表现</strong></td>\n<td>良好至优秀</td>\n<td>良好</td>\n<td>良好</td>\n<td>优秀 (尤其在恶劣网络)</td>\n<td>优秀 (低延迟)</td>\n</tr>\n<tr>\n<td><strong>配置复杂度</strong></td>\n<td>中 (Reality 增加步骤)</td>\n<td>中 (需域名/证书)</td>\n<td>低到中</td>\n<td>中</td>\n<td>中</td>\n</tr>\n<tr>\n<td><strong>核心优势</strong></td>\n<td>Reality 带来的高隐蔽性</td>\n<td>强大的 HTTPS 模仿能力</td>\n<td>简洁, 广泛支持</td>\n<td>恶劣网络下的高吞吐</td>\n<td>低握手延迟, 0-RTT 选项</td>\n</tr>\n<tr>\n<td><strong>主要劣势</strong></td>\n<td>Reality 配置可能较复杂</td>\n<td>域名/证书管理</td>\n<td>旧版/不当配置易被检测</td>\n<td>UDP 封锁/限速, “明显特征” 30</td>\n<td>UDP 封锁/限速, 0-RTT 风险</td>\n</tr>\n</tbody></table>\n<h2 id=\"第四章：配置您的客户端设备\"><a href=\"#第四章：配置您的客户端设备\" class=\"headerlink\" title=\"第四章：配置您的客户端设备\"></a>第四章：配置您的客户端设备</h2><p>成功搭建 sing-box 服务器后，下一步是在您的设备上配置客户端以连接并使用该服务。</p>\n<h3 id=\"4-1-Sing-box-客户端通用配置原则\"><a href=\"#4-1-Sing-box-客户端通用配置原则\" class=\"headerlink\" title=\"4.1. Sing-box 客户端通用配置原则\"></a>4.1. Sing-box 客户端通用配置原则</h3><p>无论是使用 sing-box 命令行作为客户端，还是使用图形化客户端，其核心配置逻辑是相似的：客户端的 <code>outbounds</code>（出站）设置必须与服务器端的 <code>inbounds</code>（入站）设置相匹配。</p>\n<p>关键匹配参数包括：</p>\n<ul>\n<li><strong>服务器地址 (server) 和端口 (server_port):</strong> 客户端必须正确指向服务器的 IP 地址或域名，以及服务器上相应协议监听的端口。</li>\n<li><strong>用户凭证 (UUID/password):</strong> 对于需要认证的协议（如 VLESS, Trojan, Shadowsocks, Hysteria2, TUIC），客户端配置的 UUID 或密码必须与服务器端为该用户设定的凭证完全一致。</li>\n<li><strong>加密方法 (method/security):</strong> 客户端选择的加密算法必须是服务器端支持并为该用户启用的。</li>\n<li><strong>传输设置 (transport):</strong> 如果服务器端使用了特定的传输方式（如 WebSocket 的路径 <code>path</code>，gRPC 的服务名 <code>serviceName</code>），客户端必须进行相应的配置。</li>\n<li>TLS 设置 (tls):<ul>\n<li><strong>SNI (Server Name Indication):</strong> 对于使用 TLS 的协议，客户端配置的 <code>server_name</code> (SNI) 通常需要与服务器证书的域名或 Reality/Trojan 等协议期望的 SNI 一致。</li>\n<li><strong>证书验证:</strong> 客户端默认会验证服务器证书的有效性。如果服务器使用自签名证书，客户端需要配置信任该证书或（在了解风险的前提下）设置为不安全连接 (<code>insecure: true</code>)。</li>\n<li><strong>Reality/uTLS:</strong> 如果服务器端配置了 Reality，客户端必须配置对应的 <code>public_key</code> 和 <code>short_id</code>。使用 <code>utls</code> 模拟浏览器指纹可以增强伪装性。</li>\n</ul>\n</li>\n<li><strong>协议类型 (type):</strong> 客户端 <code>outbounds</code> 中的 <code>type</code> 字段必须与服务器端 <code>inbounds</code> 中配置的协议类型相对应。</li>\n</ul>\n<h3 id=\"4-2-使用-Sing-box-命令行作为客户端-适用于高级用户或连接其他服务器\"><a href=\"#4-2-使用-Sing-box-命令行作为客户端-适用于高级用户或连接其他服务器\" class=\"headerlink\" title=\"4.2. 使用 Sing-box 命令行作为客户端 (适用于高级用户或连接其他服务器)\"></a>4.2. 使用 Sing-box 命令行作为客户端 (适用于高级用户或连接其他服务器)</h3><p>对于高级用户，或者当您希望将一台设备（如另一台服务器或本地 Linux/macOS 机器）作为连接到主 sing-box 服务器的客户端时，可以直接使用 sing-box 命令行程序。</p>\n<p>以下是一个最小化的客户端 <code>config.json</code> 示例，它包含日志、DNS、一个连接到 VLESS+Reality 服务器的出站，以及一个本地 SOCKS5 入站，允许本机其他应用程序通过此 sing-box 客户端进行代理：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"log\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"level\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"info\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 日志级别，可根据需要调整为 \"debug\" 获取更详细信息</span>\n    <span class=\"token property\">\"timestamp\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"dns\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"servers\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"final\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"dns-remote\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 默认所有 DNS 查询走 \"dns-remote\"</span>\n    <span class=\"token property\">\"strategy\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ipv4_only\"</span> <span class=\"token comment\">// DNS 解析策略，可按需选择</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"route\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"rules\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"outbound\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"direct\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// { \"geosite\": \"category-ads-all\", \"outbound\": \"block\" }</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"final\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"proxy\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 默认情况下，所有其他流量都通过名为 \"proxy\" 的出站</span>\n    <span class=\"token property\">\"auto_detect_interface\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// 自动检测出口网络接口，某些情况下需要</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将上述配置保存为 <code>client_config.json</code>，然后通过 <code>sing-box run -c client_config.json</code> 运行。之后，将需要代理的应用程序的 SOCKS5 代理设置为 <code>127.0.0.1:1080</code> 即可。</p>\n<h3 id=\"4-3-主流图形化客户端-GUI-概览\"><a href=\"#4-3-主流图形化客户端-GUI-概览\" class=\"headerlink\" title=\"4.3. 主流图形化客户端 (GUI) 概览\"></a>4.3. 主流图形化客户端 (GUI) 概览</h3><p>对于不习惯命令行的用户，或者希望在日常设备上便捷使用代理，可以选择各种支持 sing-box 内核或其协议的图形化客户端。</p>\n<ul>\n<li><strong>桌面端 (Windows/macOS/Linux):</strong><ul>\n<li><strong>GUI.for.SingBox (下一代 Clash Verge):</strong> 这是一款专为 sing-box 设计的图形化配置和管理工具，支持通过 GUI 创建和调整配置，管理配置文件（Profiles），最终生成 sing-box 可用的 <code>config.json</code> 。</li>\n<li><strong>Nekoray / NekoBox:</strong> 广受欢迎的多协议客户端，支持 sing-box、Xray、Clash 等多种核心，界面友好，易于上手 。</li>\n<li><strong>Hiddify-Next:</strong> 另一款支持多种协议和 sing-box 的第三方 GUI 客户端 。</li>\n<li><strong>Clash Verge:</strong> 主要为 Clash 核心设计，但由于其配置范式与 sing-box 有相似之处，且社区活跃，部分衍生项目或新版本可能增强对 sing-box 的兼容性或提供类似体验 。</li>\n</ul>\n</li>\n<li><strong>移动端:</strong><ul>\n<li>Android:<ul>\n<li><strong>Sing-box for Android (官方):</strong> 由 SagerNet 开发的官方 Android 客户端，功能全面，紧跟 sing-box 内核更新 。</li>\n<li><strong>SagerNet:</strong> 也是 SagerNet 开发的一款支持多种协议（包括 sing-box 协议）的客户端 。</li>\n<li><strong>NekoBox for Android:</strong> Nekoray 的 Android 版本，同样支持 sing-box 。</li>\n</ul>\n</li>\n<li>iOS:<ul>\n<li><strong>Sing-box for Apple (官方):</strong> 官方 iOS 客户端，提供原生体验 。</li>\n<li><strong>Shadowrocket (“小火箭”):</strong> 老牌且功能强大的 iOS 网络工具，支持包括 Trojan, VLESS, Shadowsocks, Hysteria2, TUIC 在内的多种 sing-box 兼容协议 。</li>\n<li><strong>Stash:</strong> 另一款流行的 iOS 代理客户端，以其强大的规则引擎和 sing-box 协议支持闻名 。</li>\n<li><strong>Egern:</strong> 支持多种协议，包括 sing-box 的主流协议 。</li>\n<li><strong>FoXray:</strong> 也被推荐用于 iOS 设备，支持 VLESS 等协议 。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>大多数图形化客户端都支持通过订阅链接（机场服务商提供）自动更新节点信息和配置，或者允许用户手动导入 sing-box 的 JSON 配置文件、单个节点的分享链接或扫描二维码添加节点 。</p>\n<p>近年来，通用型图形化客户端的兴起极大地简化了用户在多协议环境下的使用体验。诸如 Nekoray、GUI.for.SingBox、Hiddify 以及移动端的官方 sing-box 应用、Shadowrocket、Stash 等客户端，其设计目标就是兼容多种代理核心（如 sing-box, Clash, Xray）或 sing-box 所支持的广泛协议集 。这种趋势的背后，是用户往往拥有运行不同协议的服务器，或者需要根据网络状况和特定需求灵活切换协议。为每种协议维护独立的客户端应用显然十分繁琐。通用客户端通过提供统一的用户界面，简化了配置管理（通常通过配置文件或订阅链接实现）和代理切换的流程。Sing-box 作为库或核心的能力 ，也为其被集成到这些第三方 GUI 客户端提供了便利。这意味着用户不再被束缚于单一协议的特定客户端，而是可以选择功能丰富、支持 sing-box 的图形化工具，从而更便捷地管理和使用其“科学上网”服务。</p>\n<h2 id=\"第五章：增强您的配置-高级技巧\"><a href=\"#第五章：增强您的配置-高级技巧\" class=\"headerlink\" title=\"第五章：增强您的配置 (高级技巧)\"></a>第五章：增强您的配置 (高级技巧)</h2><p>在掌握了 sing-box 的基本安装和协议配置之后，可以进一步探索一些高级技巧，以增强代理服务的隐蔽性、稳定性和灵活性。</p>\n<h3 id=\"5-1-使用-CDN-隐藏服务器-IP-例如-Cloudflare\"><a href=\"#5-1-使用-CDN-隐藏服务器-IP-例如-Cloudflare\" class=\"headerlink\" title=\"5.1. 使用 CDN 隐藏服务器 IP (例如 Cloudflare)\"></a>5.1. 使用 CDN 隐藏服务器 IP (例如 Cloudflare)</h3><ul>\n<li><p><strong>核心概念:</strong> 将代理服务器的流量通过内容分发网络 (CDN) 如 Cloudflare 进行中转，可以有效隐藏真实服务器的 IP 地址。这使得即使代理服务器的 IP 被直接探测或封锁，只要 CDN 节点可用，服务依然能够访问，从而提高了抗封锁能力 。</p>\n</li>\n<li><p><strong>工作原理:</strong></p>\n<ol>\n<li>将您的域名解析指向 Cloudflare 的服务器（在 Cloudflare DNS 设置中开启橙色云朵代理）。</li>\n<li>Sing-box 服务器配置为监听来自 Cloudflare IP 段的流量。</li>\n<li>客户端连接您的域名（实际上是连接到离客户端最近的 Cloudflare 边缘节点）。</li>\n<li>Cloudflare 接收到流量后，再将其转发到您的源代理服务器。</li>\n</ol>\n</li>\n<li><p><strong>必要条件:</strong></p>\n<ul>\n<li>一个您拥有的域名。</li>\n<li>一个 Cloudflare 账户（免费套餐通常已足够）。</li>\n<li>选择能够被 CDN 可靠代理的协议和传输方式。通常是基于 WebSocket (WS) 并通过 TLS 加密（通常在 443 端口）的协议，例如 Trojan + WS 或 VLESS + WS 。</li>\n</ul>\n</li>\n<li><p>Sing-box 配置示例 (客户端 Trojan + WS over CDN):</p>\n<p>服务器端需要配置相应的 Trojan + WebSocket 入站。客户端出站配置如下：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>注意：这里的 <code>server</code> 字段直接使用您的域名，因为 Cloudflare 会处理 IP 解析和转发。</p>\n</li>\n<li><p><strong>服务器端注意事项:</strong></p>\n<ul>\n<li>服务器上的 sing-box 需配置为监听 WebSocket 流量，并使用与客户端一致的路径。</li>\n<li>在 Cloudflare 的 DNS 设置中，确保对应域名的代理状态（橙色云朵）已开启。</li>\n<li>Cloudflare 的 SSL/TLS 加密模式建议设置为“完全”或“完全（严格）”，以确保从客户端到 Cloudflare 以及从 Cloudflare 到源服务器的全程加密。</li>\n</ul>\n</li>\n<li><p><strong>益处:</strong></p>\n<ul>\n<li>显著提高抵抗 IP 直接封锁的能力。</li>\n<li>CDN 的全球节点分布可能（但不一定）为部分用户带来访问延迟的改善（对于动态代理流量，CDN 缓存效果有限，但其路由优化仍有一定作用）。</li>\n</ul>\n</li>\n</ul>\n<p>将 CDN 置于代理服务器之前，相当于引入了一个广受信赖的中间层 。这种做法通常与 WebSocket 等能封装在标准 HTTP/HTTPS 请求中的传输协议配合使用。直接连接代理服务器 IP 的方式，一旦该 IP 地址被标记并封锁，服务即告中断。而 CDN 服务商（如 Cloudflare）拥有海量的 IP 地址资源，这些 IP 被大量合法网站共享。大规模封锁这些共享 IP 会造成巨大的“附带伤害”，审查机构对此通常较为谨慎。通过 CDN 传输的、使用 WebSocket 并以 TLS 加密的流量（尤其是在 443 端口），其外观与普通网站的 HTTPS 流量极为相似。CDN 在其边缘节点处理 TLS 握手，然后将流量（可能重新加密）转发至源服务器。这种方式不仅隐藏了真实服务器的 IP，还使得代理流量能够混入海量的、通过 CDN 的合法 HTTPS 流量之中，从而显著提升了抗审查的持久性。这对于在严格审查环境下维持代理服务的长期可用性是一项关键技术。</p>\n<h3 id=\"5-2-Sing-box-基础路由：智能分流流量\"><a href=\"#5-2-Sing-box-基础路由：智能分流流量\" class=\"headerlink\" title=\"5.2. Sing-box 基础路由：智能分流流量\"></a>5.2. Sing-box 基础路由：智能分流流量</h3><p>Sing-box 强大的路由功能允许用户根据多种条件精细控制流量走向，实现国内外分流、广告屏蔽、特定服务加速等目的。路由配置在 <code>config.json</code> 文件的 <code>route</code> 块中定义 。</p>\n<ul>\n<li><p><strong>常用规则类型:</strong></p>\n<ul>\n<li><strong>域名匹配:</strong> <code>domain</code> (精确匹配), <code>domain_suffix</code> (域名后缀匹配，如 <code>google.com</code>), <code>domain_keyword</code> (域名关键词匹配)。</li>\n<li><strong>IP 匹配:</strong> <code>ip_cidr</code> (IP 地址段匹配), <code>geoip</code> (基于 IP 的地理位置，如 <code>geoip:cn</code> 匹配中国大陆 IP) 。</li>\n<li><strong>预设网站列表:</strong> <code>geosite</code> (匹配预定义的网站分类，如 <code>geosite:google</code> 匹配谷歌相关服务) 。</li>\n<li><strong>协议类型:</strong> <code>protocol</code> (如 <code>dns</code> 专门匹配 DNS 查询流量) 。</li>\n<li><strong>端口:</strong> <code>port</code> (匹配目标端口)。</li>\n<li><strong>进程名/包名 (客户端):</strong> <code>process_name</code> (Windows/Linux 进程名) 或 <code>package_name</code> (Android 应用包名)。</li>\n</ul>\n</li>\n<li><p><strong>简单分流示例 (国内直连，国外代理):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"route\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"rules\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"final\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"proxy\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 所有未匹配上述规则的流量，默认通过名为 \"proxy\" 的出站 (即您的主代理出站)</span>\n    <span class=\"token property\">\"auto_detect_interface\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// 建议开启，自动检测网络接口</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>规则集 (<code>rule_set</code>):</strong> 为了方便管理大量的域名或 IP 列表，可以使用 <code>rule_set</code> 功能，引用预先编译好的规则文件（通常是 <code>.srs</code> 或 <code>.db</code> 格式）。这些规则集可以从远程 URL 下载更新。</p>\n</li>\n</ul>\n<h3 id=\"5-3-实现故障转移与基础负载均衡-URLTest-和-Selector\"><a href=\"#5-3-实现故障转移与基础负载均衡-URLTest-和-Selector\" class=\"headerlink\" title=\"5.3. 实现故障转移与基础负载均衡 (URLTest 和 Selector)\"></a>5.3. 实现故障转移与基础负载均衡 (URLTest 和 Selector)</h3><p>为了提高代理连接的稳定性和可用性，sing-box 提供了 <code>URLTest</code> 和 <code>Selector</code> 两种特殊的出站类型。</p>\n<ul>\n<li><p><strong>URLTest 出站 (自动选择最佳节点):</strong></p>\n<ul>\n<li><p><strong>用途:</strong> <code>URLTest</code> 会定期测试一组预定义的出站代理节点，并自动选择其中延迟最低（或最先成功响应）的节点作为当前使用的出站9。这主要用于实现故障自动切换 (failover) 和基于延迟的简单负载均衡。</p>\n</li>\n<li><p>关键字段:</p>\n<ul>\n<li><code>outbounds</code>: 一个包含多个代理出站标签（tag）的列表，<code>URLTest</code> 将对这些出站进行测试。</li>\n<li><code>url</code>: 用于测试的 URL，例如 <code>http://www.gstatic.com/generate_204</code> (谷歌提供的用于测试网络连通性的 URL，返回 HTTP 204 No Content)。如果为空，sing-box 有默认测试地址。</li>\n<li><code>interval</code>: 测试间隔时间，例如 <code>\"5m\"</code> 表示每 5 分钟测试一次。</li>\n<li><code>tolerance</code>: 延迟容忍度（毫秒），用于判断节点是否可用或切换的阈值。</li>\n</ul>\n</li>\n<li><p>示例:</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 参与测试的代理出站标签列表</span>\n      <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://www.gstatic.com/generate_204\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"interval\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"5m\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 每5分钟测试一次</span>\n      <span class=\"token property\">\"tolerance\"</span><span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token comment\">// 延迟容忍度 100ms</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后，在路由规则中（例如 route.final）使用 “auto-proxy-selector”作为出站。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Selector 出站 (手动选择节点):</strong></p>\n<ul>\n<li><p><strong>用途:</strong> <code>Selector</code> 允许用户从一个预定义的出站列表中手动选择一个当前使用的出站。这种选择通常通过外部 API (例如 sing-box 的 Clash API 兼容接口) 进行控制，图形化客户端常利用此功能提供节点切换界面 。</p>\n</li>\n<li><p>关键字段:</p>\n<ul>\n<li><code>outbounds</code>: 一个包含多个出站标签（可以是具体代理，也可以是 <code>direct</code> 或其他 <code>URLTest</code> 组）的列表。</li>\n<li><code>default</code>: 默认选中的出站标签。</li>\n</ul>\n</li>\n<li><p>示例:</p>\n<pre class=\"line-numbers language-JSON\" data-language=\"JSON\"><code class=\"language-JSON\">{\n  \"outbounds\":, // 可供选择的出站列表\n      \"default\": \"proxy-vless\" // 默认选择 \"proxy-vless\"\n    }\n  ]\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同样，可以在路由规则中使用 “manual-proxy-selector”。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>URLTest</code> 和 <code>Selector</code> 为 sing-box 提供了强大的流量管理能力。<code>URLTest</code> 通过自动化的健康检查和延迟测试 ，确保了连接的韧性：当某个代理节点失效或表现不佳时，它能自动切换到其他可用节点，从而在无需用户干预的情况下维持“科学上网”的通畅。这对于故障转移至关重要。另一方面，<code>Selector</code> 则赋予用户明确的控制权 ，允许用户根据特定需求（如访问特定区域的地理限制内容，或临时切换到直连）主动选择出口。Clash API 的支持使得图形化客户端能够方便地集成这种手动选择功能。实际应用中，一种常见的模式是将多个 <code>URLTest</code> 分组（例如，一组美国服务器，一组日本服务器），然后使用一个 <code>Selector</code> 在这些分组或单个优质代理之间进行选择。这种组合既满足了自动化故障恢复的需求，也兼顾了用户的主动偏好。</p>\n<h2 id=\"第六章：故障排除与日常维护\"><a href=\"#第六章：故障排除与日常维护\" class=\"headerlink\" title=\"第六章：故障排除与日常维护\"></a>第六章：故障排除与日常维护</h2><p>即使配置无误，有时也可能遇到连接问题。了解如何排查故障和进行日常维护，是确保代理服务长期稳定运行的关键。</p>\n<h3 id=\"6-1-“芝麻开门”：通过-Sing-box-日志寻找线索\"><a href=\"#6-1-“芝麻开门”：通过-Sing-box-日志寻找线索\" class=\"headerlink\" title=\"6.1. “芝麻开门”：通过 Sing-box 日志寻找线索\"></a>6.1. “芝麻开门”：通过 Sing-box 日志寻找线索</h3><p>日志是排查问题的第一手资料。当遇到连接失败、速度缓慢或其他异常行为时，首先应该查看 sing-box 的日志。</p>\n<ul>\n<li><p><strong>服务器端日志:</strong> 如果 sing-box 作为系统服务运行 (通过 <code>systemd</code> 管理)，可以使用以下命令查看实时日志：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo journalctl -u sing-box -f --output cat<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果直接通过 sing-box run 命令在前台运行，日志会直接输出到终端，或者根据 config.json 中 log.output 的设置输出到指定文件。</p>\n</li>\n<li><p><strong>客户端日志:</strong></p>\n<ul>\n<li>如果使用 sing-box 命令行作为客户端，日志同样会输出到终端或配置文件中指定的位置。</li>\n<li>图形化客户端通常内置了日志查看器，方便用户查阅。</li>\n</ul>\n</li>\n<li><p><strong>关注日志中的关键信息:</strong></p>\n<ul>\n<li><strong>错误信息 (Error messages):</strong> 明确指示问题的发生，如连接超时、认证失败、证书错误等。</li>\n<li><strong>警告信息 (Warning messages):</strong> 可能提示潜在问题或配置不当。</li>\n<li><strong>连接尝试与结果:</strong> 可以看到客户端的连接请求、使用的协议、目标地址等。</li>\n<li><strong>路由决策:</strong> 对于复杂的路由配置，日志可以显示流量是如何根据规则被导向特定出站的。</li>\n<li><strong>日志级别 (<code>log.level</code>):</strong> 在 <code>config.json</code> 中，可以将 <code>log.level</code> 设置为 <code>\"debug\"</code> 甚至 <code>\"trace\"</code> 以获取更详细的诊断信息，但在正常运行时建议使用 <code>\"info\"</code> 或 <code>\"warn\"</code> 以避免日志过于庞大 。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-2-配置检查：使用-sing-box-check-进行预检\"><a href=\"#6-2-配置检查：使用-sing-box-check-进行预检\" class=\"headerlink\" title=\"6.2. 配置检查：使用 sing-box check 进行预检\"></a>6.2. 配置检查：使用 <code>sing-box check</code> 进行预检</h3><p>在修改 <code>config.json</code> 文件后，启动或重启 sing-box 服务之前，务必使用 <code>sing-box check</code> 命令校验配置文件的有效性：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sing-box check -c /path/to/your/config.json<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>该命令会检查 JSON 语法是否正确、字段名和值是否符合 sing-box 的规范。</p>\n<p><code>sing-box check</code> 命令是配置管理流程中不可或缺的“预飞检查”环节 。JSON 格式对逗号、括号、引号等符号要求严格，而 sing-box 的配置项众多且可能存在嵌套，手动编辑时很容易出现笔误或使用了不正确的字段名。如果直接运行一个有错误的配置文件，可能导致 sing-box 服务启动失败、意外崩溃或行为异常。例如，某些 GitHub issue 中报告的崩溃问题，部分可能源于配置不当（提到的一个与 tun 配置相关的崩溃，如果涉及到需要 root 权限的资源访问，<code>check</code> 命令在尝试校验时或许能提前发现权限问题或配置冲突）。因此，在每次修改配置文件后、重启服务前，执行 <code>sing-box check</code>，可以及时发现并修正这些低级错误，从而节省大量的排错时间和避免不必要的服务中断。</p>\n<h3 id=\"6-3-常见连接问题及其解决方案\"><a href=\"#6-3-常见连接问题及其解决方案\" class=\"headerlink\" title=\"6.3. 常见连接问题及其解决方案\"></a>6.3. 常见连接问题及其解决方案</h3><ul>\n<li><strong>防火墙阻挡端口:</strong><ul>\n<li><strong>症状:</strong> 客户端无法连接到服务器的指定端口。</li>\n<li><strong>排查:</strong> 仔细检查服务器的防火墙规则 (UFW, firewalld)，确保已为 sing-box 使用的协议和端口正确开放了 TCP 和/或 UDP 流量。</li>\n</ul>\n</li>\n<li><strong>客户端配置错误:</strong><ul>\n<li><strong>症状:</strong> 连接失败，日志提示认证错误、地址错误等。</li>\n<li><strong>排查:</strong> 逐项核对客户端配置中的服务器地址、端口、用户ID (UUID)、密码、加密方法、传输参数（如 WebSocket 路径）、TLS SNI 等，确保与服务器端的入站配置完全一致。</li>\n</ul>\n</li>\n<li><strong>TLS 相关错误 (适用于 VLESS, Trojan, Hysteria2, TUIC 等):</strong><ul>\n<li><strong>SNI 不匹配:</strong> 客户端 <code>tls.server_name</code> 与服务器证书或 Reality/Trojan 期望的 SNI 不符。</li>\n<li><strong>服务器证书无效/过期:</strong> 检查服务器证书状态，及时续签或修复。</li>\n<li><strong>客户端无法验证服务器证书:</strong> 如果服务器使用自签名证书，客户端需要导入该证书或（不推荐，但可用于测试）设置 <code>insecure: true</code>。对于 Reality，确保客户端的 <code>tls.server_name</code> 与服务器 <code>reality.handshake.server</code> 一致。</li>\n</ul>\n</li>\n<li><strong>DNS 解析问题:</strong><ul>\n<li><strong>症状:</strong> 可以连接代理，但无法访问网站，或特定网站无法打开。</li>\n<li>排查:<ul>\n<li>检查客户端和服务器 <code>dns</code> 配置块。</li>\n<li>确保代理服务器自身能够正常解析外部域名（可在服务器上用 <code>ping</code> 或 <code>nslookup</code> 测试）。</li>\n<li>客户端 DNS 是否正确通过代理或指定 DNS 服务器解析，避免 DNS 泄露。</li>\n<li>因 IPv6 偏好设置导致的 DNS 解析问题，提示注意 DNS 策略配置。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Reality 握手失败:</strong><ul>\n<li><strong>症状:</strong> VLESS+Reality 连接失败。</li>\n<li><strong>排查:</strong> 确认客户端的 <code>public_key</code>、<code>short_id</code> 与服务器端的 <code>private_key</code>、<code>short_id</code> 对应且正确。确认客户端 <code>tls.server_name</code> 与服务器端 <code>reality.handshake.server</code> 配置的域名一致。检查伪装的目标网站 (<code>reality.handshake.server</code>) 是否可访问且其 TLS 证书有效。</li>\n</ul>\n</li>\n<li><strong>网络不可达 (“network is unreachable”):</strong><ul>\n<li><strong>症状:</strong> 日志中出现此类错误。</li>\n<li><strong>排查:</strong> 服务器可能已宕机，服务器 IP 可能被 ISP 封锁，或者存在网络路由问题。检查服务器状态和网络连通性 。</li>\n</ul>\n</li>\n<li><strong>时间同步问题:</strong><ul>\n<li><strong>症状:</strong> 某些协议（特别是依赖 TLS 和证书的）连接失败。</li>\n<li><strong>排查:</strong> 确保客户端和服务器的时间基本同步。在服务器上配置并启用 NTP 服务（sing-box 配置中也有 <code>ntp</code> 模块）。</li>\n</ul>\n</li>\n<li><strong>服务器资源耗尽:</strong><ul>\n<li><strong>症状:</strong> 连接不稳定，速度极慢，服务频繁重启。</li>\n<li><strong>排查:</strong> 登录服务器检查 CPU、内存、带宽使用情况。如果资源不足，考虑升级 VPS 配置或优化 sing-box 配置（如限制并发连接数）。</li>\n</ul>\n</li>\n<li><strong>Sing-box 进程崩溃 (panic):</strong><ul>\n<li><strong>症状:</strong> 服务意外停止，日志中出现 <code>panic:</code> 开头的错误信息和堆栈跟踪。</li>\n<li><strong>排查:</strong> <code>panic</code> 通常指示程序内部错误（bug）、不兼容的配置、或严重的资源问题 24。仔细阅读 <code>panic</code> 信息和相关的上下文日志。如果怀疑是 sing-box 的 bug，可以附上详细的日志、可复现的配置和操作步骤，到 sing-box 的 GitHub Issues 页面报告。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-4-保持更新：维护-Sing-box-及配置的有效性\"><a href=\"#6-4-保持更新：维护-Sing-box-及配置的有效性\" class=\"headerlink\" title=\"6.4. 保持更新：维护 Sing-box 及配置的有效性\"></a>6.4. 保持更新：维护 Sing-box 及配置的有效性</h3><p>网络审查技术和代理协议本身都在不断发展和演变。为了保持代理服务的有效性和安全性，需要进行持续的维护：</p>\n<ul>\n<li><strong>定期更新 Sing-box:</strong> 关注 SagerNet/sing-box 的 GitHub Releases 页面，及时将 sing-box 程序更新到最新的稳定版本。新版本通常包含 bug 修复、性能优化、安全更新以及对新特性或协议的支持。可以通过重新运行安装脚本或使用系统的包管理器进行更新。</li>\n<li><strong>关注社区动态:</strong> 留意 sing-box 的 GitHub Issues 、官方文档更新以及相关的技术社区和论坛。这些渠道通常会讨论最新的审查手段、协议的有效性变化以及新的规避策略。</li>\n<li><strong>更新路由规则集:</strong> 如果在路由配置中使用了 GeoIP、Geosite 等远程规则集，应确保这些规则集能够定期更新，以保证分流的准确性。部分客户端或辅助工具可能提供自动更新规则集的功能 。</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>Sing-box 作为一个强大且灵活的通用代理平台，为用户提供了构建自定义“科学上网”节点的坚实基础。通过本教程的指引，用户应能掌握从服务器准备、sing-box 安装、核心协议配置到客户端设置的完整流程。无论是追求极致隐蔽性的 VLESS+Reality、模仿 HTTPS 的 Trojan，还是经典高效的 Shadowsocks，亦或是面向特定网络优化的 Hysteria2 和 TUIC，sing-box 都能提供良好的支持。</p>\n<p>然而，需要强调的是，网络审查与规避技术之间的博弈是一个持续动态的过程。今天有效的协议或配置，明天可能就会面临新的挑战。因此，保持学习的热情，关注技术前沿，并根据实际情况灵活调整策略，是确保长期顺畅访问互联网的关键。</p>\n<p>最后，请负责任地使用本教程提供的知识和工具，遵守当地法律法规，并将其用于促进信息自由交流和个人学习研究等正当目的。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"A-1-Sing-box-常用命令行-CLI-命令参考\"><a href=\"#A-1-Sing-box-常用命令行-CLI-命令参考\" class=\"headerlink\" title=\"A.1. Sing-box 常用命令行 (CLI) 命令参考\"></a>A.1. Sing-box 常用命令行 (CLI) 命令参考</h3><p>尽管 sing-box 的命令行参数和子命令的官方集中文档尚不完善，但通过分析其源码、社区讨论和实际使用，可以总结出以下常用命令：</p>\n<ul>\n<li><p><strong>核心操作:</strong></p>\n<ul>\n<li><pre><code>sing-box run [options]\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n  : 运行 sing-box 实例。\n\n  - `-c, --config &lt;path&gt;`: 指定一个或多个配置文件路径（JSON 或 SJSON 格式）。可以指定目录，sing-box 会加载目录内所有 `.json` 文件 22。\n  - `-D, --directory &lt;path&gt;`: 指定配置文件目录，与 `-c` 配合使用。\n  - `--disable-color`: 禁用彩色日志输出。\n\n- ```\n  sing-box check [options]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n: 检查配置文件的有效性。\n\n- `-c, --config &lt;path&gt;`: 同 `run` 命令。\n- `-D, --directory &lt;path&gt;`: 同 `run` 命令。\n- `--format`: 检查后自动格式化配置文件。\n</code></pre>\n</li>\n<li><pre><code>sing-box format [options]\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n  : 格式化（美化）配置文件。\n\n  - `-c, --config &lt;path&gt;`: 指定输入配置文件。\n  - `-D, --directory &lt;path&gt;`: 指定配置文件目录。\n  - `-w, --write`: 将格式化后的内容写回原文件 5。\n  - `-o, --output &lt;path&gt;`: 将格式化后的内容输出到指定文件。\n\n- ```\n  sing-box version<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n: 显示版本信息，包括构建标签 。\n\n\n\n- `-n, --name`: 只显示版本名称。\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>密钥生成:</strong></p>\n<ul>\n<li><code>sing-box generate uuid</code>: 生成一个 UUID 11。</li>\n<li><code>sing-box generate reality-keypair</code>: 生成 Reality 公私钥对 11。</li>\n<li><code>sing-box generate rand &lt;length&gt;</code>: 生成指定长度的随机字符串（可用于密码）。</li>\n</ul>\n</li>\n<li><p><strong>其他 (可能存在或特定构建中包含):</strong></p>\n<ul>\n<li><code>sing-box geoip export &lt;path&gt;</code>: 导出 GeoIP 数据。</li>\n<li><code>sing-box geosite export &lt;path&gt;</code>: 导出 Geosite 数据。</li>\n<li><code>sing-box rule-set compile</code>: 编译规则集。</li>\n<li><code>sing-box rule-set merge</code>: 合并规则集。</li>\n</ul>\n</li>\n<li><p><strong>通过 <code>systemd</code> 进行服务管理 (Linux):</strong></p>\n<ul>\n<li><code>sudo systemctl start sing-box</code></li>\n<li><code>sudo systemctl stop sing-box</code></li>\n<li><code>sudo systemctl restart sing-box</code></li>\n<li><code>sudo systemctl enable sing-box</code></li>\n<li><code>sudo systemctl disable sing-box</code></li>\n<li><code>sudo systemctl status sing-box</code></li>\n<li><code>sudo journalctl -u sing-box -f --output cat</code> 11</li>\n</ul>\n</li>\n</ul>\n<p>目前关于 sing-box 命令行工具的详细信息较为分散，可见于 GitHub issue 讨论 24、博客文章 19、官方文档的特定子页面 5 以及 Go 语言的源代码文件 22。尚无一个统一、详尽的“man page”式参考手册。上述列表整合了目前已知的主要命令及其功能，对于习惯使用命令行的用户而言，这是一个实用的快速参考。最准确和完整的参数列表，理论上可以通过 <code>sing-box --help</code> 或 <code>sing-box &lt;subcommand&gt; --help</code> 获取，但具体输出内容未在本次研究资料中直接提供。</p>\n<h3 id=\"A-2-关键术语解释\"><a href=\"#A-2-关键术语解释\" class=\"headerlink\" title=\"A.2. 关键术语解释\"></a>A.2. 关键术语解释</h3><ul>\n<li><strong>CDN (Content Delivery Network, 内容分发网络):</strong> 一组分布在不同地理位置的服务器，用于缓存和加速网站内容的传递。在代理场景中，可用于隐藏源服务器 IP。</li>\n<li><strong>DPI (Deep Packet Inspection, 深度包检测):</strong> 一种网络数据包过滤技术，通过检查数据包的内容来识别协议类型、应用或特定数据模式，常用于网络审查。</li>\n<li><strong>GFW (Great Firewall, 防火长城):</strong> 指中国大陆用于互联网审查和内容过滤的一系列技术和行政手段的俗称。</li>\n<li><strong>GeoIP:</strong> 基于 IP 地址确定其地理位置的技术或数据库。</li>\n<li><strong>Geosite:</strong> 预定义的网站域名分类列表，常用于路由规则中对特定类型的网站进行分流。</li>\n<li><strong>Inbound (入站):</strong> Sing-box 中处理传入连接的配置模块。</li>\n<li><strong>Outbound (出站):</strong> Sing-box 中处理传出连接的配置模块。</li>\n<li><strong>Multiplexing (多路复用):</strong> 在单个网络连接（通常是 TCP 连接）上承载多个独立的逻辑数据流的技术，可以提高连接效率和并发性能。</li>\n<li><strong>QUIC (Quick UDP Internet Connections):</strong> 一种基于 UDP 的新型传输层网络协议，旨在提供比 TCP 更低的延迟和更好的拥塞控制，是 HTTP/3 的基础。</li>\n<li><strong>Reality:</strong> 一种 VLESS 协议的扩展，通过模拟真实网站的 TLS 握手来增强代理服务器的隐蔽性，抵抗主动探测。</li>\n<li><strong>SNI (Server Name Indication):</strong> TLS 协议的一个扩展，允许客户端在 TLS 握手初期就告知服务器其希望连接的域名，使得同一 IP 地址可以托管多个 HTTPS 网站。</li>\n<li><strong>TLS (Transport Layer Security, 传输层安全协议):</strong> 用于在两个通信应用程序之间提供私密性和数据完整性的加密协议，是 HTTPS 的基础。</li>\n<li><strong>UDP (User Datagram Protocol, 用户数据报协议):</strong> 一种无连接的传输层协议，提供快速但不可靠的数据传输。</li>\n<li><strong>UUID (Universally Unique Identifier, 通用唯一识别码):</strong> 一个128位的数字，用于在计算机系统中唯一地标识信息。在代理协议中常用作用户ID。</li>\n<li><strong>WebSocket (WS):</strong> 一种在单个 TCP 连接上进行全双工通信的协议，常用于 Web 应用。在代理中，可将流量封装在类似 HTTP 的连接中，便于穿透防火墙或通过 CDN。</li>\n<li><strong>XTLS-Vision:</strong> VLESS 协议的一种流控模式，旨在减少加密开销，提高性能。</li>\n</ul>\n<h3 id=\"A-3-进一步学习资源\"><a href=\"#A-3-进一步学习资源\" class=\"headerlink\" title=\"A.3. 进一步学习资源\"></a>A.3. 进一步学习资源</h3><ul>\n<li><strong>Sing-box 官方文档:</strong> <a href=\"https://sing-box.sagernet.org/\">https://sing-box.sagernet.org/</a> 5</li>\n<li><strong>Sing-box GitHub 仓库:</strong>(<a href=\"https://github.com/SagerNet/sing-box\">https://github.com/SagerNet/sing-box</a>) 7</li>\n<li><strong>GUI.for.SingBox (图形化客户端):</strong>(<a href=\"https://github.com/GUI-for-Cores/GUI.for.SingBox\">https://github.com/GUI-for-Cores/GUI.for.SingBox</a>) 56</li>\n<li><strong>Nekoray / NekoBox (图形化客户端):</strong>(<a href=\"https://github.com/MatsuriDayo/nekoray\">https://github.com/MatsuriDayo/nekoray</a>) (原版，新版可搜索 NekoBox)</li>\n<li><strong>Hiddify-Next (图形化客户端):</strong> <a href=\"https://github.com/hiddify/hiddify-next\">https://github.com/hiddify/hiddify-next</a></li>\n</ul>\n",
            "tags": [
                "教程"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2021/04/23/http-xue-xi/",
            "url": "https://0xdadream.github.io/2021/04/23/http-xue-xi/",
            "title": "HTTP学习",
            "date_published": "2021-04-23T01:25:00.000Z",
            "content_html": "<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><h2 id=\"web协议\"><a href=\"#web协议\" class=\"headerlink\" title=\"web协议\"></a>web协议</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议 ）的协议作为规范，完成从客户端到服务器端等一系列运作流程。</p>\n<p>1997 年  1 月公布的  HTTP/1.1 是目前主流的  HTTP 协议版本。</p>\n<h3 id=\"TCP-IP协议簇\"><a href=\"#TCP-IP协议簇\" class=\"headerlink\" title=\"TCP/IP协议簇\"></a>TCP/IP协议簇</h3><p><img src=\"https://images.dadream.eu.org/images/2024/07/cb757b5e4fbd69d9a7870cf73ec5f2c8.png\"></p>\n<h4 id=\"TCP-IP分层\"><a href=\"#TCP-IP分层\" class=\"headerlink\" title=\"TCP/IP分层\"></a>TCP/IP分层</h4><h5 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h5><p>FTP（FileTransfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）</p>\n<p>HTTP</p>\n<h5 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h5><p>TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）</p>\n<h5 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h5><p>网络层所起的作用就是在众多的选项内选择一条传输路线</p>\n<h5 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h5><p>用来处理连接网络的硬件部分</p>\n<h4 id=\"TCP-IP-通信传输流\"><a href=\"#TCP-IP-通信传输流\" class=\"headerlink\" title=\"TCP/IP 通信传输流\"></a>TCP/IP 通信传输流</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/81ffdf57755cc7acedb59dfef5c70546.png\"></p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>IP（Internet Protocol）网际协议位于网络层</p>\n<p>IP 协议的作用是把各种数据包传送给对方。</p>\n<p>P 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。</p>\n<h3 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h3><p>ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p>\n<h4 id=\"路由选择\"><a href=\"#路由选择\" class=\"headerlink\" title=\"路由选择\"></a>路由选择</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/0c783c5c7eef0356ea5f3a327fb43c70.png\"></p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>TCP 位于传输层，提供可靠的字节流服务</p>\n<h4 id=\"tcp三次握手\"><a href=\"#tcp三次握手\" class=\"headerlink\" title=\"tcp三次握手\"></a>tcp三次握手</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/4fd95e6d2b8edcd965ce11295ac0c301.png\"></p>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的<br>协议。它提供域名到 IP 地址之间的解析服务。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/9b9ebce7681849f430d21d47495b3400.png\"></p>\n<h3 id=\"各协议关系\"><a href=\"#各协议关系\" class=\"headerlink\" title=\"各协议关系\"></a>各协议关系</h3><p><img src=\"https://images.dadream.eu.org/images/2024/07/7e76c47328b109133df3878b6803e24a.png\"></p>\n<h3 id=\"URI\"><a href=\"#URI\" class=\"headerlink\" title=\"URI\"></a>URI</h3><p>URI 是 Uniform Resource Identifier 的缩写。</p>\n<p>URI 用字符串标识某一互联网资源，而 URL表示资源的地点（互联网上所处的位置）</p>\n<h4 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/48eb2105e992b313cb99eb9cb2a0e897.png\"></p>\n<p>as：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">ftp</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">//ftp.is.co.za/rfc/rfc1808.txt</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">http</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">//www.ietf.org/rfc/rfc2396.txt</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">ldap</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">//[2001:db8::7]/c=GB?objectClass?one</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">mailto</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">John.Doe@example.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">news</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">comp.infosystems.www.servers.unix</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">tel</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">+1-816-555-1212</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">telnet</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">//192.0.2.16:80/</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">urn</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">oasis:names:specification:docbook:dtd:xml:4.1.2</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<hr>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><h3 id=\"S-B客服端与服务器端的交互\"><a href=\"#S-B客服端与服务器端的交互\" class=\"headerlink\" title=\"S-B客服端与服务器端的交互\"></a>S-B客服端与服务器端的交互</h3><p>在两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。</p>\n<p>HTTP 是不保存状态的协议</p>\n<h3 id=\"请求-响应\"><a href=\"#请求-响应\" class=\"headerlink\" title=\"请求-响应\"></a>请求-响应</h3><p><img src=\"https://images.dadream.eu.org/images/2024/07/4043823659f06850225215b355d26e70.png\"></p>\n<p>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/5064a6a828ab020f5558b42c2dfbdf58.png\"></p>\n<p>响应报文</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/7931c23a1e3c807e44a4108e514bb99d.png\"></p>\n<p>URI请求</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/84626c79794c0eb39904acbe02811cb4.png\"></p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><h4 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h4><p>GET ：获取资源<br>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保 持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接 口）那样的程序，则返回经过执行后的输出结果。</p>\n<p>请求：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">GET</span> <span class=\"token request-target url\">/index.html</span> <span class=\"token http-version property\">HTTP/1.1</span></span> \n\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">www.hackr.jp</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>响应：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">返回  index.html 的页面资源<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h4 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h4><p>POST：传输实体主体<br>POST 方法用来传输实体的主体。<br>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。</p>\n<p>请求：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">POST</span> <span class=\"token request-target url\">/submit.cgi</span> <span class=\"token http-version property\">HTTP/1.1</span></span> \n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">www.hackr.jp </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Length</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">1560（1560字节的数据）</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>响应：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">返回  submit.cgi 接收数据的处理结果 <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h4 id=\"PUT\"><a href=\"#PUT\" class=\"headerlink\" title=\"PUT\"></a>PUT</h4><p>PUT：传输文件<br>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请 求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。 </p>\n<p>请求：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">PUT</span> <span class=\"token request-target url\">/example.html</span> <span class=\"token http-version property\">HTTP/1.1</span></span> \n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">www.hackr.jp </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Length</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">1560（1560 字节的数据</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>响应：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">响应返回状态码  204 No Content（比如  ：该  html 已存在于服务器上） <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h4 id=\"HEAD\"><a href=\"#HEAD\" class=\"headerlink\" title=\"HEAD\"></a>HEAD</h4><p>HEAD：获得报文首部<br>HEAD 方法和  GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。</p>\n<p>请求：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">HEAD</span> <span class=\"token request-target url\">/index.html</span> <span class=\"token http-version property\">HTTP/1.1</span></span> \n\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">www.hackr.jp </span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>响应：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">返回index.html有关的响应首部 <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h4 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h4><p>DELETE：删除文件<br>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。</p>\n<p>请求：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">DELETE</span> <span class=\"token request-target url\">/example.html</span> <span class=\"token http-version property\">HTTP/1.1</span></span> \n\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">www.hackr.jp </span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>响应：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">响应返回状态码  204 No Content（比如  ：该  html 已从该服务器上删除） <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h4 id=\"OPTIONS\"><a href=\"#OPTIONS\" class=\"headerlink\" title=\"OPTIONS\"></a>OPTIONS</h4><p>OPTIONS：询问支持的方法<br>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。 </p>\n<p>请求：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">OPTIONS * HTTP/1.1 \n\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">www.hackr.jp </span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>响应：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Allow</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">GET, POST, HEAD, OPTIONS （返回服务器支持的方法） </span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n\n\n\n\n<h4 id=\"TRACK\"><a href=\"#TRACK\" class=\"headerlink\" title=\"TRACK\"></a>TRACK</h4><p>TRACE：追踪路径<br>TRACE 方法是让  Web 服务器端将之前的请求通信环回给客户端的方 法。<br>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应</p>\n<p>请求：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">TRACE</span> <span class=\"token request-target url\">/</span> <span class=\"token http-version property\">HTTP/1.1</span></span> \n\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">hackr.jp </span></span>\n\n<span class=\"token header\"><span class=\"token header-name keyword\">Max-Forwards</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">2 </span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>响应：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK </span></span>\n\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">message/http </span></span>\n\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Length</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">1024 </span></span>\n<span class=\"token request-line\"><span class=\"token method property\">TRACE</span> <span class=\"token request-target url\">/</span> <span class=\"token http-version property\">HTTP/1.1</span></span> \n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">hackr.jp </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Max-Forwards</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">2（返回响应包含请求内容） </span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"CONNECT\"><a href=\"#CONNECT\" class=\"headerlink\" title=\"CONNECT\"></a>CONNECT</h4><p>CONNECT：要求用隧道协议连接代理<br>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接 层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容 加 密后经网络隧道传输。<br>CONNECT 方法的格式如下所示。 </p>\n<p>CONNECT 代理服务器名:端口号    HTTP版本 </p>\n<p>请求：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">CONNECT proxy.hackr.jp:8080 HTTP/1.1 \n\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">proxy.hackr.jp </span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>响应：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK（之后进入网络隧道） </span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/bc16fc0bdc1aef2e1d96c95a7305119b.png\"></p>\n<h3 id=\"持久连接\"><a href=\"#持久连接\" class=\"headerlink\" title=\"持久连接\"></a>持久连接</h3><p>持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互</p>\n<h4 id=\"管线化\"><a href=\"#管线化\" class=\"headerlink\" title=\"管线化\"></a>管线化</h4><p>不等待响应，直接发送下一个请求</p>\n<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h3><p><img src=\"https://images.dadream.eu.org/images/2024/07/be4b0058f89df48262095fa3817ef763.png\"><img src=\"https://images.dadream.eu.org/images/2024/07/bafece7685c6f5723d0be0b8d9900781.png\"></p>\n<p>请求：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">GET</span> <span class=\"token request-target url\">/image/</span> <span class=\"token http-version property\">HTTP/1.1</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">hackr.jp</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Cookie</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">sid=1342077140226724</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>响应：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Date</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Thu, 12 Jul 2012 07:12:20 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Server</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Apache</span></span>\n＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,\n10-Oct-12 07:12:20 GMT＞\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/plain; charset=UTF-8</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<hr>\n<h2 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h2><h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p><img src=\"https://images.dadream.eu.org/images/2024/07/3cc4a6cf42aa0161d3b83ff598b01724.png\"><img src=\"https://images.dadream.eu.org/images/2024/07/3ad6ac069f66bb198aba64a2803ea8ad.png\"></p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/42f1143b5ce8261c3255e62dd8e28d32.png\"></p>\n<h3 id=\"压缩传输\"><a href=\"#压缩传输\" class=\"headerlink\" title=\"压缩传输\"></a>压缩传输</h3><p>常用的内容编码有以下几种：<br>gzip（GNU zip）<br>compress（UNIX 系统的标准压缩）<br>deflate（zlib）<br>identity（不进行编码）</p>\n<h3 id=\"分割发送的分块传输编码\"><a href=\"#分割发送的分块传输编码\" class=\"headerlink\" title=\"分割发送的分块传输编码\"></a>分割发送的分块传输编码</h3><p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。<br>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编 码前的实体主体。</p>\n<h3 id=\"发送多种数据的多部分对象集合\"><a href=\"#发送多种数据的多部分对象集合\" class=\"headerlink\" title=\"发送多种数据的多部分对象集合\"></a>发送多种数据的多部分对象集合</h3><ul>\n<li><p>multipart/form-data（文件上传时）</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">multipart/form-data; boundary=AaB03x</span></span>\n--AaB03x\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Disposition</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">form-data; name=\"field1\"</span></span>\nJoe Blow\n--AaB03x\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Disposition</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">form-data; name=\"pics\"; filename=\"file1.txt\"</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/plain</span></span>\n<span class=\"token text-plain\">...（file1.txt的数据）...\n--AaB03x--</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>multipart/byteranges</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">206</span> <span class=\"token reason-phrase string\">Partial Content</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Date</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Fri, 13 Jul 2012 02:45:26 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Last-Modified</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Fri, 31 Aug 2007 02:02:20 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">multipart/byteranges; boundary=THIS_STRING_SEPARATES</span></span>\n\n--THIS_STRING_SEPARATES\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/pdf</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Range</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">bytes 500-999/8000</span></span>\n...（范围指定的数据）...\n\n--THIS_STRING_SEPARATES\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/pdf</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Range</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">bytes 7000-7999/8000</span></span>\n...（范围指定的数据）...\n--THIS_STRING_SEPARATES--<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>使用 boundary 字符串来划分多部分对象集合指明的各类实体。在boundary 字符串指定的各个实体的起始行之前插入“–”标记（例如：–AaB03x、–THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“–”标记（例如：–AaB03x–、–THIS_STRING_SEPARATES–）作为结束。</p>\n<h3 id=\"获取部分内容的范围请求（分段请求）\"><a href=\"#获取部分内容的范围请求（分段请求）\" class=\"headerlink\" title=\"获取部分内容的范围请求（分段请求）\"></a>获取部分内容的范围请求（分段请求）</h3><p><img src=\"https://images.dadream.eu.org/images/2024/07/702457428b380409f065b3cb6853fd08.png\"></p>\n<p>从一开始到  3000 字节和  5000~7000 字节，8000到之后全部的多重范围</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Range</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">bytes=-3000, 5000-7000 ,8000-</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"内容协商\"><a href=\"#内容协商\" class=\"headerlink\" title=\"内容协商\"></a>内容协商</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然 后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字 符集、编码方式等作为判断的基准。</p>\n<p>参照头</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">Accept \nAccept-Charset\nAccept-Encoding \nAccept-Language \nContent-Language<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>内容协商技术</p>\n<ul>\n<li>服务器驱动协商</li>\n<li>客户端驱动协商</li>\n<li>透明协商</li>\n</ul>\n<h2 id=\"HTTP返回状态码\"><a href=\"#HTTP返回状态码\" class=\"headerlink\" title=\"HTTP返回状态码\"></a>HTTP返回状态码</h2><h3 id=\"类别\"><a href=\"#类别\" class=\"headerlink\" title=\"类别\"></a>类别</h3><p><img src=\"https://images.dadream.eu.org/images/2024/07/448efd6d806b88b6d8ae97140bafec53.png\"></p>\n<h4 id=\"2XX\"><a href=\"#2XX\" class=\"headerlink\" title=\"2XX\"></a>2XX</h4><p>2XX 的响应结果表明请求被正常处理了</p>\n<h5 id=\"200OK\"><a href=\"#200OK\" class=\"headerlink\" title=\"200OK\"></a>200OK</h5><p>表示从客户端发来的请求在服务器端被正常处理了，get请求回返回实体，head请求返回实体首部</p>\n<h5 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h5><p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。（浏览器不更新页面）</p>\n<h5 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h5><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>\n<h4 id=\"3XX重定向\"><a href=\"#3XX重定向\" class=\"headerlink\" title=\"3XX重定向\"></a>3XX重定向</h4><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>\n<h5 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h5><p>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p>\n<h5 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h5><p>临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。不更新书签，仍保留产生302的url</p>\n<h5 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h5><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。例如，post方法请求时，处理结果希望客服端采用get方法获取资源</p>\n<h5 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h5><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。</p>\n<p>附带条件的请求是指采用 GET方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。</p>\n<h5 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h5><h4 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h4><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>\n<h5 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h5><p>该状态码表示请求报文中存在语法错误。修改报文再发送。和200异曲同工</p>\n<h5 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h5><p>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。</p>\n<p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。</p>\n<p>首次返回一个认证框，再返回就是认证失败</p>\n<h5 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h5><p>该状态码表明对请求资源的访问被服务器拒绝了。</p>\n<h5 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h5><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>\n<h4 id=\"5XX-服务器错误\"><a href=\"#5XX-服务器错误\" class=\"headerlink\" title=\"5XX 服务器错误\"></a>5XX 服务器错误</h4><p>5XX 的响应结果表明服务器本身发生错误。</p>\n<h5 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h5><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。</p>\n<h5 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h5><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>\n<h3 id=\"samll-tips\"><a href=\"#samll-tips\" class=\"headerlink\" title=\"samll_tips\"></a>samll_tips</h3><p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。</p>\n<h2 id=\"与-HTTP-协作的-Web-服务器\"><a href=\"#与-HTTP-协作的-Web-服务器\" class=\"headerlink\" title=\"与 HTTP 协作的 Web 服务器\"></a>与 HTTP 协作的 Web 服务器</h2><h3 id=\"用单台虚拟主机实现多个域名\"><a href=\"#用单台虚拟主机实现多个域名\" class=\"headerlink\" title=\"用单台虚拟主机实现多个域名\"></a>用单台虚拟主机实现多个域名</h3><p>一台服务器托管了两个域名，<a href=\"http://www.hacker.com,www.hacker2.com,两个域名托管在一个虚拟机,则dns解析后ip相同,两个域名会访问一个ip.在相同的/\">www.hacker.com,www.hacker2.com，两个域名托管在一个虚拟机，则DNS解析后IP相同，两个域名会访问一个IP。在相同的</a> IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。</p>\n<h3 id=\"通信数据转发程序-：代理、网关、隧道\"><a href=\"#通信数据转发程序-：代理、网关、隧道\" class=\"headerlink\" title=\"通信数据转发程序 ：代理、网关、隧道\"></a>通信数据转发程序 ：代理、网关、隧道</h3><h4 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h4><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p>\n<p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/5cb86cda8dff1fbdc1eb32bde62d73c6.png\"></p>\n<p>每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息</p>\n<h5 id=\"代理方法\"><a href=\"#代理方法\" class=\"headerlink\" title=\"代理方法\"></a>代理方法</h5><p>1.缓存代理</p>\n<p>代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。再次收到相同的资源请求就会返回代理上缓存的资源。</p>\n<p>2.透明代理</p>\n<p>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。</p>\n<h4 id=\"网关\"><a href=\"#网关\" class=\"headerlink\" title=\"网关\"></a>网关</h4><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。</p>\n<p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。<br>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/1d46d1ae5f16e09805d3e87e506383c5.png\"></p>\n<h4 id=\"隧道\"><a href=\"#隧道\" class=\"headerlink\" title=\"隧道\"></a>隧道</h4><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p>\n<p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。<br>隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/1abf8e9495373ad8e481c44cd93d8968.png\"></p>\n<h3 id=\"保存资源的缓存\"><a href=\"#保存资源的缓存\" class=\"headerlink\" title=\"保存资源的缓存\"></a>保存资源的缓存</h3><p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</p>\n<h4 id=\"缓存的有效期限\"><a href=\"#缓存的有效期限\" class=\"headerlink\" title=\"缓存的有效期限\"></a>缓存的有效期限</h4><p>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。</p>\n<h4 id=\"客户端的缓存\"><a href=\"#客户端的缓存\" class=\"headerlink\" title=\"客户端的缓存\"></a>客户端的缓存</h4><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以Internet Explorer 程序为例，把客户端缓存称为临时网络文件（Temporary Internet File）。<br>浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。</p>\n<h3 id=\"HTTP-出现之前的协议\"><a href=\"#HTTP-出现之前的协议\" class=\"headerlink\" title=\"HTTP 出现之前的协议\"></a>HTTP 出现之前的协议</h3><ol>\n<li>FTP（File Transfer Protocol）<br>传输文件时使用的协议。</li>\n<li>NNTP（Network News Transfer Protocol）<br>用于 NetNews 电子会议室内传送消息的协议。。</li>\n<li>Archie<br>搜索 anonymous FTP 公开的文件信息的协议。</li>\n<li>WAIS（Wide Area Information Servers）<br>以关键词检索多个数据库使用的协议。</li>\n<li>Gopher<br>查找与互联网连接的计算机内信息的协议。</li>\n</ol>\n<h2 id=\"HTTP-首部\"><a href=\"#HTTP-首部\" class=\"headerlink\" title=\"HTTP 首部\"></a>HTTP 首部</h2><h3 id=\"HTTP-报文首部\"><a href=\"#HTTP-报文首部\" class=\"headerlink\" title=\"HTTP 报文首部\"></a>HTTP 报文首部</h3><p><img src=\"https://images.dadream.eu.org/images/2024/07/cdd775e3a5788d5f6b3083052c3eb339.png\"></p>\n<p>HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。</p>\n<h4 id=\"HTTP-请求报文\"><a href=\"#HTTP-请求报文\" class=\"headerlink\" title=\"HTTP 请求报文\"></a>HTTP 请求报文</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/34f0690cdfd988547a148806ba15ffb5.png\"></p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">GET</span> <span class=\"token request-target url\">/</span> <span class=\"token http-version property\">HTTP/1.1</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">hackr.jp</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">User-Agent</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html,application/xhtml+xml,application/xml;q=0.9,</span></span>\n*/*; q=0.8\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Language</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">ja,en-us;q=0.7,en;q=0.3</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Encoding</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">gzip, deflate</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">DNT</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">1</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Connection</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">keep-alive</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">If-Modified-Since</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Fri, 31 Aug 2007 02:02:20 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">If-None-Match</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">\"45bae1-16a-46d776ac\"</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Cache-Control</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">max-age=0</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"HTTP-响应报文\"><a href=\"#HTTP-响应报文\" class=\"headerlink\" title=\"HTTP 响应报文\"></a>HTTP 响应报文</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/d9a94837fa995200e34533dd7640b88c.png\"></p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">304</span> <span class=\"token reason-phrase string\">Not Modified</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Date</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Thu, 07 Jun 2012 07:21:36 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Server</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Apache</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Connection</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">close</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Etag</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">\"45bae1-16a-46d776ac\"</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"HTTP-首部字段\"><a href=\"#HTTP-首部字段\" class=\"headerlink\" title=\"HTTP 首部字段\"></a>HTTP 首部字段</h3><h4 id=\"HTTP-首部字段传递重要信息\"><a href=\"#HTTP-首部字段传递重要信息\" class=\"headerlink\" title=\"HTTP 首部字段传递重要信息\"></a>HTTP 首部字段传递重要信息</h4><h4 id=\"HTTP-首部字段结构\"><a href=\"#HTTP-首部字段结构\" class=\"headerlink\" title=\"HTTP 首部字段结构\"></a>HTTP 首部字段结构</h4><p>HTTP 首部字段是由首部字段名和字段值构成的</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">首部字段名: 字段值\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Keep-Alive</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">timeout=15, max=100</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>若 <strong>HTTP</strong> 首部字段重复了会如何</p>\n<p> 不同浏览器解析方式不同，有的是解析前面，有的则是解析后面的</p>\n<h4 id=\"4-种-HTTP-首部字段类型\"><a href=\"#4-种-HTTP-首部字段类型\" class=\"headerlink\" title=\"4 种 HTTP 首部字段类型\"></a><strong>4</strong> 种 <strong>HTTP</strong> 首部字段类型</h4><ol>\n<li>通用首部字段（<strong>General</strong> <strong>Header Fields</strong>）</li>\n</ol>\n<p>请求报文和响应报文两方都会使用的首部。</p>\n<ol start=\"2\">\n<li>请求首部字段（<strong>Request Header Fields</strong>）</li>\n</ol>\n<p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>\n<ol start=\"3\">\n<li>响应首部字段（<strong>Response Header Fields</strong>）</li>\n</ol>\n<p>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p>\n<ol start=\"4\">\n<li>实体首部字段（<strong>Entity Header Fields</strong>）</li>\n</ol>\n<p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息</p>\n<h4 id=\"HTTP-1-1-首部字段一览\"><a href=\"#HTTP-1-1-首部字段一览\" class=\"headerlink\" title=\"HTTP/1.1 首部字段一览\"></a>HTTP/1.1 首部字段一览</h4><p>RFC2616 中定义的 47 种首部字段</p>\n<h5 id=\"通用首部字段\"><a href=\"#通用首部字段\" class=\"headerlink\" title=\"通用首部字段\"></a>通用首部字段</h5><table>\n<thead>\n<tr>\n<th align=\"left\">首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Cache-Control</td>\n<td>控制缓存的行为</td>\n</tr>\n<tr>\n<td align=\"left\">Connection</td>\n<td>逐跳首部、连接的管理</td>\n</tr>\n<tr>\n<td align=\"left\">Date</td>\n<td>创建报文的日期时间</td>\n</tr>\n<tr>\n<td align=\"left\">Pragma</td>\n<td>报文指令</td>\n</tr>\n<tr>\n<td align=\"left\">Trailer</td>\n<td>报文末端的首部一览</td>\n</tr>\n<tr>\n<td align=\"left\">Transfer-Encoding</td>\n<td>指定报文主体的传输编码方式</td>\n</tr>\n<tr>\n<td align=\"left\">Upgrade</td>\n<td>升级为其他协议</td>\n</tr>\n<tr>\n<td align=\"left\">Via</td>\n<td>代理服务器的相关信息</td>\n</tr>\n<tr>\n<td align=\"left\">Warning</td>\n<td>错误通知</td>\n</tr>\n</tbody></table>\n<h5 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h5><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept</td>\n<td>用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>优先的内容编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>优先的语言（自然语言）</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Web认证信息</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待服务器的特定行为</td>\n</tr>\n<tr>\n<td>From</td>\n<td>用户的电子邮箱地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求资源所在服务器</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记（ETag）</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记（与 If-Match 相反）</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源未更新时发送实体 Byte 的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间（与If-Modified-Since相反）</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>最大传输逐跳数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证信息</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>对请求中 URI 的原始获取方</td>\n</tr>\n<tr>\n<td>TE</td>\n<td>传输编码的优先级</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>HTTP  客户端程序的信息</td>\n</tr>\n</tbody></table>\n<h5 id=\"响应首部字段\"><a href=\"#响应首部字段\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h5><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept-Ranges</td>\n<td>是否接受字节范围请求</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>推算资源创建经过时间</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>资源的匹配信息</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>令客户端重定向至指定URI</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>代理服务器对客户端的认证信息</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>对再次发起请求的时机要求</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>HTTP服务器的安装信息</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>代理服务器缓存的管理信息</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>服务器对客户端的认证信息</td>\n</tr>\n</tbody></table>\n<h5 id=\"实体首部字段\"><a href=\"#实体首部字段\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h5><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Allow</td>\n<td>资源可支持的HTTP方法</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>实体主体适用的编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>实体主体的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>实体主体的大小（单位：字节）</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>替代对应资源的URI</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>实体主体的报文摘要</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>实体主体的位置范围</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>实体主体的媒体类型</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体主体过期的日期时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>资源的最后修改日期时间</td>\n</tr>\n</tbody></table>\n<h4 id=\"非-HTTP-1-1-首部字段\"><a href=\"#非-HTTP-1-1-首部字段\" class=\"headerlink\" title=\"非 HTTP/1.1 首部字段\"></a>非 <strong>HTTP/1.1</strong> 首部字段</h4><p>RFC4229</p>\n<p>Cookie、Set-Cookie 和 Content-Disposition 等</p>\n<h4 id=\"End-to-end-首部和-Hop-by-hop-首部\"><a href=\"#End-to-end-首部和-Hop-by-hop-首部\" class=\"headerlink\" title=\"End-to-end 首部和 Hop-by-hop 首部\"></a><strong>End-to-end</strong> 首部和 <strong>Hop-by-hop</strong> 首部</h4><h5 id=\"端到端首部（End-to-end-Header）\"><a href=\"#端到端首部（End-to-end-Header）\" class=\"headerlink\" title=\"端到端首部（End-to-end Header）\"></a>端到端首部（<strong>End-to-end Header</strong>）</h5><p>分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p>\n<h5 id=\"逐跳首部（Hop-by-hop-Header）\"><a href=\"#逐跳首部（Hop-by-hop-Header）\" class=\"headerlink\" title=\"逐跳首部（Hop-by-hop Header）\"></a>逐跳首部（<strong>Hop-by-hop Header</strong>）</h5><p>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。</p>\n<p>除了一下8种其他全是端到端首部</p>\n<table>\n<thead>\n<tr>\n<th>Connection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Keep-Alive</td>\n</tr>\n<tr>\n<td><strong>Proxy-Authenticate</strong></td>\n</tr>\n<tr>\n<td><strong>Proxy-Authorization</strong></td>\n</tr>\n<tr>\n<td><strong>Trailer</strong></td>\n</tr>\n<tr>\n<td>TE</td>\n</tr>\n<tr>\n<td><strong>Transfer-Encoding</strong></td>\n</tr>\n<tr>\n<td><strong>Upgrade</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"HTTP-1-1-通用首部字段\"><a href=\"#HTTP-1-1-通用首部字段\" class=\"headerlink\" title=\"HTTP/1.1 通用首部字段\"></a><strong>HTTP/1.1</strong> 通用首部字段</h3><p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a><strong>Cache-Control</strong></h4><p>首部字段 <strong>Cache-Control</strong> 能够控制缓存的行为</p>\n<p>写法<code>Cache-Control: private, max-age=0, no-cache</code></p>\n<h5 id=\"缓存请求指令\"><a href=\"#缓存请求指令\" class=\"headerlink\" title=\"缓存请求指令\"></a>缓存请求指令</h5><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>no-cache</td>\n<td>无</td>\n<td>强制向源服务器再次验证</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>无</td>\n<td>不缓存请求或响应的任何内容</td>\n</tr>\n<tr>\n<td>max-age  = [ 秒]</td>\n<td>必需</td>\n<td>响应的最大Age值</td>\n</tr>\n<tr>\n<td>max-stale( = [ 秒])</td>\n<td>可省略</td>\n<td>接收已过期的响应</td>\n</tr>\n<tr>\n<td>min-fresh  = [ 秒]</td>\n<td>必需</td>\n<td>期望在指定时间内的响应仍有效</td>\n</tr>\n<tr>\n<td>no-transform</td>\n<td>无</td>\n<td>代理不可更改媒体类型</td>\n</tr>\n<tr>\n<td>only-if-cached</td>\n<td>无</td>\n<td>从缓存获取资源</td>\n</tr>\n<tr>\n<td>cache-extension</td>\n<td>-</td>\n<td>新指令标记（token）</td>\n</tr>\n</tbody></table>\n<h5 id=\"缓存响应指令\"><a href=\"#缓存响应指令\" class=\"headerlink\" title=\"缓存响应指令\"></a>缓存响应指令</h5><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td>无</td>\n<td>可向任意方提供响应的缓存</td>\n</tr>\n<tr>\n<td>private</td>\n<td>可省略</td>\n<td>仅向特定用户返回响应</td>\n</tr>\n<tr>\n<td>no-cache</td>\n<td>可省略</td>\n<td>缓存前必须先确认其有效性</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>无</td>\n<td>不缓存请求或响应的任何内容</td>\n</tr>\n<tr>\n<td>no-transform</td>\n<td>无</td>\n<td>代理不可更改媒体类型</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td>无</td>\n<td>可缓存但必须再向源服务器进行确认</td>\n</tr>\n<tr>\n<td>proxy-revalidate</td>\n<td>无</td>\n<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>\n</tr>\n<tr>\n<td>max-age = [ 秒]</td>\n<td>必需</td>\n<td>响应的最大Age值</td>\n</tr>\n<tr>\n<td>s-maxage  = [ 秒]</td>\n<td>必需</td>\n<td>公共缓存服务器响应的最大Age值</td>\n</tr>\n<tr>\n<td>cache-extension</td>\n<td>-</td>\n<td>新指令标记（token）</td>\n</tr>\n</tbody></table>\n<h5 id=\"表示是否能缓存的指令\"><a href=\"#表示是否能缓存的指令\" class=\"headerlink\" title=\"表示是否能缓存的指令\"></a>表示是否能缓存的指令</h5><ul>\n<li><p><code>Cache-Control: public</code></p>\n<p>当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</p>\n</li>\n<li><p><code>Cache-Control: private</code></p>\n<p>当指定 private 指令后，响应只以特定的用户作为对象，这与 public指令的行为相反。</p>\n<p>缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p>\n</li>\n<li><p><code>Cache-Control: no-cache</code></p>\n<p>使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 </p>\n<p>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。中间缓存服务器不缓存，相当于隧道不对报文做文章。</p>\n</li>\n</ul>\n<ul>\n<li><p><code>Cache-Control: no-cache=Location</code></p>\n<p>由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p>\n</li>\n</ul>\n<h5 id=\"控制可执行缓存的对象的指令\"><a href=\"#控制可执行缓存的对象的指令\" class=\"headerlink\" title=\"控制可执行缓存的对象的指令\"></a>控制可执行缓存的对象的指令</h5><ul>\n<li><p><code>Cache-Control: no-store</code></p>\n<p>当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。</p>\n<p>该指令规定缓存不能在本地存储请求或响应的任一部分。</p>\n</li>\n</ul>\n<h5 id=\"指定缓存期限和认证的指令\"><a href=\"#指定缓存期限和认证的指令\" class=\"headerlink\" title=\"指定缓存期限和认证的指令\"></a>指定缓存期限和认证的指令</h5><ul>\n<li><p><code>Cache-Control: s-maxage=604800（单位 ：秒）</code></p>\n<p>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s- maxage 指令只适用于供多位用户使用的公共缓存服务器 。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。</p>\n<p>当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及max-age 指令的处理。</p>\n</li>\n<li><p><code>Cache-Control: max-age=604800（单位：秒）</code></p>\n<p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。</p>\n<p>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。</p>\n<p>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉。</p>\n</li>\n<li><p><code>Cache-Control: min-fresh=60（单位：秒）</code></p>\n<p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p>\n</li>\n<li><p><code>Cache-Control: max-stale=3600（单位：秒）</code></p>\n<p>使用 max-stale 可指示缓存资源，即使过期也照常接收。</p>\n<p>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应； 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</p>\n</li>\n<li><p><code>Cache-Control: only-if-cached</code></p>\n<p>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。</p>\n</li>\n<li><p><code>Cache-Control: must-revalidate</code></p>\n<p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。</p>\n<p>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条 504（Gateway Timeout）状态码。</p>\n<p>另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。</p>\n</li>\n<li><p><code>Cache-Control: proxy-revalidate</code></p>\n<p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p>\n</li>\n<li><p><code>Cache-Control: no-transform</code></p>\n<p>使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。</p>\n<p>这样做可防止缓存或代理压缩图片等类似操作。</p>\n</li>\n</ul>\n<h5 id=\"Cache-Control-扩展\"><a href=\"#Cache-Control-扩展\" class=\"headerlink\" title=\"Cache-Control 扩展\"></a>Cache-Control 扩展</h5><p><code>Cache-Control: private, community=\"UCI\"</code></p>\n<p>通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。</p>\n<p>如上例，Cache-Control 首部字段本身没有 community 这个指令。借助extension tokens 实现了该指令的添加。如果缓存服务器不能理解community 这个新指令，就会直接忽略。因此，extension tokens 仅对能理解它的缓存服务器来说是有意义的。</p>\n<h4 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h4><h5 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h5><ul>\n<li><p>控制不再转发给代理的首部字段<code>Connection: 不再转发的首部字段名</code></p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/f6aa486e881b027e5f4c0eae92b1bf92.png\"></p>\n</li>\n<li><p>管理持久连接</p>\n<p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定Connection 首部字段的值为 Keep-Alive。<code>Connection: Keep-Alive</code></p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/fa4c471298769a15944259a15361652e.png\"></p>\n<p>HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection 首部字段的值为 Close。<code>Connection: close</code></p>\n</li>\n</ul>\n<h4 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h4><p>首部字段 Date 表明创建 HTTP 报文的日期和时间。</p>\n<ul>\n<li><p>HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式</p>\n<p><code>Date: Tue, 03 Jul 2012 04:40:59 GMT</code></p>\n</li>\n<li><p>之前的 HTTP 协议版本中使用在 RFC850 中定义的格式</p>\n<p><code>Date: Tue, 03-Jul-12 04:40:59 GMT</code></p>\n</li>\n<li><p>C 标准库内的 asctime() 函数的输出格式</p>\n<p><code>Date: Tue Jul 03 04:40:59 2012</code></p>\n</li>\n</ul>\n<h4 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h4><p>Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义。相当于HTTP/1.1之后Cache-Control</p>\n<p><code>Pragma: no-cache</code></p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Cache-Control</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">no-cache </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Pragma</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">no-cache</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>通常一起用，因为你不能掌握全部中间服务器</p>\n<h4 id=\"Trailer\"><a href=\"#Trailer\" class=\"headerlink\" title=\"Trailer\"></a>Trailer</h4><p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Date</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Tue, 03 Jul 2012 04:40:56 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html</span></span>\n<span class=\"token text-html\">...\nTransfer-Encoding: chunked\nTrailer: Expires\n\n...(报文主体)... 0\nExpires: Tue, 28 Sep 2004 23:59:59 GMT</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。</p>\n<h4 id=\"Transfer-Encoding\"><a href=\"#Transfer-Encoding\" class=\"headerlink\" title=\"Transfer-Encoding\"></a>Transfer-Encoding</h4><p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。</p>\n<p>HTTP/1.1 的传输编码方式仅对分块传输编码有效。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Date</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Tue, 03 Jul 2012 04:40:56 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Cache-Control</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">public, max-age=604800 </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/javascript; charset=utf-8 </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Expires</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Tue, 10 Jul 2012 04:40:56 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">X-Frame-Options</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">DENY</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">X-XSS-Protection</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">1; mode=block </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Encoding</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">gzip </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Transfer-Encoding</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">chunked </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Connection</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">keep-alive</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"Upgrade\"><a href=\"#Upgrade\" class=\"headerlink\" title=\"Upgrade\"></a>Upgrade</h4><p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/c345255e4e1f7c71755193f3e9157b21.png\"></p>\n<p>上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还需要额外指定Connection:Upgrade。</p>\n<p>对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。</p>\n<h4 id=\"Via\"><a href=\"#Via\" class=\"headerlink\" title=\"Via\"></a>Via</h4><p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/eb53ad7d905d8029eca3b989b9348508.png\"></p>\n<p>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。</p>\n<p>1.0是指代理服务器的HTTP版本</p>\n<h4 id=\"Warning\"><a href=\"#Warning\" class=\"headerlink\" title=\"Warning\"></a>Warning</h4><p>HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Warning</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">[警告码][警告的主机:端口号]“[警告内容]”([日期时间])</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Warning</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">113 gw.hackr.jp:8080 \"Heuristic expiration\" Tue, 03</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h5 id=\"HTTP-1-1-警告码\"><a href=\"#HTTP-1-1-警告码\" class=\"headerlink\" title=\"HTTP/1.1 警告码\"></a><strong>HTTP/1.1</strong> 警告码</h5><table>\n<thead>\n<tr>\n<th>警告码</th>\n<th>警告内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>110</td>\n<td>Response  is stale（响应已过期）</td>\n<td>代理返回已过期的资源</td>\n</tr>\n<tr>\n<td>111</td>\n<td>Revalidation  failed（再验证失败）</td>\n<td>代理再验证资源有效性时失败（服务器无法到达等原因）</td>\n</tr>\n<tr>\n<td>112</td>\n<td>Disconnection operation（断开连接操作）</td>\n<td>代理与互联网连接被故意切断</td>\n</tr>\n<tr>\n<td>113</td>\n<td>Heuristic  expiration（试探性过期）</td>\n<td>响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</td>\n</tr>\n<tr>\n<td>199</td>\n<td>Miscellaneous  warning（杂项警告）</td>\n<td>任意的警告内容</td>\n</tr>\n<tr>\n<td>214</td>\n<td>Transformation  applied（使用了转换）</td>\n<td>代理对内容编码或媒体类型等执行了某些处理时</td>\n</tr>\n<tr>\n<td>299</td>\n<td>Miscellaneous persistent  warning（持久杂项警告）</td>\n<td>任意的警告内容</td>\n</tr>\n</tbody></table>\n<h3 id=\"请求首部字段-1\"><a href=\"#请求首部字段-1\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段， 用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p>\n<h4 id=\"Accept\"><a href=\"#Accept\" class=\"headerlink\" title=\"Accept\"></a>Accept</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/28a3ddf597307b46dbfd4f5fcaa59bc6.png\"></p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html,application/xhtml+xml,application/xml;q=0.1</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><p>文本文件</p>\n<p>text/html, text/plain, text/css … </p>\n<p>application/xhtml+xml, application/xml …</p>\n</li>\n<li><p>图片文件</p>\n<p>image/jpeg, image/gif, image/png …</p>\n</li>\n<li><p>视频文件</p>\n<p>video/mpeg, video/quicktime …</p>\n</li>\n<li><p>应用程序使用的二进制文件</p>\n<p>application/octet-stream, application/zip …</p>\n</li>\n</ul>\n<p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。</p>\n<p>若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值1，用分（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。</p>\n<h4 id=\"Accept-Charset\"><a href=\"#Accept-Charset\" class=\"headerlink\" title=\"Accept-Charset\"></a>Accept-Charset</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/c4e11a52cebd529f557a2167802d9ffc.png\"></p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Accept-Charset</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">iso-8859-5, unicode-1-1;q=0.8</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"Accept-Encoding\"><a href=\"#Accept-Encoding\" class=\"headerlink\" title=\"Accept-Encoding\"></a>Accept-Encoding</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Accept-Encoding</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">gzip, deflate</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。</p>\n<ul>\n<li>gzip</li>\n<li>compress</li>\n<li>deflate</li>\n<li>identity</li>\n</ul>\n<p>也能使用权重q，使用<code>*</code>作为通配符</p>\n<h4 id=\"Accept-Language\"><a href=\"#Accept-Language\" class=\"headerlink\" title=\"Accept-Language\"></a>Accept-Language</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Accept-Language</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">zh-cn,zh;q=0.7,en-us,en;q=0.3</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。</p>\n<h4 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/b03ee40399dfa19fd529932d4b425bf2.png\"></p>\n<p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p>\n<h4 id=\"Expect\"><a href=\"#Expect\" class=\"headerlink\" title=\"Expect\"></a>Expect</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/505b2dc20140f2229009f7b1d50c6003.png\"></p>\n<p>客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。</p>\n<p>客户端可以利用该首部字段，写明所期望的扩展。</p>\n<h4 id=\"From\"><a href=\"#From\" class=\"headerlink\" title=\"From\"></a>From</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/7eab6c8381ea2f0dfc218ee7b8bd0917.png\"></p>\n<p>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。</p>\n<h4 id=\"Host\"><a href=\"#Host\" class=\"headerlink\" title=\"Host\"></a>Host</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">www.hackr.jp</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。</p>\n<p>虚拟主机运行在同一个 <strong>IP</strong> 上，因此使用首部字段 <strong>Host</strong> 加以区分</p>\n<p>若服务器未设定主机名，那直接发送一个空值即可。</p>\n<h4 id=\"If-XXX\"><a href=\"#If-XXX\" class=\"headerlink\" title=\"If-XXX\"></a>If-XXX</h4><p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/882524fadb21c8271d082b988d4bc4fe.png\"></p>\n<h4 id=\"If-Match\"><a href=\"#If-Match\" class=\"headerlink\" title=\"If-Match\"></a>If-Match</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">If-Match</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">\"123456\"</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。</p>\n<p>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。</p>\n<p>通配符<code>*</code>跳过匹配</p>\n<h4 id=\"If-Modified-Since\"><a href=\"#If-Modified-Since\" class=\"headerlink\" title=\"If-Modified-Since\"></a>If-Modified-Since</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">If-Modified-Since</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Thu, 15 Apr 2004 00:00:00 GMT</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If- Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。</p>\n<p>If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。</p>\n<h4 id=\"If-None-Match\"><a href=\"#If-None-Match\" class=\"headerlink\" title=\"If-None-Match\"></a>If-None-Match</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/7443e192d3075d7a42155c0632ce4c06.png\"></p>\n<p>它和首部字段 If-Match 作用相反。</p>\n<p>在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。</p>\n<h4 id=\"If-Range\"><a href=\"#If-Range\" class=\"headerlink\" title=\"If-Range\"></a>If-Range</h4><p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If- Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/9e0a6505cd35db6f7beb949d933106cc.png\"></p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/d82cef8fcce80a19ce1cbcbc522d76b8.png\"></p>\n<h4 id=\"If-Unmodified-Since\"><a href=\"#If-Unmodified-Since\" class=\"headerlink\" title=\"If-Unmodified-Since\"></a>If-Unmodified-Since</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">If-Unmodified-Since</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Thu, 03 Jul 2012 00:00:00 GMT</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</p>\n<h4 id=\"Max-Forwards\"><a href=\"#Max-Forwards\" class=\"headerlink\" title=\"Max-Forwards\"></a>Max-Forwards</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/58c2400eb309d5ef98d5a565925de4b3.png\"></p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Max-Forwards</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">10</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>每次转发数值减 <strong>1</strong>。当数值变 <strong>0</strong> 时返回响应</p>\n<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max- Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。</p>\n<h4 id=\"Proxy-Authorization\"><a href=\"#Proxy-Authorization\" class=\"headerlink\" title=\"Proxy-Authorization\"></a>Proxy-Authorization</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Proxy-Authorization</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Basic dGlwOjkpNLAGfFY5</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</p>\n<h4 id=\"Range\"><a href=\"#Range\" class=\"headerlink\" title=\"Range\"></a>Range</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Range</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">bytes=5001-10000</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第10000 字节的资源。</p>\n<p>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。</p>\n<h4 id=\"Referer\"><a href=\"#Referer\" class=\"headerlink\" title=\"Referer\"></a>Referer</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Referer</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">http://www.hackr.jp/index.htm</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Referer 会告知服务器请求的原始资源的 URI。</p>\n<h4 id=\"TE\"><a href=\"#TE\" class=\"headerlink\" title=\"TE\"></a>TE</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">TE</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">gzip, deflate;q=0.5</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。</p>\n<p>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">TE</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">trailers</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"User-Agent\"><a href=\"#User-Agent\" class=\"headerlink\" title=\"User-Agent\"></a>User-Agent</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">User-Agent</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gec</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>\n<h3 id=\"响应首部字段-1\"><a href=\"#响应首部字段-1\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h3><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段， 用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p>\n<h4 id=\"Accept-Ranges\"><a href=\"#Accept-Ranges\" class=\"headerlink\" title=\"Accept-Ranges\"></a>Accept-Ranges</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Accept-Ranges</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">bytes</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</p>\n<p>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</p>\n<h4 id=\"Age\"><a href=\"#Age\" class=\"headerlink\" title=\"Age\"></a>Age</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Age</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">600</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</p>\n<p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age。</p>\n<h4 id=\"ETag\"><a href=\"#ETag\" class=\"headerlink\" title=\"ETag\"></a>ETag</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">ETag</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">\"82e22293907ce725faf67773957acd12\"</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/0e9a820ce5a8a8b4b440975ba2efbed4.png\"></p>\n<p>仅仅是由服务器来分配。</p>\n<h5 id=\"强-ETag-值\"><a href=\"#强-ETag-值\" class=\"headerlink\" title=\"强 ETag 值\"></a>强 <strong>ETag</strong> 值</h5><p>强 ETag 值，不论实体发生多么细微的变化都会改变其值。</p>\n<p><code>ETag: \"usagi-1234\"</code></p>\n<h5 id=\"弱-ETag-值\"><a href=\"#弱-ETag-值\" class=\"headerlink\" title=\"弱 ETag 值\"></a>弱 <strong>ETag</strong> 值</h5><p>弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。</p>\n<p><code>ETag: W/\"usagi-1234\"</code></p>\n<h4 id=\"Location\"><a href=\"#Location\" class=\"headerlink\" title=\"Location\"></a>Location</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/d427319a2e408e1a28ec464f7a19eb32.png\"></p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Location</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">http://www.usagidesign.jp/sample.html</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</p>\n<p>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。</p>\n<h4 id=\"Proxy-Authenticate\"><a href=\"#Proxy-Authenticate\" class=\"headerlink\" title=\"Proxy-Authenticate\"></a>Proxy-Authenticate</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Proxy-Authenticate</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Basic realm=\"Usagidesign Auth\"</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。</p>\n<h4 id=\"Retry-After\"><a href=\"#Retry-After\" class=\"headerlink\" title=\"Retry-After\"></a>Retry-After</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Retry-After</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">120</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。</p>\n<p>字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。</p>\n<h4 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Server</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Apache/2.2.6 (Unix) PHP/5.2.5</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p>\n<h4 id=\"Vary\"><a href=\"#Vary\" class=\"headerlink\" title=\"Vary\"></a>Vary</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Vary</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Accept-Language</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</p>\n<h4 id=\"WWW-Authenticate\"><a href=\"#WWW-Authenticate\" class=\"headerlink\" title=\"WWW-Authenticate\"></a>WWW-Authenticate</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">WWW-Authenticate</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Basic realm=\"Usagidesign Auth\"</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。</p>\n<h3 id=\"实体首部字段-1\"><a href=\"#实体首部字段-1\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h3><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p>\n<h4 id=\"Alow\"><a href=\"#Alow\" class=\"headerlink\" title=\"Alow\"></a>Alow</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Allow</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">GET, HEAD</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</p>\n<h4 id=\"Content-Encoding\"><a href=\"#Content-Encoding\" class=\"headerlink\" title=\"Content-Encoding\"></a>Content-Encoding</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Content-Encoding</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">gzip</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p>\n<ul>\n<li>gzip</li>\n<li>compress</li>\n<li>deflate</li>\n<li>identity</li>\n</ul>\n<h4 id=\"Content-Languag\"><a href=\"#Content-Languag\" class=\"headerlink\" title=\"Content-Languag\"></a>Content-Languag</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Content-Language</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">zh-CN</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p>\n<h4 id=\"Content-Length\"><a href=\"#Content-Length\" class=\"headerlink\" title=\"Content-Length\"></a>Content-Length</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Content-Length</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">15000</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Content-Length 表明了实体主体的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。</p>\n<h4 id=\"Content-Location\"><a href=\"#Content-Location\" class=\"headerlink\" title=\"Content-Location\"></a>Content-Location</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Content-Location</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">http://www.hackr.jp/index-ja.html</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p>\n<p>比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段 Content-Location 内会写明 URI。</p>\n<h4 id=\"Content-MD5\"><a href=\"#Content-MD5\" class=\"headerlink\" title=\"Content-MD5\"></a>Content-MD5</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Content-MD5</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/cae670c7d7ca3bf6ff620ed7cf4fafe2.png\"></p>\n<p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>\n<p>对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。</p>\n<h4 id=\"Content-Range\"><a href=\"#Content-Range\" class=\"headerlink\" title=\"Content-Range\"></a>Content-Range</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Content-Range</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">bytes 5001-10000/10000</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p>\n<h4 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html; charset=UTF-8</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。</p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Expires</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Wed, 04 Jul 2012 08:26:05 GMT</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</p>\n<p>当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。</p>\n<h4 id=\"Last-Modified\"><a href=\"#Last-Modified\" class=\"headerlink\" title=\"Last-Modified\"></a>Last-Modified</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Last-Modified</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Wed, 23 May 2012 09:59:55 GMT</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p>\n<h3 id=\"为-Cookie-服务的首部字段\"><a href=\"#为-Cookie-服务的首部字段\" class=\"headerlink\" title=\"为 Cookie 服务的首部字段\"></a>为 <strong>Cookie</strong> 服务的首部字段</h3><p>Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie。</p>\n<p>调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他Web 站点和攻击者的攻击而泄露。</p>\n<h4 id=\"Cookie-的规格标准文档\"><a href=\"#Cookie-的规格标准文档\" class=\"headerlink\" title=\"Cookie 的规格标准文档\"></a>Cookie 的规格标准文档</h4><ul>\n<li><h6 id=\"RFC2109\"><a href=\"#RFC2109\" class=\"headerlink\" title=\"RFC2109\"></a>RFC2109</h6></li>\n<li><h6 id=\"RFC2965\"><a href=\"#RFC2965\" class=\"headerlink\" title=\"RFC2965\"></a>RFC2965</h6></li>\n<li><h6 id=\"RFC6265\"><a href=\"#RFC6265\" class=\"headerlink\" title=\"RFC6265\"></a>RFC6265</h6></li>\n<li><p>由网景公司颁布的规格标准</p>\n</li>\n</ul>\n<h4 id=\"Cookie-服务的首部字段\"><a href=\"#Cookie-服务的首部字段\" class=\"headerlink\" title=\"Cookie 服务的首部字段\"></a><strong>Cookie</strong> 服务的首部字段</h4><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n<th>首部类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Set-Cookie</td>\n<td>开始状态管理所使用的Cookie信息</td>\n<td>响应首部字段</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>服务器接收到的Cookie信息</td>\n<td>请求首部字段</td>\n</tr>\n</tbody></table>\n<h4 id=\"Set-Cookie\"><a href=\"#Set-Cookie\" class=\"headerlink\" title=\"Set-Cookie\"></a>Set-Cookie</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Set-Cookie</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">status=enable; expires=Tue, 05 Jul 2011 07:26:31</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><strong>Set-Cookie</strong> 字段的属性</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NAME=VALUE</td>\n<td>赋予 Cookie 的名称和其值（必需项）</td>\n</tr>\n<tr>\n<td>expires=DATE</td>\n<td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>\n</tr>\n<tr>\n<td>path=PATH</td>\n<td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>\n</tr>\n<tr>\n<td>domain=域名</td>\n<td>作为 Cookie 适用对象的域名  （若不指定则默认为创建 Cookie  的服务器的域名）</td>\n</tr>\n<tr>\n<td>Secure</td>\n<td>仅在 HTTPS 安全通信时才会发送  Cookie</td>\n</tr>\n<tr>\n<td>HttpOnly</td>\n<td>加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>\n</tr>\n</tbody></table>\n<h6 id=\"expires-属性\"><a href=\"#expires-属性\" class=\"headerlink\" title=\"expires 属性\"></a>expires 属性</h6><p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。</p>\n<p>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session） 时间段内。这通常限于浏览器应用程序被关闭之前。</p>\n<p>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</p>\n<h5 id=\"path-属性\"><a href=\"#path-属性\" class=\"headerlink\" title=\"path 属性\"></a><strong>path</strong> 属性</h5><p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。</p>\n<h5 id=\"domain-属性\"><a href=\"#domain-属性\" class=\"headerlink\" title=\"domain 属性\"></a><strong>domain</strong> 属性</h5><p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除 example.com 以外，<a href=\"http://www.example.com/\">www.example.com </a>或www2.example.com 等都可以发送 Cookie。</p>\n<p>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定domain 属性显得更安全</p>\n<h5 id=\"secure-属性\"><a href=\"#secure-属性\" class=\"headerlink\" title=\"secure 属性\"></a><strong>secure</strong> 属性</h5><p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Set-Cookie</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">name=value; secure</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h6 id=\"HttpOnly-属性\"><a href=\"#HttpOnly-属性\" class=\"headerlink\" title=\"HttpOnly 属性\"></a>HttpOnly 属性</h6><p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Set-Cookie</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">name=value; HttpOnly</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Cookie</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">status=enable</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。</p>\n<h3 id=\"其他首部字段\"><a href=\"#其他首部字段\" class=\"headerlink\" title=\"其他首部字段\"></a>其他首部字段</h3><p>HTTP 首部字段是可以自行扩展的。</p>\n<table>\n<thead>\n<tr>\n<th>X-Frame-Options</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>X-XSS-Protection</td>\n</tr>\n<tr>\n<td>DNT</td>\n</tr>\n<tr>\n<td>P3P</td>\n</tr>\n</tbody></table>\n<h4 id=\"X-Frame-Options\"><a href=\"#X-Frame-Options\" class=\"headerlink\" title=\"X-Frame-Options\"></a>X-Frame-Options</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">X-Frame-Options</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">DENY</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p>\n<h5 id=\"字段\"><a href=\"#字段\" class=\"headerlink\" title=\"字段\"></a>字段</h5><ul>\n<li><strong>DENY</strong> ：拒绝</li>\n<li><strong>SAMEORIGIN</strong> ：仅同源域名下的页面（Top-level-browsing- context）匹配时许可。（比如，当指定 <a href=\"http://hackr.jp/sample.html\">http://hackr.jp/sample.html </a>页面为 SAMEORIGIN 时，那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了）</li>\n</ul>\n<h5 id=\"apache2-conf-的配置实例\"><a href=\"#apache2-conf-的配置实例\" class=\"headerlink\" title=\"apache2.conf 的配置实例\"></a><strong>apache2.conf</strong> 的配置实例</h5><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">&lt;IfModule mod_headers.c&gt;\nHeader append X-FRAME-OPTIONS \"SAMEORIGIN\"\n&lt;/IfModule&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"X-XSS-Protection\"><a href=\"#X-XSS-Protection\" class=\"headerlink\" title=\"X-XSS-Protection\"></a>X-XSS-Protection</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">X-XSS-Protection</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">1</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。</p>\n<ul>\n<li>0：将 XSS 过滤设置成无效状态</li>\n<li>1：将 XSS 过滤设置成有效状态</li>\n</ul>\n<h4 id=\"DNT\"><a href=\"#DNT\" class=\"headerlink\" title=\"DNT\"></a>DNT</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">DNT</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">1</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。</p>\n<ul>\n<li>0：同意被追踪</li>\n<li>1：拒绝被追踪</li>\n</ul>\n<h4 id=\"P3P\"><a href=\"#P3P\" class=\"headerlink\" title=\"P3P\"></a>P3P</h4><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">P3P</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">CP=\"CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p>\n<p>要进行 P3P 的设定，需按以下操作步骤进行。</p>\n<p>步骤 <strong>1</strong>：创建 P3P 隐私</p>\n<p>步骤 <strong>2</strong>：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</p>\n<p>步骤 <strong>3</strong>：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</p>\n<h2 id=\"确保-Web-安全的HTTPS\"><a href=\"#确保-Web-安全的HTTPS\" class=\"headerlink\" title=\"确保 Web 安全的HTTPS\"></a>确保 <strong>Web</strong> 安全的HTTPS</h2><p>在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS 通信机制可以有效地防止这些问题。</p>\n<h3 id=\"HTTP的缺点\"><a href=\"#HTTP的缺点\" class=\"headerlink\" title=\"HTTP的缺点\"></a>HTTP的缺点</h3><ul>\n<li><p>通信使用明文（不加密），内容可能会被窃听</p>\n</li>\n<li><p>不验证通信方的身份，因此有可能遭遇伪装</p>\n</li>\n<li><p>无法证明报文的完整性，所以有可能已遭篡改</p>\n</li>\n</ul>\n<h4 id=\"通信使用明文（不加密），内容可能会被窃听\"><a href=\"#通信使用明文（不加密），内容可能会被窃听\" class=\"headerlink\" title=\"通信使用明文（不加密），内容可能会被窃听\"></a>通信使用明文（不加密），内容可能会被窃听</h4><p>由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送。</p>\n<ul>\n<li><p><strong>TCP/IP</strong> 是可能被窃听的网络</p>\n<p>互联网上的任何角落都存在通信内容被窃听的风险</p>\n<p>即使加密的处理过的通信任会被监听，只是监听者还需要破解报文信息</p>\n</li>\n<li><p>加密处理防止被窃听</p>\n<ul>\n<li><p>通信的加密</p>\n<p>HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用， 加密 HTTP 的通信内容。</p>\n</li>\n<li><p>内容的加密</p>\n<p>HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用， 加密 HTTP 的通信内容。</p>\n<p>把HTTP 报文里所含的内容进行加密处理。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/ebf75f3e4a4d5757e3628065a63e4971.png\"></p>\n<h4 id=\"不验证通信方的身份就可能遭遇伪装\"><a href=\"#不验证通信方的身份就可能遭遇伪装\" class=\"headerlink\" title=\"不验证通信方的身份就可能遭遇伪装\"></a>不验证通信方的身份就可能遭遇伪装</h4><p>HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。</p>\n<h5 id=\"任何人都可发起请求\"><a href=\"#任何人都可发起请求\" class=\"headerlink\" title=\"任何人都可发起请求\"></a>任何人都可发起请求</h5><p>HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应。</p>\n<ul>\n<li>无法判断发出的请求是否到达理想服务器，伪装服务器</li>\n<li>无法判断响应是理想客服端发来的，伪造客服端</li>\n<li>无法判断对方是否具有访问权限</li>\n<li>无法判断是否会发给理想客户端</li>\n</ul>\n<h5 id=\"查明对手的证书\"><a href=\"#查明对手的证书\" class=\"headerlink\" title=\"查明对手的证书\"></a>查明对手的证书</h5><p>虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段， 可用于确定方。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/5b8c38026530678e13e723170dad0f13.png\"></p>\n<h4 id=\"无法证明报文完整性，可能已遭篡改\"><a href=\"#无法证明报文完整性，可能已遭篡改\" class=\"headerlink\" title=\"无法证明报文完整性，可能已遭篡改\"></a>无法证明报文完整性，可能已遭篡改</h4><p>所谓完整性是指信息的准确度。</p>\n<h5 id=\"接收到的内容可能有误\"><a href=\"#接收到的内容可能有误\" class=\"headerlink\" title=\"接收到的内容可能有误\"></a>接收到的内容可能有误</h5><p>在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/6b6927be25adafe4f71d33db42272962.png\"></p>\n<h5 id=\"如何防止篡改\"><a href=\"#如何防止篡改\" class=\"headerlink\" title=\"如何防止篡改\"></a>如何防止篡改</h5><p>其中常用的是 MD5 和 SHA-1 等散列值校验的方法， 以及用来确认文件的数字签名方法。这些算法也会被改写。</p>\n<h3 id=\"HTTP-加密-认证-完整性保护-HTTPS\"><a href=\"#HTTP-加密-认证-完整性保护-HTTPS\" class=\"headerlink\" title=\"HTTP+ 加密 + 认证 + 完整性保护**=HTTPS**\"></a><strong>HTTP+</strong> 加密 <strong>+</strong> 认证 <strong>+</strong> 完整性保护**=HTTPS**</h3><h4 id=\"HTTP-加上加密处理和认证以及完整性保护后即是HTTPS\"><a href=\"#HTTP-加上加密处理和认证以及完整性保护后即是HTTPS\" class=\"headerlink\" title=\"HTTP 加上加密处理和认证以及完整性保护后即是HTTPS\"></a><strong>HTTP</strong> 加上加密处理和认证以及完整性保护后即是HTTPS</h4><p>把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/e837127d056258e30e3e134a207e6791.png\"></p>\n<h4 id=\"HTTPS-是身披-SSL-外壳的-HTTP\"><a href=\"#HTTPS-是身披-SSL-外壳的-HTTP\" class=\"headerlink\" title=\"HTTPS 是身披 SSL 外壳的 HTTP\"></a><strong>HTTPS</strong> 是身披 <strong>SSL</strong> 外壳的 <strong>HTTP</strong></h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/140c9e47c4065dfc522e3e412df99331.png\"></p>\n<h4 id=\"相互交换密钥的公开密钥加密技术\"><a href=\"#相互交换密钥的公开密钥加密技术\" class=\"headerlink\" title=\"相互交换密钥的公开密钥加密技术\"></a>相互交换密钥的公开密钥加密技术</h4><p>SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p>\n<ul>\n<li>共享密钥加密的困境</li>\n<li>使用两把密钥的公开密钥加密</li>\n<li><strong>HTTPS</strong> 采用混合加密机制</li>\n</ul>\n<h4 id=\"证明公开密钥正确性的证书\"><a href=\"#证明公开密钥正确性的证书\" class=\"headerlink\" title=\"证明公开密钥正确性的证书\"></a>证明公开密钥正确性的证书</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/a60a859278525e0944814a22d2dc2c4a.png\"></p>\n<ul>\n<li><p>可证明组织真实性的 <strong>EV SSL</strong> 证书</p>\n<p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书（Extended Validation SSL Certificate）。</p>\n</li>\n<li><p>用以确认客户端的客户端证书</p>\n<p>HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。</p>\n</li>\n<li><p>认证机构信誉第一</p>\n</li>\n<li><p>由自认证机构颁发的证书称为自签名证书</p>\n</li>\n</ul>\n<h4 id=\"HTTPS-的安全通信机制\"><a href=\"#HTTPS-的安全通信机制\" class=\"headerlink\" title=\"HTTPS 的安全通信机制\"></a><strong>HTTPS</strong> 的安全通信机制</h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/8fd4f672653f4ee626fa9d20a1ed5f5c.png\"></p>\n<p>步骤 <strong>1</strong>： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p>\n<p>步骤 <strong>2</strong>： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>\n<p>步骤 <strong>3</strong>： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>\n<p>步骤 <strong>4</strong>： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p>\n<p>步骤 <strong>5</strong>： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p>\n<p>步骤 <strong>6</strong>： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p>\n<p>步骤 <strong>7</strong>： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p>\n<p>步骤 <strong>8</strong>： 服务器同样发送 Change Cipher Spec 报文。</p>\n<p>步骤 <strong>9</strong>： 服务器同样发送 Finished 报文。</p>\n<p>步骤 <strong>10</strong>： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p>\n<p>步骤 <strong>11</strong>： 应用层协议通信，即发送 HTTP 响应。</p>\n<p>步骤 <strong>12</strong>： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p>\n<p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/c4d634280d5777af7ef7eb4b434c7791.png\"></p>\n<p>从仅使用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程</p>\n<h4 id=\"SSL和TLS\"><a href=\"#SSL和TLS\" class=\"headerlink\" title=\"SSL和TLS\"></a>SSL和TLS</h4><p>HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security）这两个协议。</p>\n<p>SSL目前主导权已转移到IETF，IETF以SSL3.0为基准，后制定了TLS1.0、TLS1.1、TLS1.2。</p>\n<p>当前主流SSL3.0、TLS1.0</p>\n<h5 id=\"small-tips\"><a href=\"#small-tips\" class=\"headerlink\" title=\"small_tips\"></a>small_tips</h5><ul>\n<li><strong>HTTPS</strong> 比 <strong>HTTP</strong> 要慢 <strong>2</strong> 到 <strong>100</strong> 倍</li>\n</ul>\n<h2 id=\"确认访问用户身份的认证\"><a href=\"#确认访问用户身份的认证\" class=\"headerlink\" title=\"确认访问用户身份的认证\"></a>确认访问用户身份的认证</h2><p>某些 Web 页面只想让特定的人浏览</p>\n<h3 id=\"何为认证\"><a href=\"#何为认证\" class=\"headerlink\" title=\"何为认证\"></a>何为认证</h3><p>为了弄清究竟是谁在访问服务 器，就得让对方的客户端自报家门。</p>\n<h4 id=\"HTTP-1-1-使用的认证方式\"><a href=\"#HTTP-1-1-使用的认证方式\" class=\"headerlink\" title=\"HTTP/1.1 使用的认证方式\"></a>HTTP/1.1 使用的认证方式</h4><ul>\n<li><strong>BASIC</strong> 认证（基本认证）</li>\n<li><strong>DIGEST</strong> 认证（摘要认证）</li>\n<li><strong>SSL</strong> 客户端认证</li>\n<li><strong>FormBase</strong> 认证（基于表单认证）</li>\n<li>Windows 统一认证（Keberos 认证、NTLM 认证）</li>\n</ul>\n<h3 id=\"BASIC-认证（基本认证）\"><a href=\"#BASIC-认证（基本认证）\" class=\"headerlink\" title=\"BASIC 认证（基本认证）\"></a><strong>BASIC</strong> 认证（基本认证）</h3><p><img src=\"https://images.dadream.eu.org/images/2024/07/922d89ad738f1561e68b4dc757c68789.png\"></p>\n<p>BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，在HTTP这种非加密信道通信就会被截获。</p>\n<h3 id=\"DIGEST-认证（摘要认证）\"><a href=\"#DIGEST-认证（摘要认证）\" class=\"headerlink\" title=\"DIGEST 认证（摘要认证）\"></a><strong>DIGEST</strong> 认证（摘要认证）</h3><p>DIGEST 认证同样使用质询 / 响应的方式</p>\n<p>所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/d2892338940c78fc33f6406e7091220c.png\"></p>\n<p>DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。</p>\n<h3 id=\"SSL-客户端认证\"><a href=\"#SSL-客户端认证\" class=\"headerlink\" title=\"SSL 客户端认证\"></a><strong>SSL</strong> 客户端认证</h3><p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>步骤 <strong>1</strong>： 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。</p>\n<p>步骤 <strong>2</strong>： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</p>\n<p>步骤 <strong>3</strong>： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</p>\n<h4 id=\"SSL-客户端认证采用双因素认证\"><a href=\"#SSL-客户端认证采用双因素认证\" class=\"headerlink\" title=\"SSL 客户端认证采用双因素认证\"></a><strong>SSL</strong> 客户端认证采用双因素认证</h4><p>在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证（Two-factor authentication）来使用。换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机， 另一个认证因素的密码则用来确定这是用户本人的行为。</p>\n<h4 id=\"SSL-客户端认证必要的费用（证书）\"><a href=\"#SSL-客户端认证必要的费用（证书）\" class=\"headerlink\" title=\"SSL 客户端认证必要的费用（证书）\"></a><strong>SSL</strong> 客户端认证必要的费用（证书）</h4><h3 id=\"基于表单认证\"><a href=\"#基于表单认证\" class=\"headerlink\" title=\"基于表单认证\"></a>基于表单认证</h3><p>客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。</p>\n<h5 id=\"认证多半为基于表单认证\"><a href=\"#认证多半为基于表单认证\" class=\"headerlink\" title=\"认证多半为基于表单认证\"></a>认证多半为基于表单认证</h5><p><strong>Session</strong> 管理及 <strong>Cookie</strong> 应用</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/2e8062821a51e04c45ae2ac8e7aa8fa1.png\"></p>\n<h2 id=\"基于-HTTP-的功能追加协议\"><a href=\"#基于-HTTP-的功能追加协议\" class=\"headerlink\" title=\"基于 HTTP 的功能追加协议\"></a>基于 <strong>HTTP</strong> 的功能追加协议</h2><h4 id=\"基于-HTTP-的协议\"><a href=\"#基于-HTTP-的协议\" class=\"headerlink\" title=\"基于 HTTP 的协议\"></a>基于 <strong>HTTP</strong> 的协议</h4><h4 id=\"消除-HTTP-瓶颈的-SPDY\"><a href=\"#消除-HTTP-瓶颈的-SPDY\" class=\"headerlink\" title=\"消除 HTTP 瓶颈的 SPDY\"></a>消除 <strong>HTTP</strong> 瓶颈的 <strong>SPDY</strong></h4><h5 id=\"HTTP-瓶颈\"><a href=\"#HTTP-瓶颈\" class=\"headerlink\" title=\"HTTP 瓶颈\"></a><strong>HTTP</strong> 瓶颈</h5><p><img src=\"https://images.dadream.eu.org/images/2024/07/a6c1ddf897e03fc581cd5fd4f7990a4c.png\"></p>\n<ul>\n<li><p>Ajax解决</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/d26bb569fc6c3b4263f786cd14533727.png\"></p>\n</li>\n<li><p><strong>Comet</strong> 解决</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/0bace5d97336e00fd7d4f6932defe557.png\"></p>\n</li>\n<li><p>消除 <strong>HTTP</strong> 瓶颈的 <strong>SPDY</strong></p>\n</li>\n</ul>\n<h4 id=\"SPDY-的设计与功能\"><a href=\"#SPDY-的设计与功能\" class=\"headerlink\" title=\"SPDY 的设计与功能\"></a><strong>SPDY</strong> 的设计与功能</h4><p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。</p>\n<p>SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/fb54f1e32d646b366d829a2c9a887ad3.png\"></p>\n<h5 id=\"新功能\"><a href=\"#新功能\" class=\"headerlink\" title=\"新功能\"></a>新功能</h5><ul>\n<li>多路复用流</li>\n<li>赋予请求优先级</li>\n<li>压缩 <strong>HTTP</strong> 首部</li>\n<li>推送功能</li>\n<li>服务器提示功能</li>\n</ul>\n<h4 id=\"SPDY-大体上消除了-Web-瓶颈\"><a href=\"#SPDY-大体上消除了-Web-瓶颈\" class=\"headerlink\" title=\"SPDY 大体上消除了 Web 瓶颈\"></a><strong>SPDY</strong> 大体上消除了 <strong>Web</strong> 瓶颈</h4><h3 id=\"使用浏览器进行全双工通信的WebSocket\"><a href=\"#使用浏览器进行全双工通信的WebSocket\" class=\"headerlink\" title=\"使用浏览器进行全双工通信的WebSocket\"></a>使用浏览器进行全双工通信的<strong>WebSocket</strong></h3><p>WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。</p>\n<p> WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。</p>\n<h4 id=\"WebSocket-协议\"><a href=\"#WebSocket-协议\" class=\"headerlink\" title=\"WebSocket 协议\"></a>WebSocket 协议</h4><p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接， 之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML 或图片等任意格式的数据。</p>\n<p>由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端， 而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p>\n<h5 id=\"新特点\"><a href=\"#新特点\" class=\"headerlink\" title=\"新特点\"></a>新特点</h5><ul>\n<li>推送功能</li>\n<li>减少通信量</li>\n</ul>\n<h4 id=\"实现-WebSocket-通信\"><a href=\"#实现-WebSocket-通信\" class=\"headerlink\" title=\"实现 WebSocket 通信\"></a>实现 WebSocket 通信</h4><p>完成一次握手</p>\n<h5 id=\"握手请求\"><a href=\"#握手请求\" class=\"headerlink\" title=\"握手请求\"></a>握手请求</h5><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">GET /chat  HTTP/1.1 \n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">server.example.com </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Upgrade</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">websocket Connection: Upgrade</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Sec-WebSocket-Key</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">dGhlIHNhbXBsZSBub25jZQ== </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Origin</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">http://example.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Sec-WebSocket-Protocol</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">chat, superchat </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Sec-WebSocket-Version</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">13</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变。</p>\n<p>Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol 字段内记录使用的子协议。</p>\n<h5 id=\"握手响应\"><a href=\"#握手响应\" class=\"headerlink\" title=\"握手响应\"></a>握手响应</h5><pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">101</span> <span class=\"token reason-phrase string\">Switching Protocols</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Upgrade</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">websocket </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Connection</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Upgrade</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Sec-WebSocket-Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">s3pPLMBiTxaQ9kYGzzhZRbK+xOo= </span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Sec-WebSocket-Protocol</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">chat</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。</p>\n<p><img src=\"https://images.dadream.eu.org/images/2024/07/1c6be636e6391922df500391f6f0a9d2.png\"></p>\n<h4 id=\"WebSocket-API\"><a href=\"#WebSocket-API\" class=\"headerlink\" title=\"WebSocket API\"></a>WebSocket API</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> socket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebSocket</span><span class=\"token punctuation\">(</span>'ws<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>game<span class=\"token punctuation\">.</span>example<span class=\"token punctuation\">.</span>com<span class=\"token operator\">:</span><span class=\"token number\">12010</span><span class=\"token operator\">/</span> socket<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onopen</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">.</span>bufferedAmount <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> socket<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token function\">getUpdateData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h3><h4 id=\"HTTP-2-0特点\"><a href=\"#HTTP-2-0特点\" class=\"headerlink\" title=\"HTTP/2.0特点\"></a>HTTP/2.0特点</h4><table>\n<thead>\n<tr>\n<th>压缩</th>\n<th><strong>SPDY</strong>、<strong>Friendly</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>多路复用</td>\n<td>SPDY</td>\n</tr>\n<tr>\n<td>TLS 义务化</td>\n<td>Speed＋ Mobility</td>\n</tr>\n<tr>\n<td>协商</td>\n<td>Speed＋ Mobility，Friendly</td>\n</tr>\n<tr>\n<td>客户端拉曳（Client Pull）/服务器推送  （Server Push）</td>\n<td>Speed＋ Mobility</td>\n</tr>\n<tr>\n<td>流量控制</td>\n<td>SPDY</td>\n</tr>\n<tr>\n<td>WebSocket</td>\n<td>Speed＋ Mobility</td>\n</tr>\n</tbody></table>\n<p>注：HTTP Speed ＋ Mobility 简写为 Speed ＋ Mobility，Network-Friendly HTTP Upgrade 简写为 Friendly。</p>\n<h3 id=\"Web-服务器管理文件的-WebDAV\"><a href=\"#Web-服务器管理文件的-WebDAV\" class=\"headerlink\" title=\"Web 服务器管理文件的 WebDAV\"></a><strong>Web</strong> 服务器管理文件的 <strong>WebDAV</strong></h3><p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。它作为扩展 HTTP/1.1 的协议定义在 RFC4918。</p>\n<p>除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。</p>\n<h4 id=\"扩展-HTTP-1-1-的-WebDAV\"><a href=\"#扩展-HTTP-1-1-的-WebDAV\" class=\"headerlink\" title=\"扩展 HTTP/1.1 的 WebDAV\"></a>扩展 <strong>HTTP/1.1</strong> 的 <strong>WebDAV</strong></h4><p><img src=\"https://images.dadream.eu.org/images/2024/07/0576a601ec5602848bee1800f36f65f3.png\"></p>\n<p>集合（<strong>Collection</strong>）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加。</p>\n<p>资源（<strong>Resource</strong>）：把文件或集合称为资源。</p>\n<p>属性（<strong>Property</strong>）：定义资源的属性。定义以<strong>“</strong>名称 <strong>=</strong> 值<strong>”</strong>的格式执行。</p>\n<p>锁（<strong>Lock</strong>）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。</p>\n<h4 id=\"WebDAV-内新增的方法及状态码\"><a href=\"#WebDAV-内新增的方法及状态码\" class=\"headerlink\" title=\"WebDAV 内新增的方法及状态码\"></a><strong>WebDAV</strong> 内新增的方法及状态码</h4><p>WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。</p>\n<p><strong>PROPFIND</strong> ：获取属性</p>\n<p><strong>PROPPATCH</strong> ：修改属性</p>\n<p><strong>MKCOL</strong> ：创建集合</p>\n<p><strong>COPY</strong> ：复制资源及属性</p>\n<p><strong>MOVE</strong> ：移动资源</p>\n<p><strong>LOCK</strong> ：资源加锁</p>\n<p><strong>UNLOCK</strong> ：资源解锁</p>\n<p>为配合扩展的方法，状态码也随之扩展。</p>\n<p><strong>102 Processing</strong> ：可正常处理请求，但目前是处理中状态</p>\n<p><strong>207 Multi-Status</strong> ：存在多种状态</p>\n<p><strong>422 Unprocessible Entity</strong> ：格式正确，内容有误</p>\n<p><strong>423 Locked</strong> ：资源已被加锁</p>\n<p><strong>424 Failed Dependency</strong> ：处理与某请求关联的请求失败，因此不再维持依赖关系</p>\n<p><strong>507 Isufficient Storage</strong> ：保存空间不足</p>\n<ul>\n<li><p><strong>WebDAV</strong> 的请求实例</p>\n<p>下面是使用 PROPFIND 方法对 <a href=\"http://www.example.com/file\">http://www.example.com/file </a>发起获取属性的请求。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">PROPFIND /file HTTP/1.1\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">www.example.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/xml; charset=\"utf-8\" Content-Length: 219</span></span>\n\n&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;D:propfind xmlns:D=\"DAV:\"&gt;\n&lt;D:prop xmlns:R=\"http://ns.example.com/boxschema/\"&gt;\n&lt;R:bigbox/&gt;\n&lt;R:author/&gt;\n&lt;R:DingALing/&gt;\n&lt;R:Random/&gt;\n&lt;/D:prop&gt;\n&lt;/D:propfind&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>WebDAV</strong> 的响应实例</p>\n<p>下面是针对之前的 PROPFIND 方法，返回<a href=\"http://www.example.com/file\">http://www.example.com/file </a>的属性的响应。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">207</span> <span class=\"token reason-phrase string\">Multi-Status</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/xml; charset=\"utf-8\" Content-Length: 831</span></span>\n\n&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;D:multistatus xmlns:D=\"DAV:\"&gt;\n&lt;D:response xmlns:R=\"http://ns.example.com/boxschema/\"\n&lt;D:href&gt;http://www.example.com/file&lt;/D:href&gt;\n&lt;D:propstat&gt;\n&lt;D:prop&gt;\n&lt;R:bigbox&gt;\n&lt;R:BoxType&gt;Box type A&lt;/R:BoxType&gt;\n&lt;/R:bigbox&gt;\n&lt;R:author&gt;\n&lt;R:Name&gt;J.J. Johnson&lt;/R:Name&gt;\n&lt;/R:author&gt;\n&lt;/D:prop&gt;\n&lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;\n&lt;/D:propstat&gt;\n&lt;D:propstat&gt;\n&lt;D:prop&gt;&lt;R:DingALing/&gt;&lt;R:Random/&gt;&lt;/D:prop&gt;\n&lt;D:status&gt;HTTP/1.1 403 Forbidden&lt;/D:status&gt;\n&lt;D:responsedescription&gt; The user does not have acc\n&lt;/D:responsedescription&gt;\n&lt;/D:propstat&gt;\n&lt;/D:response&gt;\n&lt;D:responsedescription&gt; There has been an access viola\n&lt;/D:responsedescription&gt;\n&lt;/D:multistatus&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"构建-Web-内容的技术\"><a href=\"#构建-Web-内容的技术\" class=\"headerlink\" title=\"构建 Web 内容的技术\"></a>构建 <strong>Web</strong> 内容的技术</h2><h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><h5 id=\"Web-页面几乎全由-HTML-构建\"><a href=\"#Web-页面几乎全由-HTML-构建\" class=\"headerlink\" title=\"Web 页面几乎全由 HTML 构建\"></a><strong>Web</strong> 页面几乎全由 <strong>HTML</strong> 构建</h5><h5 id=\"HTML版本\"><a href=\"#HTML版本\" class=\"headerlink\" title=\"HTML版本\"></a>HTML版本</h5><h5 id=\"设计应用-CSS\"><a href=\"#设计应用-CSS\" class=\"headerlink\" title=\"设计应用 CSS\"></a>设计应用 <strong>CSS</strong></h5><h4 id=\"动态HTML\"><a href=\"#动态HTML\" class=\"headerlink\" title=\"动态HTML\"></a>动态HTML</h4><p>使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。</p>\n<h5 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h5><p>DOM 是用以操作 HTML 文档和 XML 文档的 API（Application Programming Interface，应用编程接口）。</p>\n<p>Web应用</p>\n<h4 id=\"通过-Web-提供功能的-Web-应用\"><a href=\"#通过-Web-提供功能的-Web-应用\" class=\"headerlink\" title=\"通过 Web 提供功能的 Web 应用\"></a>通过 <strong>Web</strong> 提供功能的 <strong>Web</strong> 应用</h4><p>由程序创建的内容称为动态内容，而事先准备好的内容称为静态内容。</p>\n<h4 id=\"与-Web-服务器及程序协作的-CGI\"><a href=\"#与-Web-服务器及程序协作的-CGI\" class=\"headerlink\" title=\"与 Web 服务器及程序协作的 CGI\"></a>与 <strong>Web</strong> 服务器及程序协作的 <strong>CGI</strong></h4><p>CGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建 HTML 等动态内容。</p>\n<p>使用 CGI 的程序叫做 CGI 程序，通常是用 Perl、PHP、Ruby 和 C 等编程语言编写而成。</p>\n<h4 id=\"因-Java-而普及的-Servlet\"><a href=\"#因-Java-而普及的-Servlet\" class=\"headerlink\" title=\"因 Java 而普及的 Servlet\"></a>因 <strong>Java</strong> 而普及的 <strong>Servlet</strong></h4><p>Servlet 是一种能在服务器上创建动态内容的程序。Servlet 是用 Java 语言实现的一个接口，属于面向企业级 Java（JavaEE，Java Enterprise Edition）的一部分。负载小。</p>\n<h3 id=\"数据发布的格式及语言\"><a href=\"#数据发布的格式及语言\" class=\"headerlink\" title=\"数据发布的格式及语言\"></a>数据发布的格式及语言</h3><h4 id=\"可扩展标记语言\"><a href=\"#可扩展标记语言\" class=\"headerlink\" title=\"可扩展标记语言\"></a>可扩展标记语言</h4><p>XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数据共享变得更容易。</p>\n<p>XML 和 HTML 都是从标准通用标记语言 SGML（Standard Generalized Markup Language）简化而成。与 HTML 相比，它对数据的记录方式做了特殊处理。</p>\n<h4 id=\"发布更新信息的-RSS-Atom\"><a href=\"#发布更新信息的-RSS-Atom\" class=\"headerlink\" title=\"发布更新信息的 RSS/Atom\"></a>发布更新信息的 <strong>RSS/Atom</strong></h4><p>RSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。</p>\n<h4 id=\"JavaScript-衍生的轻量级易用-JSON\"><a href=\"#JavaScript-衍生的轻量级易用-JSON\" class=\"headerlink\" title=\"JavaScript 衍生的轻量级易用 JSON\"></a><strong>JavaScript</strong> 衍生的轻量级易用 <strong>JSON</strong></h4><p>JSON（JavaScript Object Notation）是一种以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。</p>\n<h2 id=\"Web-的攻击技术\"><a href=\"#Web-的攻击技术\" class=\"headerlink\" title=\"Web 的攻击技术\"></a><strong>Web</strong> 的攻击技术</h2><h3 id=\"针对-Web-的攻击技术\"><a href=\"#针对-Web-的攻击技术\" class=\"headerlink\" title=\"针对 Web 的攻击技术\"></a>针对 <strong>Web</strong> 的攻击技术</h3><h4 id=\"HTTP-不具备必要的安全功能\"><a href=\"#HTTP-不具备必要的安全功能\" class=\"headerlink\" title=\"HTTP 不具备必要的安全功能\"></a><strong>HTTP</strong> 不具备必要的安全功能</h4><h4 id=\"在客户端即可篡改请求\"><a href=\"#在客户端即可篡改请求\" class=\"headerlink\" title=\"在客户端即可篡改请求\"></a>在客户端即可篡改请求</h4><h4 id=\"针对-Web-应用的攻击模式\"><a href=\"#针对-Web-应用的攻击模式\" class=\"headerlink\" title=\"针对 Web 应用的攻击模式\"></a>针对 <strong>Web</strong> 应用的攻击模式</h4><ul>\n<li>主动攻击</li>\n<li>被动攻击</li>\n<li>以服务器为目标的主动攻击</li>\n<li>以服务器为目标的被动攻</li>\n</ul>\n<h3 id=\"因输出值转义不完全引发的安全漏洞\"><a href=\"#因输出值转义不完全引发的安全漏洞\" class=\"headerlink\" title=\"因输出值转义不完全引发的安全漏洞\"></a>因输出值转义不完全引发的安全漏洞</h3><ul>\n<li>客户端的验证</li>\n<li><strong>Web</strong> 应用端（服务器端）的验证<ul>\n<li>输入值验证</li>\n<li>输出值转义</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"跨站脚本攻击（Cross-Site-Scripting，XSS）\"><a href=\"#跨站脚本攻击（Cross-Site-Scripting，XSS）\" class=\"headerlink\" title=\"跨站脚本攻击（Cross-Site Scripting，XSS）\"></a>跨站脚本攻击（Cross-Site Scripting，XSS）</h4><p>跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。</p>\n<h4 id=\"SQL-注入（SQL-Injection）\"><a href=\"#SQL-注入（SQL-Injection）\" class=\"headerlink\" title=\"SQL 注入（SQL Injection）\"></a>SQL 注入（SQL Injection）</h4><h4 id=\"OS-命令注入攻击（OS-Command-Injection）\"><a href=\"#OS-命令注入攻击（OS-Command-Injection）\" class=\"headerlink\" title=\"OS 命令注入攻击（OS Command Injection）\"></a>OS 命令注入攻击（OS Command Injection）</h4><h4 id=\"HTTP-首部注入攻击（HTTP-Header-Injection）\"><a href=\"#HTTP-首部注入攻击（HTTP-Header-Injection）\" class=\"headerlink\" title=\"HTTP 首部注入攻击（HTTP Header Injection）\"></a>HTTP 首部注入攻击（HTTP Header Injection）</h4><h4 id=\"邮件首部注入（Mail-Header-Injection）\"><a href=\"#邮件首部注入（Mail-Header-Injection）\" class=\"headerlink\" title=\"邮件首部注入（Mail Header Injection）\"></a>邮件首部注入（Mail Header Injection）</h4><h4 id=\"目录遍历（Directory-Traversal）攻击\"><a href=\"#目录遍历（Directory-Traversal）攻击\" class=\"headerlink\" title=\"目录遍历（Directory Traversal）攻击\"></a>目录遍历（Directory Traversal）攻击</h4><h4 id=\"远程文件包含漏洞（Remote-File-Inclusion）\"><a href=\"#远程文件包含漏洞（Remote-File-Inclusion）\" class=\"headerlink\" title=\"远程文件包含漏洞（Remote File Inclusion）\"></a>远程文件包含漏洞（Remote File Inclusion）</h4><h3 id=\"因设置或设计上的缺陷引发的安全漏洞\"><a href=\"#因设置或设计上的缺陷引发的安全漏洞\" class=\"headerlink\" title=\"因设置或设计上的缺陷引发的安全漏洞\"></a>因设置或设计上的缺陷引发的安全漏洞</h3><h4 id=\"强制浏览（Forced-Browsing）\"><a href=\"#强制浏览（Forced-Browsing）\" class=\"headerlink\" title=\"强制浏览（Forced Browsing）\"></a>强制浏览（Forced Browsing）</h4><p>强制浏览（Forced Browsing）安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。</p>\n<h4 id=\"不正确的错误消息处理（Error-Handling-Vulnerability）\"><a href=\"#不正确的错误消息处理（Error-Handling-Vulnerability）\" class=\"headerlink\" title=\"不正确的错误消息处理（Error Handling Vulnerability）\"></a>不正确的错误消息处理（Error Handling Vulnerability）</h4><p>不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web 应用的错误信息内包含对攻击者有用的信息。</p>\n<h4 id=\"开放重定向（Open-Redirect）\"><a href=\"#开放重定向（Open-Redirect）\" class=\"headerlink\" title=\"开放重定向（Open Redirect）\"></a>开放重定向（Open Redirect）</h4><p>开放重定向（Open Redirect）是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。</p>\n<h3 id=\"因会话管理疏忽引发的安全漏洞\"><a href=\"#因会话管理疏忽引发的安全漏洞\" class=\"headerlink\" title=\"因会话管理疏忽引发的安全漏洞\"></a>因会话管理疏忽引发的安全漏洞</h3><h4 id=\"会话劫持（Session-Hijack）\"><a href=\"#会话劫持（Session-Hijack）\" class=\"headerlink\" title=\"会话劫持（Session Hijack）\"></a>会话劫持（Session Hijack）</h4><p>会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</p>\n<h4 id=\"会话固定攻击\"><a href=\"#会话固定攻击\" class=\"headerlink\" title=\"会话固定攻击\"></a>会话固定攻击</h4><p>对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击。</p>\n<h4 id=\"跨站点请求伪造（Cross-Site-Request-Forgeries，CSRF）\"><a href=\"#跨站点请求伪造（Cross-Site-Request-Forgeries，CSRF）\" class=\"headerlink\" title=\"跨站点请求伪造（Cross-Site Request Forgeries，CSRF）\"></a>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）</h4><p>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</p>\n<h3 id=\"其他安全漏洞\"><a href=\"#其他安全漏洞\" class=\"headerlink\" title=\"其他安全漏洞\"></a>其他安全漏洞</h3><h4 id=\"密码破解攻击（Password-Cracking）\"><a href=\"#密码破解攻击（Password-Cracking）\" class=\"headerlink\" title=\"密码破解攻击（Password Cracking）\"></a>密码破解攻击（Password Cracking）</h4><p>密码破解攻击（Password Cracking）即算出密码，突破认证。</p>\n<h4 id=\"点击劫持（Clickjacking）\"><a href=\"#点击劫持（Clickjacking）\" class=\"headerlink\" title=\"点击劫持（Clickjacking）\"></a>点击劫持（Clickjacking）</h4><p>点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。</p>\n<h4 id=\"DoS-攻击（Denial-of-Service-attack）\"><a href=\"#DoS-攻击（Denial-of-Service-attack）\" class=\"headerlink\" title=\"DoS 攻击（Denial of Service attack）\"></a>DoS 攻击（Denial of Service attack）</h4><p>DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。</p>\n<h4 id=\"后门程序（Backdoor）\"><a href=\"#后门程序（Backdoor）\" class=\"headerlink\" title=\"后门程序（Backdoor）\"></a>后门程序（Backdoor）</h4><p>后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。</p>\n",
            "tags": [
                "学习"
            ]
        }
    ]
}