{
    "version": "https://jsonfeed.org/version/1",
    "title": "逐梦",
    "description": "Welcome to my blog",
    "home_page_url": "https://0xdadream.github.io",
    "items": [
        {
            "id": "https://0xdadream.github.io/2025/06/17/xu-qi-shi-jian-bei-wang-lu/",
            "url": "https://0xdadream.github.io/2025/06/17/xu-qi-shi-jian-bei-wang-lu/",
            "title": "续期时间备忘录",
            "date_published": "2025-06-17T06:25:00.000Z",
            "content_html": "<h1 id=\"续期时间备忘录\"><a href=\"#续期时间备忘录\" class=\"headerlink\" title=\"续期时间备忘录\"></a>续期时间备忘录</h1><h2 id=\"DigitalPlat-FreeDomain（DigitalPlat-Domain-Dashboard）\"><a href=\"#DigitalPlat-FreeDomain（DigitalPlat-Domain-Dashboard）\" class=\"headerlink\" title=\"DigitalPlat FreeDomain（DigitalPlat Domain Dashboard）\"></a>DigitalPlat FreeDomain（<a href=\"https://dash.domain.digitalplat.org/panel/main?page=/panel/domains\">DigitalPlat Domain Dashboard</a>）</h2><h3 id=\"0xdadream-dpdns-org\"><a href=\"#0xdadream-dpdns-org\" class=\"headerlink\" title=\"0xdadream.dpdns.org\"></a>0xdadream.dpdns.org</h3><ul>\n<li><strong>Expire Date:</strong> 20260710  </li>\n<li>最早续约: 180天</li>\n<li>下次续约：2026年1月12日</li>\n</ul>\n<h3 id=\"0xadadream-dpdns-org\"><a href=\"#0xadadream-dpdns-org\" class=\"headerlink\" title=\"0xadadream.dpdns.org\"></a>0xadadream.dpdns.org</h3><ul>\n<li><strong>Expire Date:</strong> 20260422</li>\n<li>最早续约: 180天</li>\n<li>下次续约：2025年10月25日</li>\n</ul>\n<h3 id=\"worlds-xx-kg\"><a href=\"#worlds-xx-kg\" class=\"headerlink\" title=\"worlds.xx.kg\"></a>worlds.xx.kg</h3><ul>\n<li><strong>Expire Date:</strong> 20260507</li>\n<li>最早续约: 180天</li>\n<li>下次续约：<strong>2025年11月9日</strong>（星期日）</li>\n</ul>\n<h2 id=\"Google账号保活登录\"><a href=\"#Google账号保活登录\" class=\"headerlink\" title=\"Google账号保活登录\"></a>Google账号保活登录</h2><p>时间：2025-06-07</p>\n<p>间隔：一年</p>\n<p>账号：</p>\n<ul>\n<li><a href=\"mailto:djh320088413@gmail.com\">djh320088413@gmail.com</a></li>\n<li><a href=\"mailto:dadreamdz@gmail.com\">dadreamdz@gmail.com</a></li>\n<li><a href=\"mailto:oxdadream@gmail.com\">oxdadream@gmail.com</a></li>\n<li><a href=\"mailto:0xdadreamzz@gmail.com\">0xdadreamzz@gmail.com</a></li>\n<li><a href=\"mailto:0xdadreamz@gmail.com\">0xdadreamz@gmail.com</a></li>\n<li><a href=\"mailto:jduan127@asu.edu\">jduan127@asu.edu</a></li>\n<li><a href=\"mailto:320088413@qq.com\">320088413@qq.com</a></li>\n</ul>\n<h2 id=\"Claw-Cloud（Claw-Cloud）\"><a href=\"#Claw-Cloud（Claw-Cloud）\" class=\"headerlink\" title=\"Claw Cloud（Claw Cloud）\"></a>Claw Cloud（<a href=\"https://us-east-1.run.claw.cloud/\">Claw Cloud</a>）</h2><p>容器启动时间：2025/04/22</p>\n<p>每月赠送：5美金</p>\n<h2 id=\"Webfreecloud-VPS容器（用户中心-Webfreecloud）\"><a href=\"#Webfreecloud-VPS容器（用户中心-Webfreecloud）\" class=\"headerlink\" title=\"Webfreecloud-VPS容器（用户中心 - Webfreecloud）\"></a>Webfreecloud-VPS容器（<a href=\"https://web.freecloud.ltd/clientarea.php\">用户中心 - Webfreecloud</a>）</h2><h3 id=\"x6f-120-100-x61-100-x72-101-97-x6d-64-103-109-97-105-108-46-x63-x6f-x6d\"><a href=\"#x6f-120-100-x61-100-x72-101-97-x6d-64-103-109-97-105-108-46-x63-x6f-x6d\" class=\"headerlink\" title=\"oxdadream@gmail.com\"></a><a href=\"mailto:oxdadream@gmail.com\">oxdadream@gmail.com</a></h3><ul>\n<li>下次续费期限：2025-7-15</li>\n<li>最早续费：7天</li>\n</ul>\n<h3 id=\"x6f-120-x64-x61-x64-x72-101-97-109-64-113-x71-x2e-99-111-x6d\"><a href=\"#x6f-120-x64-x61-x64-x72-101-97-109-64-113-x71-x2e-99-111-x6d\" class=\"headerlink\" title=\"oxdadream@qq.com\"></a><a href=\"mailto:oxdadream@qq.com\">oxdadream@qq.com</a></h3><ul>\n<li>下次续费期限：2025-7-15</li>\n<li>最早续费：7天</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://0xdadream.github.io/2025/06/17/python-bao-guan-li/",
            "url": "https://0xdadream.github.io/2025/06/17/python-bao-guan-li/",
            "title": "Python 包管理与导入全方位教程",
            "date_published": "2025-06-17T04:25:00.000Z",
            "content_html": "<h1 id=\"Python-包管理与导入全方位教程\"><a href=\"#Python-包管理与导入全方位教程\" class=\"headerlink\" title=\"Python 包管理与导入全方位教程\"></a>Python 包管理与导入全方位教程</h1><p>在 Python 开发中，代码的组织、复用和分发都离不开模块（Module）和包（Package）。掌握好它们的导入机制以及如何管理项目依赖，是从新手走向专业的必经之路。</p>\n<p>本教程将涵盖四个核心部分：</p>\n<ol>\n<li><strong>模块与导入：基础篇</strong> - 理解 Python 如何导入单个文件。</li>\n<li><strong>包的创建与内部导入：进阶篇</strong> - 如何组织你自己的项目代码。</li>\n<li><strong>使用 <code>pip</code> 管理外部包：工具篇</strong> - 如何安装和使用社区的优秀代码。</li>\n<li><strong>虚拟环境：最佳实践</strong> - 为什么需要以及如何使用虚拟环境来隔离项目。</li>\n</ol>\n<hr>\n<h3 id=\"Part-1-模块与导入：基础篇\"><a href=\"#Part-1-模块与导入：基础篇\" class=\"headerlink\" title=\"Part 1: 模块与导入：基础篇\"></a>Part 1: 模块与导入：基础篇</h3><h4 id=\"1-1-什么是模块-Module-？\"><a href=\"#1-1-什么是模块-Module-？\" class=\"headerlink\" title=\"1.1 什么是模块 (Module)？\"></a>1.1 什么是模块 (Module)？</h4><p>在 Python 中，<strong>任何一个 <code>.py</code> 文件都可以被看作一个模块</strong>。模块能让你将相关的代码（函数、类、变量）组织在一起，方便在其他地方复用。</p>\n<p>例如，我们创建一个 <code>math_utils.py</code> 文件：</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\"># math_utils.py\nPI = 3.14159\n\ndef add(a, b):\n    return a + b\n\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return PI * self.radius * self.radius<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"1-2-import-语句的基本用法\"><a href=\"#1-2-import-语句的基本用法\" class=\"headerlink\" title=\"1.2 import 语句的基本用法\"></a>1.2 <code>import</code> 语句的基本用法</h4><p><code>import</code> 语句用于将其他模块的功能引入到当前文件中。</p>\n<p><strong>方式一：导入整个模块</strong> 这是最常见的方式。你需要通过 <code>模块名.</code> 的前缀来访问其内容。</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\"># main.py\nimport math_utils\n\nprint(math_utils.PI)  # 输出: 3.14159\n\nsum_result = math_utils.add(3, 5)\nprint(sum_result) # 输出: 8\n\nmy_circle = math_utils.Circle(10)\nprint(my_circle.area()) # 输出: 314.159<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>方式二：使用 <code>as</code> 设置别名</strong> 如果模块名太长或者容易混淆，可以给它设置一个简短的别名。</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\">import math_utils as mu\n\nprint(mu.PI)\nprint(mu.add(3, 5))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>方式三：使用 <code>from...import...</code> 导入特定内容</strong> 如果你只需要模块中的某几个部分，可以使用 <code>from</code> 关键字直接导入它们。这样，在使用时就不需要加模块名前缀了。</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\">from math_utils import add, Circle\n\nsum_result = add(4, 6) # 直接调用 add，无需前缀\nprint(sum_result) # 输出: 10\n\nmy_circle = Circle(5)\nprint(my_circle.area()) # 输出: 78.53975<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>也可以为导入的特定内容设置别名：</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\">from math_utils import add as sum_func\n\nresult = sum_func(1, 2)\nprint(result) # 输出: 3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>方式四：<code>from...import \\*</code>（不推荐）</strong> 这会导入模块中所有非下划线开头的内容。<strong>强烈不推荐</strong>在大型项目中使用，因为它会污染当前文件的命名空间，你可能不知道哪些函数和变量被导入了，容易导致名称冲突和代码可读性下降。</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\"># 谨慎使用！\nfrom math_utils import *\n\nprint(PI) # 直接可用\nprint(add(1, 1)) # 直接可用<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"Part-2-包的创建与内部导入：进阶篇\"><a href=\"#Part-2-包的创建与内部导入：进阶篇\" class=\"headerlink\" title=\"Part 2: 包的创建与内部导入：进阶篇\"></a>Part 2: 包的创建与内部导入：进阶篇</h3><p>当项目变得复杂，一个文件已经不够用时，我们就需要用“包”（Package）来组织模块。</p>\n<h4 id=\"2-1-什么是包-Package-？\"><a href=\"#2-1-什么是包-Package-？\" class=\"headerlink\" title=\"2.1 什么是包 (Package)？\"></a>2.1 什么是包 (Package)？</h4><p>简单来说，<strong>一个包含 <code>__init__.py</code> 文件的目录就是一个包</strong>。这个目录里可以存放多个模块（<code>.py</code> 文件）或者子包。</p>\n<p><code>__init__.py</code> 文件有几个作用：</p>\n<ol>\n<li><strong>标记作用</strong>：它的存在告诉 Python 这个目录应该被当作一个包来对待。在 Python 3.3+ 版本中，即使没有这个文件，也可能被当作“命名空间包”，但为了兼容性和清晰性，<strong>强烈建议总是创建它</strong>。</li>\n<li><strong>初始化操作</strong>：可以在这个文件中编写代码，当包被导入时，这些代码会自动执行。</li>\n<li><strong>简化导入</strong>：可以在 <code>__init__.py</code> 中使用 <code>from .module import func</code> 的方式，将包深处的函数或类暴露到包的顶层，方便外部调用。</li>\n</ol>\n<h4 id=\"2-2-项目结构示例\"><a href=\"#2-2-项目结构示例\" class=\"headerlink\" title=\"2.2 项目结构示例\"></a>2.2 项目结构示例</h4><p>让我们构建一个清晰的项目结构作为例子：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">my_project/\n├── main.py             <span class=\"token comment\"># 项目主入口文件</span>\n└── my_app/             <span class=\"token comment\"># 我们的主应用包</span>\n    ├── __init__.py\n    ├── core/           <span class=\"token comment\"># 子包：核心功能</span>\n    │   ├── __init__.py\n    │   └── calculator.py\n    └── utils/          <span class=\"token comment\"># 子包：工具函数</span>\n        ├── __init__.py\n        └── formatter.py<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p><code>calculator.py</code> 内容:</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\"># my_app/core/calculator.py\ndef add(a, b):\n    return a + b<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>formatter.py</code> 内容:</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\"># my_app/utils/formatter.py\ndef format_as_json(data):\n    # 这是一个简化的例子\n    return f'{{\"result\": {data}}}'<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h4 id=\"2-3-包内导入：绝对导入-vs-相对导入\"><a href=\"#2-3-包内导入：绝对导入-vs-相对导入\" class=\"headerlink\" title=\"2.3 包内导入：绝对导入 vs 相对导入\"></a>2.3 包内导入：绝对导入 vs 相对导入</h4><p>现在，假设我们想在 <code>calculator.py</code> 中使用 <code>formatter.py</code> 的功能（虽然这个例子不太合逻辑，但很适合演示）。这就要用到包内导入。</p>\n<p><strong>1. 绝对导入 (Absolute Import) - 推荐</strong></p>\n<p>绝对导入总是从项目的<strong>根目录</strong>（可以被 Python 找到的路径，通常是你运行命令的目录）开始。它路径清晰，不容易出错，是 PEP 8 规范推荐的方式。</p>\n<p>假设我们在 <code>main.py</code> 中想使用 <code>calculator</code> 和 <code>formatter</code>：</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\"># main.py\nfrom my_app.core import calculator\nfrom my_app.utils import formatter\n\nresult = calculator.add(10, 20)\nprint(formatter.format_as_json(result))\n# 输出: {\"result\": 30}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>2. 相对导入 (Relative Import)</strong></p>\n<p>相对导入使用 <code>.</code> 或 <code>..</code> 来表示相对位置，它<strong>只能在包内部使用</strong>，不能在顶级脚本中使用。</p>\n<ul>\n<li><code>.</code>：表示当前目录。</li>\n<li><code>..</code>：表示上级目录。</li>\n</ul>\n<p>现在，假设我们的 <code>calculator.py</code> 需要调用 <code>formatter.py</code>。这在不同目录，<code>calculator.py</code> 需要先回到父级目录 <code>my_app</code>，再进入 <code>utils</code> 目录。</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\"># my_app/core/calculator.py\n\n# '..' 代表回到 calculator.py 的上级目录 (core -&gt; my_app)\n# 然后从 my_app 进入 utils 包，导入 formatter 模块\nfrom ..utils import formatter\n\ndef add_and_format(a, b):\n    sum_val = a + b\n    return formatter.format_as_json(sum_val)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>⚠️ 常见的陷阱：<code>ImportError</code></strong></p>\n<p>如果你直接运行一个使用了相对导入的文件，就会触发 <code>ImportError: attempted relative import with no known parent package</code> 错误。</p>\n<p>例如，直接在终端里运行： <code>python my_app/core/calculator.py</code></p>\n<p>这会失败！因为 Python 将 <code>calculator.py</code> 当作顶级脚本，它不知道自己的“父包”是谁。</p>\n<p><strong>正确的运行方式</strong>是从项目的根目录 <code>my_project/</code> 执行：</p>\n<ul>\n<li><p>如果你要运行 main.py（它使用绝对导入），直接运行即可：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">cd my_project/\npython main.py<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>如果你想把某个子模块当作脚本运行（例如测试），请使用 -m 标志：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">cd my_project/\npython -m my_app.core.calculator<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h3 id=\"Part-3-使用-pip-管理外部包：工具篇\"><a href=\"#Part-3-使用-pip-管理外部包：工具篇\" class=\"headerlink\" title=\"Part 3: 使用 pip 管理外部包：工具篇\"></a>Part 3: 使用 <code>pip</code> 管理外部包：工具篇</h3><p>当项目需要用到第三方库（如 <code>requests</code> 用于网络请求，<code>pandas</code> 用于数据分析）时，就需要包管理器。Python 的标准包管理器是 <code>pip</code>。</p>\n<h4 id=\"3-1-pip-基础命令\"><a href=\"#3-1-pip-基础命令\" class=\"headerlink\" title=\"3.1 pip 基础命令\"></a>3.1 <code>pip</code> 基础命令</h4><ul>\n<li><p><strong>安装包</strong>:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">pip install requests<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>安装指定版本的包</strong>:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">pip install requests==2.28.1\npip install \"requests&gt;=2.25.0\"<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>卸载包</strong>:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pip uninstall requests<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>查看已安装的包</strong>:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pip list<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>查看某个包的详细信息</strong>:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pip show requests<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h4 id=\"3-2-使用-requirements-txt-管理项目依赖\"><a href=\"#3-2-使用-requirements-txt-管理项目依赖\" class=\"headerlink\" title=\"3.2 使用 requirements.txt 管理项目依赖\"></a>3.2 使用 <code>requirements.txt</code> 管理项目依赖</h4><p>当你的项目依赖多个包，或者你需要与他人协作时，手动一个一个安装包是不可行的。最佳实践是使用 <code>requirements.txt</code> 文件来记录所有依赖。</p>\n<ol>\n<li><p><strong>生成 <code>requirements.txt</code></strong>: 当你完成开发，将当前环境中所有包及其版本信息冻结（freeze）到一个文件中：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pip freeze <span class=\"token operator\">&gt;</span> requirements.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>文件内容可能如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">certifi</span><span class=\"token operator\">==</span><span class=\"token number\">2022.9</span>.24\ncharset-normalizer<span class=\"token operator\">==</span><span class=\"token number\">2.1</span>.1\n<span class=\"token assign-left variable\">idna</span><span class=\"token operator\">==</span><span class=\"token number\">3.4</span>\n<span class=\"token assign-left variable\">requests</span><span class=\"token operator\">==</span><span class=\"token number\">2.28</span>.1\n<span class=\"token assign-left variable\">urllib3</span><span class=\"token operator\">==</span><span class=\"token number\">1.26</span>.12<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>从 <code>requirements.txt</code> 安装</strong>: 当另一个开发者拿到你的项目后，只需一条命令就可以安装所有必需的依赖：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pip <span class=\"token function\">install</span> <span class=\"token parameter variable\">-r</span> requirements.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<hr>\n<h3 id=\"Part-4-虚拟环境：最佳实践\"><a href=\"#Part-4-虚拟环境：最佳实践\" class=\"headerlink\" title=\"Part 4: 虚拟环境：最佳实践\"></a>Part 4: 虚拟环境：最佳实践</h3><h4 id=\"4-1-为什么需要虚拟环境？\"><a href=\"#4-1-为什么需要虚拟环境？\" class=\"headerlink\" title=\"4.1 为什么需要虚拟环境？\"></a>4.1 为什么需要虚拟环境？</h4><p>想象一下：</p>\n<ul>\n<li>项目 A 需要 <code>requests</code> 的 1.0 版本。</li>\n<li>项目 B 需要 <code>requests</code> 的 2.0 版本。</li>\n</ul>\n<p>如果你将它们都安装在全局的 Python环境中，就会产生版本冲突，导致一个项目无法正常工作。</p>\n<p><strong>虚拟环境（Virtual Environment）</strong> 就是为了解决这个问题而生的。它能为每个项目创建一个独立的、隔离的 Python 环境。你在其中安装的所有包都只属于这个项目，不会影响到全局环境或其他项目。</p>\n<h4 id=\"4-2-使用-venv（Python-内置工具）\"><a href=\"#4-2-使用-venv（Python-内置工具）\" class=\"headerlink\" title=\"4.2 使用 venv（Python 内置工具）\"></a>4.2 使用 <code>venv</code>（Python 内置工具）</h4><p>从 Python 3.3 开始，<code>venv</code> 模块成为创建虚拟环境的标准工具。</p>\n<p><strong>1. 创建虚拟环境</strong>: 在你的项目根目录下，运行以下命令。<code>venv</code> 是你给这个环境起的名字，这是一个通用惯例。</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\"># 在 my_project/ 目录下\npython -m venv venv<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>执行后，会创建一个 <code>venv</code> 目录，里面包含了独立的 Python 解释器和包安装目录。</p>\n<p><strong>2. 激活虚拟环境</strong>: 在使用前，你必须“激活”它。</p>\n<ul>\n<li><p>Windows:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">.\\venv\\Scripts\\activate<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>macOS / Linux:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">source venv/bin/activate<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<p>激活后，你会发现你的命令行提示符前面多了 <code>(venv)</code> 的字样，表示你正处于这个虚拟环境中。</p>\n<p><strong>3. 在虚拟环境中工作</strong>: 激活后，你使用的 <code>python</code> 和 <code>pip</code> 命令都将是该环境内的版本。</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\"># (venv) D:\\path\\to\\my_project&gt;\npip install requests\npip freeze &gt; requirements.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>现在 <code>requests</code> 被安装到了 <code>my_project/venv/Lib/site-packages</code> 目录下，而不是全局。</p>\n<p><strong>4. 停用虚拟环境</strong>: 当你工作完成，想回到全局环境时，只需运行：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">deactivate<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"4-3-结合-gitignore\"><a href=\"#4-3-结合-gitignore\" class=\"headerlink\" title=\"4.3 结合 .gitignore\"></a>4.3 结合 <code>.gitignore</code></h4><p>虚拟环境目录 (<code>venv</code>) 不应该被提交到 Git 等版本控制系统中。它包含了大量文件，并且可以在任何地方通过 <code>requirements.txt</code> 重建。</p>\n<p>因此，请务必在你的 <code>.gitignore</code> 文件中添加 <code>venv/</code> 这一行。</p>\n<h3 id=\"总结：专业的开发流程\"><a href=\"#总结：专业的开发流程\" class=\"headerlink\" title=\"总结：专业的开发流程\"></a>总结：专业的开发流程</h3><ol>\n<li><strong>项目启动</strong>：<ul>\n<li>创建项目主目录（如 <code>my_project</code>）。</li>\n<li><code>cd my_project</code></li>\n<li>创建虚拟环境：<code>python -m venv venv</code></li>\n<li>激活环境：<code>source venv/bin/activate</code> (或 Windows 对应命令)。</li>\n</ul>\n</li>\n<li><strong>开发过程</strong>：<ul>\n<li>使用 <code>pip install &lt;package_name&gt;</code> 安装所需第三方库。</li>\n<li>按照包的结构组织你的代码（创建 <code>my_app</code>, <code>__init__.py</code> 等）。</li>\n<li>在包内部优先使用<strong>绝对导入</strong>，或在必要时使用相对导入。</li>\n</ul>\n</li>\n<li><strong>依赖管理</strong>：<ul>\n<li>定期更新 <code>requirements.txt</code> 文件：<code>pip freeze &gt; requirements.txt</code>。</li>\n</ul>\n</li>\n<li><strong>项目交付/协作</strong>：<ul>\n<li>其他人获取你的代码后，只需重复第一步创建并激活虚拟环境，然后运行 <code>pip install -r requirements.txt</code> 即可搭建出完全一致的开发环境。</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/06/02/linux-chang-yong-ming-ling-xiang-xi-jiao-cheng/",
            "url": "https://0xdadream.github.io/2025/06/02/linux-chang-yong-ming-ling-xiang-xi-jiao-cheng/",
            "title": "Linux 常用命令详解教程",
            "date_published": "2025-06-02T14:25:00.000Z",
            "content_html": "<h1 id=\"Linux-常用命令详解教程\"><a href=\"#Linux-常用命令详解教程\" class=\"headerlink\" title=\"Linux 常用命令详解教程\"></a>Linux 常用命令详解教程</h1><p>本教程旨在提供一份全面的 Linux 常用命令列表，涵盖文件管理、系统信息获取、高级系统监控、文本处理、用户与权限管理、网络配置与诊断以及端口和防火墙管理等多个方面。每个命令都将包含其用途、常用语法、重要选项及示例，力求内容完整且实用。</p>\n<h2 id=\"一、文件和目录管理-File-and-Directory-Management\"><a href=\"#一、文件和目录管理-File-and-Directory-Management\" class=\"headerlink\" title=\"一、文件和目录管理 (File and Directory Management)\"></a>一、文件和目录管理 (File and Directory Management)</h2><p>文件和目录管理是 Linux 系统操作的基础。以下命令能帮助用户有效地在文件系统中进行导航、创建、删除、复制、移动和查找文件及目录。</p>\n<h3 id=\"1-1-基本导航与列表-Basic-Navigation-and-Listing\"><a href=\"#1-1-基本导航与列表-Basic-Navigation-and-Listing\" class=\"headerlink\" title=\"1.1 基本导航与列表 (Basic Navigation and Listing)\"></a>1.1 基本导航与列表 (Basic Navigation and Listing)</h3><ul>\n<li><strong><code>ls</code></strong> (列出目录内容 List directory contents)<ul>\n<li><strong>用途:</strong> 显示目录中的文件和子目录。 </li>\n<li><strong>语法:</strong> <code>ls [选项][目录名]</code> </li>\n<li>常用选项:<ul>\n<li><code>-l</code>: 以长格式显示详细信息，包括权限、所有者、大小、修改日期等。 </li>\n<li><code>-a</code>: 显示所有文件，包括隐藏文件（以 <code>.</code> 开头的文件）。 </li>\n<li><code>-h</code>: 以人类可读的格式显示文件大小 (例如 1K, 234M, 2G)。 </li>\n<li><code>-A</code>: 显示除 <code>.</code> 和 <code>..</code> 之外的所有文件，包括隐藏文件。 </li>\n<li><code>-S</code>: 按文件大小降序排序。 </li>\n<li><code>-t</code>: 按修改时间排序，最新修改的在前。 </li>\n<li><code>-R</code>: 递归列出所有子目录的内容。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>ls -l /home/user</code>: 以长格式列出 <code>/home/user</code> 目录的内容。</li>\n<li><code>ls -ah</code>: 以人类可读格式显示当前目录所有文件（包括隐藏文件）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>cd</code></strong> (更改目录 Change directory)<ul>\n<li><strong>用途:</strong> 切换当前工作目录。 </li>\n<li><strong>语法:</strong> <code>cd [目录路径]</code> </li>\n<li>特殊用法:<ul>\n<li><code>cd..</code>: 切换到上一级目录。 </li>\n<li><code>cd ~</code> 或 <code>cd</code>: 切换到当前用户的主目录。 </li>\n<li><code>cd -</code>: 切换到上一个工作目录。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>cd /var/log</code>: 切换到 <code>/var/log</code> 目录。</li>\n<li><code>cd../documents</code>: 从当前目录切换到上一级的 <code>documents</code> 子目录。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>pwd</code></strong> (打印工作目录 Print working directory)<ul>\n<li><strong>用途:</strong> 显示当前所在的完整目录路径。 </li>\n<li><strong>语法:</strong> <code>pwd</code> </li>\n<li><strong>示例:</strong> <code>pwd</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-文件与目录操作-File-and-Directory-Operations\"><a href=\"#1-2-文件与目录操作-File-and-Directory-Operations\" class=\"headerlink\" title=\"1.2 文件与目录操作 (File and Directory Operations)\"></a>1.2 文件与目录操作 (File and Directory Operations)</h3><ul>\n<li><strong><code>mkdir</code></strong> (创建目录 Make directory)<ul>\n<li><strong>用途:</strong> 创建一个新的目录。 </li>\n<li><strong>语法:</strong> <code>mkdir [选项] 目录名</code> </li>\n<li>常用选项:<ul>\n<li><code>-p</code>: 递归创建目录，如果父目录不存在则一并创建。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>mkdir new_project</code>: 在当前目录下创建名为 <code>new_project</code> 的目录。</li>\n<li><code>mkdir -p project/docs/images</code>: 递归创建 <code>project</code> 目录及其子目录 <code>docs</code> 和 <code>images</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>rmdir</code></strong> (删除空目录 Remove empty directory)<ul>\n<li><strong>用途:</strong> 删除一个空的目录。 </li>\n<li><strong>语法:</strong> <code>rmdir [选项] 目录名</code> </li>\n<li>常用选项:<ul>\n<li><code>-p</code>: 递归删除目录，当子目录被删除后其父目录变为空时，也一同被删除。 </li>\n<li><code>--ignore-fail-on-non-empty</code>: 删除非空目录时忽略错误（通常不推荐，应使用 <code>rm -r</code>）。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>rmdir old_folder</code> (如果 <code>old_folder</code> 为空，则删除它)。</li>\n</ul>\n</li>\n<li><strong><code>cp</code></strong> (复制文件和目录 Copy files and directories)<ul>\n<li><strong>用途:</strong> 复制文件或目录。 </li>\n<li><strong>语法:</strong> <code>cp [选项] 源文件/目录 目标文件/目录</code> </li>\n<li>常用选项:<ul>\n<li><code>-r</code> 或 <code>-R</code>: 递归复制目录及其内容。 </li>\n<li><code>-i</code>: 覆盖前提示。 </li>\n<li><code>-v</code>: 显示详细的复制过程。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>cp file1.txt file1_backup.txt</code>: 将 <code>file1.txt</code> 复制为 <code>file1_backup.txt</code>。</li>\n<li><code>cp -r project_a/ /backup/project_a_backup</code>: 将 <code>project_a</code> 目录及其所有内容复制到 <code>/backup/project_a_backup</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>mv</code></strong> (移动或重命名文件和目录 Move or rename files and directories)<ul>\n<li><strong>用途:</strong> 移动文件或目录，或者在同一目录下对文件或目录进行重命名。 </li>\n<li><strong>语法:</strong> <code>mv [选项] 源文件/目录 目标文件/目录</code> </li>\n<li>常用选项:<ul>\n<li><code>-i</code>: 覆盖前提示。 </li>\n<li><code>-n</code>: 不覆盖已存在的目标文件。 </li>\n<li><code>-u</code>: 仅当源文件比目标文件新，或目标文件不存在时，才执行移动。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>mv report.docx documents/</code>: 将 <code>report.docx</code> 移动到 <code>documents</code> 目录。</li>\n<li><code>mv old_name.txt new_name.txt</code>: 将 <code>old_name.txt</code> 重命名为 <code>new_name.txt</code>。</li>\n<li><code>mv temp_folder /opt/archive/</code>: 将 <code>temp_folder</code> 目录移动到 <code>/opt/archive/</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>rm</code></strong> (删除文件或目录 Remove files or directories)<ul>\n<li><strong>用途:</strong> 删除文件或目录。这是一个非常强大的命令，使用时需格外小心。 </li>\n<li><strong>语法:</strong> <code>rm [选项] 文件/目录...</code> </li>\n<li>常用选项:<ul>\n<li><code>-r</code> 或 <code>-R</code>: 递归删除目录及其所有内容。 </li>\n<li><code>-f</code>: 强制删除，不进行提示，忽略不存在的文件和参数。 </li>\n<li><code>-i</code>: 删除前逐一提示确认。 </li>\n<li><code>-v</code>: 显示详细的删除过程。</li>\n</ul>\n</li>\n<li><strong>警告:</strong> <code>rm -rf</code> 命令会无提示地递归删除指定目录下的所有内容，一旦执行无法轻易恢复，务必谨慎使用。 </li>\n<li>示例:<ul>\n<li><code>rm unwanted_file.txt</code>: 删除 <code>unwanted_file.txt</code> 文件。</li>\n<li><code>rm -rf old_project/</code>: 强制递归删除 <code>old_project</code> 目录及其所有内容。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>touch</code></strong> (创建空文件或更新文件时间戳 Create empty file or update file timestamps)<ul>\n<li><strong>用途:</strong> 创建一个空文件，或者更新已有文件的时间戳（访问时间和修改时间）。 </li>\n<li><strong>语法:</strong> <code>touch [选项] 文件名...</code> </li>\n<li>示例:<ul>\n<li><code>touch newfile.log</code>: 创建一个名为 <code>newfile.log</code> 的空文件。</li>\n<li><code>touch existing_file.txt</code>: 更新 <code>existing_file.txt</code> 的时间戳。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>ln</code></strong> (创建链接 Create links)<ul>\n<li><strong>用途:</strong> 在文件之间创建链接，分为硬链接和符号链接（软链接）。 </li>\n<li><strong>语法:</strong> <code>ln [选项] 源文件 链接名</code> </li>\n<li>常用选项:<ul>\n<li><code>-s</code>: 创建符号链接（软链接）。如果不使用此选项，则创建硬链接。 </li>\n<li><code>-v</code>: 显示详细过程。</li>\n</ul>\n</li>\n<li>硬链接与符号链接的区别:<ul>\n<li>硬链接：与原文件共享相同的inode号和数据块，删除原文件不影响硬链接的访问，除非所有硬链接和原文件都被删除。不能对目录创建硬链接，不能跨文件系统创建硬链接。 </li>\n<li>符号链接：一个指向原文件路径的特殊文件，类似于快捷方式。删除原文件会导致符号链接失效。可以对目录创建符号链接，也可以跨文件系统创建。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>ln target.txt hard_link.txt</code>: 为 <code>target.txt</code> 创建一个名为 <code>hard_link.txt</code> 的硬链接。</li>\n<li><code>ln -s /opt/app/config.conf /etc/app_config.conf</code>: 为 <code>/opt/app/config.conf</code> 创建一个名为 <code>/etc/app_config.conf</code> 的符号链接。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-文件查找与类型判断-File-Searching-and-Type-Identification\"><a href=\"#1-3-文件查找与类型判断-File-Searching-and-Type-Identification\" class=\"headerlink\" title=\"1.3 文件查找与类型判断 (File Searching and Type Identification)\"></a>1.3 文件查找与类型判断 (File Searching and Type Identification)</h3><ul>\n<li><strong><code>find</code></strong> (在目录层次结构中查找文件 Search for files in a directory hierarchy)<ul>\n<li><strong>用途:</strong> 根据指定的条件在目录树中搜索文件和目录。 </li>\n<li><strong>语法:</strong> <code>find [路径...][表达式选项]</code> </li>\n<li>常用表达式选项:<ul>\n<li><code>-name \"模式\"</code>: 按文件名模式查找 (支持通配符, 如 <code>*.txt</code>)。 </li>\n<li><code>-type 类型</code>: 按文件类型查找 (如 <code>f</code> 普通文件, <code>d</code> 目录, <code>l</code> 符号链接)。 </li>\n<li><code>-user 用户名</code>: 按文件所有者查找。</li>\n<li><code>-group 组名</code>: 按文件所属组查找。</li>\n<li><code>-size [+|-]大小[cwbkMG]</code>: 按文件大小查找 (如 <code>+10M</code> 大于10MB, <code>-1k</code> 小于1KB)。</li>\n<li><code>-mtime [-|+]天数</code>: 按文件修改时间查找 (如 <code>-7</code> 7天内修改, <code>+30</code> 30天前修改)。</li>\n<li><code>-exec 命令 {} \\;</code>: 对找到的每个文件执行指定的命令。</li>\n<li><code>-maxdepth 层数</code>: 限制搜索深度。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>find /home/user -name \"*.log\" -mtime -7</code>: 在 <code>/home/user</code> 目录及其子目录下查找最近7天内修改过的所有 <code>.log</code> 文件。</li>\n<li><code>find. -type f -size +100M -exec rm {} \\;</code>: 查找当前目录下大于100MB的普通文件并删除它们（删除前会提示）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>file</code></strong> (判断文件类型 Determine file type)<ul>\n<li><strong>用途:</strong> 识别给定文件的类型。 </li>\n<li><strong>语法:</strong> <code>file [选项] 文件名...</code> </li>\n<li>常用选项:<ul>\n<li><code>-b</code> 或 <code>--brief</code>: 简要模式，不输出文件名。 </li>\n<li><code>-i</code>: 输出MIME类型字符串。 </li>\n<li><code>-z</code>: 尝试查看压缩文件内部。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>file document.pdf</code>: 显示 <code>document.pdf</code> 的文件类型。</li>\n<li><code>file -bi image.jpg</code>: 以MIME类型格式简要显示 <code>image.jpg</code> 的类型。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、系统信息与管理-System-Information-and-Management\"><a href=\"#二、系统信息与管理-System-Information-and-Management\" class=\"headerlink\" title=\"二、系统信息与管理 (System Information and Management)\"></a>二、系统信息与管理 (System Information and Management)</h2><p>了解系统的运行状态、硬件信息和基本配置是系统管理的重要组成部分。</p>\n<h3 id=\"2-1-系统基本信息-Basic-System-Information\"><a href=\"#2-1-系统基本信息-Basic-System-Information\" class=\"headerlink\" title=\"2.1 系统基本信息 (Basic System Information)\"></a>2.1 系统基本信息 (Basic System Information)</h3><ul>\n<li><strong><code>uname</code></strong> (打印系统信息 Print system information)<ul>\n<li><strong>用途:</strong> 显示当前系统的内核名称、版本、主机名等信息。 </li>\n<li><strong>语法:</strong> <code>uname [选项]</code> </li>\n<li>常用选项:<ul>\n<li><code>-a</code>: 显示所有可用信息。 </li>\n<li><code>-r</code>: 显示内核发行版本。 </li>\n<li><code>-s</code>: 显示内核名称。</li>\n<li><code>-n</code>: 显示网络节点主机名。</li>\n<li><code>-m</code>: 显示机器硬件名称。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>uname -a</code></li>\n</ul>\n</li>\n<li><strong><code>hostname</code></strong> (显示或设置系统的主机名 Show or set the system’s host name)<ul>\n<li><strong>用途:</strong> 查看或临时设置系统的主机名。 </li>\n<li><strong>语法:</strong> <code>hostname [选项][新主机名]</code> </li>\n<li>常用选项:<ul>\n<li><code>-s</code> 或 <code>--short</code>: 显示短主机名 (第一个点之前的部分)。 </li>\n<li><code>-f</code> 或 <code>--fqdn</code> 或 <code>--long</code>: 显示完全限定域名 (FQDN)。 </li>\n<li><code>-i</code> 或 <code>--ip-address</code>: 显示主机的IP地址 (如果可解析)。 </li>\n<li><code>-I</code> 或 <code>--all-ip-addresses</code>: 显示主机所有网络接口的IP地址。 </li>\n<li><code>-d</code> 或 <code>--domain</code>: 显示DNS域名。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>hostname</code>: 显示当前主机名。</li>\n<li><code>sudo hostname new-server-name</code>: 临时将主机名设置为 <code>new-server-name</code> (永久更改需修改配置文件，如 <code>/etc/hostname</code> )。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>date</code></strong> (打印或设置系统日期和时间 Print or set the system date and time)<ul>\n<li><strong>用途:</strong> 显示或设置系统的当前日期和时间。 </li>\n<li><strong>语法:</strong> <code>date [选项][+格式]YY][.ss]]</code></li>\n<li>常用选项与格式:<ul>\n<li><code>+%Y-%m-%d %H:%M:%S</code>: 以 <code>年-月-日 时:分:秒</code> 格式显示。</li>\n<li><code>--set=\"字符串\"</code>: 设置日期和时间。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>date</code>: 显示当前日期和时间。</li>\n<li><code>date '+%A, %B %d, %Y'</code>: 以 “星期几, 月份 日期, 年份” 格式显示。</li>\n<li><code>sudo date --set=\"2024-07-30 10:30:00\"</code>: 将日期和时间设置为2024年7月30日10点30分。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>uptime</code></strong> (告诉系统已运行多长时间 Tell how long the system has been running)<ul>\n<li><strong>用途:</strong> 显示系统自上次启动以来运行了多长时间、当前用户数量以及系统平均负载。 </li>\n<li><strong>语法:</strong> <code>uptime [选项]</code></li>\n<li>常用选项:<ul>\n<li><code>-p</code>: 以易读格式显示运行时间。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>uptime</code></li>\n</ul>\n</li>\n<li><strong><code>whoami</code></strong> (打印有效用户ID Print effective user ID)<ul>\n<li><strong>用途:</strong> 显示当前正在操作的用户名。 </li>\n<li><strong>语法:</strong> <code>whoami</code> </li>\n<li><strong>示例:</strong> <code>whoami</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-磁盘与内存使用-Disk-and-Memory-Usage\"><a href=\"#2-2-磁盘与内存使用-Disk-and-Memory-Usage\" class=\"headerlink\" title=\"2.2 磁盘与内存使用 (Disk and Memory Usage)\"></a>2.2 磁盘与内存使用 (Disk and Memory Usage)</h3><ul>\n<li><strong><code>df</code></strong> (报告文件系统磁盘空间使用情况 Report file system disk space usage)<ul>\n<li><strong>用途:</strong> 显示文件系统的总空间、已用空间、可用空间和挂载点。 </li>\n<li><strong>语法:</strong> <code>df [选项][文件/目录]</code> </li>\n<li>常用选项:<ul>\n<li><code>-h</code>: 以人类可读的格式显示 (例如 GB, MB)。 </li>\n<li><code>-T</code>: 显示文件系统类型。</li>\n<li><code>-i</code>: 显示inode信息而非块使用情况。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>df -h</code></li>\n</ul>\n</li>\n<li><strong><code>du</code></strong> (估算文件空间使用情况 Estimate file space usage)<ul>\n<li><strong>用途:</strong> 显示指定文件或目录占用的磁盘空间大小。 </li>\n<li><strong>语法:</strong> <code>du [选项][文件/目录]</code> </li>\n<li>常用选项:<ul>\n<li><code>-h</code>: 以人类可读的格式显示。 </li>\n<li><code>-s</code>: 仅显示总计大小。 </li>\n<li><code>-c</code>: 显示总计大小，并在最后显示所有参数的总和。</li>\n<li><code>--max-depth=N</code>: 只显示指定深度的目录大小。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>du -sh /var/log</code>: 显示 <code>/var/log</code> 目录的总大小。</li>\n<li><code>du -h --max-depth=1 /home</code>: 显示 <code>/home</code> 目录下第一级子目录和文件的大小。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>free</code></strong> (显示系统中的可用和已用物理内存和交换内存量 Display amount of free and used memory in the system)<ul>\n<li><strong>用途:</strong> 查看系统内存和交换空间的使用情况。 </li>\n<li><strong>语法:</strong> <code>free [选项]</code> </li>\n<li>常用选项:<ul>\n<li><code>-h</code>: 以人类可读的格式显示。 </li>\n<li><code>-m</code>: 以MB为单位显示。 </li>\n<li><code>-g</code>: 以GB为单位显示。</li>\n<li><code>-s N</code>: 每N秒刷新一次。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>free -h</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-系统控制-System-Control\"><a href=\"#2-3-系统控制-System-Control\" class=\"headerlink\" title=\"2.3 系统控制 (System Control)\"></a>2.3 系统控制 (System Control)</h3><ul>\n<li><strong><code>shutdown</code></strong> (关闭系统 Schedule a system shutdown)<ul>\n<li><strong>用途:</strong> 安全地关闭或重启Linux系统，可以指定延迟时间或特定时间，并向登录用户发送警告信息。 </li>\n<li><strong>语法:</strong> <code>sudo shutdown [选项] 时间 [警告信息]</code> </li>\n<li>常用选项:<ul>\n<li><code>-h</code>: 关闭系统后停止电源 (halt)。 </li>\n<li><code>-P</code>: 关闭系统后切断电源 (power off)，通常是 <code>-h</code> 的默认行为。 </li>\n<li><code>-r</code>: 重启系统。 </li>\n<li><code>-c</code>: 取消先前安排的关机。 </li>\n<li><code>-k</code>: 发送警告信息，但不实际关机。</li>\n</ul>\n</li>\n<li>时间参数:<ul>\n<li><code>now</code>: 立刻执行。 </li>\n<li><code>+分钟数</code>: 指定多少分钟后执行 (例如 <code>+10</code>)。 </li>\n<li><code>hh:mm</code>: 指定绝对时间执行 (例如 <code>23:00</code>)。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>sudo shutdown -h now</code>: 立刻关闭系统。</li>\n<li><code>sudo shutdown -r +15 \"系统将在15分钟后重启以进行维护\"</code>: 15分钟后重启系统并发送消息。</li>\n<li><code>sudo shutdown -c</code>: 取消已计划的关机或重启。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>reboot</code></strong> (重启系统 Reboot the system)<ul>\n<li><strong>用途:</strong> 重启Linux系统。通常是 <code>shutdown -r now</code> 的一个快捷方式。 </li>\n<li><strong>语法:</strong> <code>sudo reboot [选项]</code> </li>\n<li>常用选项:<ul>\n<li><code>-f</code>: 强制重启，不调用 <code>shutdown</code>。不推荐常规使用。 </li>\n<li><code>-p</code>: 关闭电源（如果系统支持）。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>sudo reboot</code></li>\n</ul>\n</li>\n<li><strong><code>history</code></strong> (显示或操作历史列表 Display or manipulate the history list)<ul>\n<li><strong>用途:</strong> 显示用户在当前shell会话中执行过的命令历史。 </li>\n<li><strong>语法:</strong> <code>history [选项][数量]</code></li>\n<li>常用选项:<ul>\n<li><code>-c</code>: 清空历史列表。 </li>\n<li><code>-d 偏移量</code>: 删除指定偏移量的历史条目。</li>\n</ul>\n</li>\n<li>特殊用法:<ul>\n<li><code>!!</code>: 执行上一条命令。 </li>\n<li><code>!编号</code>: 执行历史列表中指定编号的命令。 </li>\n<li><code>!字符串</code>: 执行最近一条以指定字符串开头的命令。 </li>\n<li><code>Ctrl+R</code>: 反向搜索历史命令。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>history</code>: 显示所有命令历史。</li>\n<li><code>history 20</code>: 显示最近20条命令历史。</li>\n<li><code>!ls</code>: 执行最近一条以 <code>ls</code> 开头的命令。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>man</code></strong> (系统参考手册的分页程序 an interface to the on-line reference manuals)<ul>\n<li><strong>用途:</strong> 显示命令、函数或配置文件的帮助手册页。 </li>\n<li><strong>语法:</strong> <code>man [选项][章节] 命令名/主题</code></li>\n<li>常用选项:<ul>\n<li><code>-k 关键字</code>: 根据关键字搜索手册页标题和描述 (等同于 <code>apropos</code>)。</li>\n</ul>\n</li>\n<li><strong>导航:</strong> 在 <code>man</code> 页面中，通常使用与 <code>less</code> 相同的导航键（如空格翻页，<code>q</code> 退出，<code>/</code> 搜索）。 </li>\n<li>示例:<ul>\n<li><code>man ls</code>: 显示 <code>ls</code> 命令的手册页。</li>\n<li><code>man 5 passwd</code>: 显示 <code>/etc/passwd</code> 文件格式的手册页 (第5章节通常是文件格式)。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>clear</code></strong> (清屏 Clear the terminal screen)<ul>\n<li><strong>用途:</strong> 清除终端屏幕上的所有内容，将提示符移到屏幕顶部。 </li>\n<li><strong>语法:</strong> <code>clear</code></li>\n<li><strong>示例:</strong> <code>clear</code> (快捷键通常是 <code>Ctrl+L</code></li>\n</ul>\n</li>\n<li><strong><code>alias</code></strong> (定义或显示别名 Define or display aliases)<ul>\n<li><strong>用途:</strong> 为长命令或常用命令序列创建简短的别名。 </li>\n<li>语法:<ul>\n<li><code>alias</code>: 显示所有已定义的别名。 </li>\n<li><code>alias 名称='命令'</code> : 定义一个别名。 </li>\n<li><code>unalias 名称</code>: 删除一个别名。</li>\n</ul>\n</li>\n<li><strong>持久化:</strong> 临时定义的别名只在当前shell会话有效。要使其永久生效，需将其添加到shell的配置文件中，如 <code>~/.bashrc</code> 或 <code>~/.bash_aliases</code>。 </li>\n<li>示例:<ul>\n<li><code>alias ll='ls -alF'</code>: 定义 <code>ll</code> 作为 <code>ls -alF</code> 的别名。</li>\n<li><code>alias update='sudo apt update &amp;&amp; sudo apt upgrade -y'</code>: 定义 <code>update</code> 用于更新系统。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三、高级系统监控-Advanced-System-Monitoring\"><a href=\"#三、高级系统监控-Advanced-System-Monitoring\" class=\"headerlink\" title=\"三、高级系统监控 (Advanced System Monitoring)\"></a>三、高级系统监控 (Advanced System Monitoring)</h2><p>除了基本的系统信息查看，Linux还提供了一系列高级工具，用于深入监控系统性能的各个方面，如CPU、内存、I/O和网络活动。</p>\n<h3 id=\"3-1-进程管理与监控-Process-Management-and-Monitoring\"><a href=\"#3-1-进程管理与监控-Process-Management-and-Monitoring\" class=\"headerlink\" title=\"3.1 进程管理与监控 (Process Management and Monitoring)\"></a>3.1 进程管理与监控 (Process Management and Monitoring)</h3><ul>\n<li><strong><code>ps</code></strong> (报告当前进程的快照 Report a snapshot of the current processes)<ul>\n<li><strong>用途:</strong> 显示当前系统中正在运行的进程信息。 </li>\n<li><strong>语法:</strong> <code>ps [选项]</code> </li>\n<li>常用选项:<ul>\n<li><code>aux</code>: 显示所有用户的进程（System V风格，无 <code>-</code>）。 </li>\n<li><code>-ef</code>: 显示所有进程，以完整格式（BSD风格，有 <code>-</code>）。 </li>\n<li><code>-u 用户名</code>: 显示指定用户的进程。 </li>\n<li><code>--forest</code>: 以ASCII字符显示进程树。 </li>\n<li><code>--sort=关键字</code>: 按指定关键字排序 (例如 <code>%cpu</code>, <code>%mem</code>)。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>ps aux</code>: 显示系统中所有正在运行的进程的详细信息。</li>\n<li><code>ps -ef | grep sshd</code>: 查找名为 <code>sshd</code> 的进程。 </li>\n<li><code>ps aux --sort=-%mem | head -n 5</code>: 显示内存使用率最高的5个进程。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>top</code></strong> (显示Linux进程 Display Linux processes)<ul>\n<li><strong>用途:</strong> 实时动态地显示系统中各个进程的资源占用状况，如CPU使用率、内存使用率等，默认按CPU使用率排序。 </li>\n<li><strong>语法:</strong> <code>top [选项]</code> </li>\n<li>交互命令 (在 <code>top</code> 运行时):<ul>\n<li><code>P</code>: 按CPU使用百分比排序。</li>\n<li><code>M</code>: 按内存使用百分比排序。</li>\n<li><code>N</code>: 按进程ID (PID) 排序。</li>\n<li><code>k</code>: 杀死一个进程 (需要输入PID和信号，默认为15 SIGTERM)。</li>\n<li><code>r</code>: 重新设置一个进程的nice值 (优先级)。</li>\n<li><code>h</code> 或 <code>?</code>: 显示帮助。 </li>\n<li><code>q</code>: 退出 <code>top</code>。 </li>\n<li><code>d</code>: 改变刷新延迟时间。</li>\n</ul>\n</li>\n<li>常用选项:<ul>\n<li><code>-d 秒数</code>: 设置屏幕刷新间隔。 </li>\n<li><code>-n 次数</code>: 刷新指定次数后退出。 </li>\n<li><code>-b</code>: 批处理模式，适合将输出重定向到文件。 </li>\n<li><code>-o +列名</code>: 按指定列排序 (如 <code>+%MEM</code> 按内存排序)。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>top</code> (启动实时监控)</li>\n</ul>\n</li>\n<li><strong><code>htop</code></strong> (交互式进程查看器 Interactive process viewer)<ul>\n<li><strong>用途:</strong> <code>top</code> 的增强版，提供更友好的交互界面、颜色显示、鼠标支持、水平/垂直滚动以及完整的命令行显示。 </li>\n<li><strong>语法:</strong> <code>htop [选项]</code> </li>\n<li>常用选项:<ul>\n<li><code>-d 延迟</code>: 设置更新之间的延迟（单位为十分之一秒，例如 <code>-d 10</code> 表示1秒）。 </li>\n<li><code>-u 用户名</code>: 只显示指定用户的进程。 </li>\n<li><code>-s 列名</code>: 按指定列排序 (例如 <code>-s PERCENT_MEM</code>)。 </li>\n<li><code>-t</code>: 以树状视图显示进程层级关系。</li>\n</ul>\n</li>\n<li>交互命令 (在 <code>htop</code> 运行时):<ul>\n<li><code>F4</code> (或 <code>\\</code>): 过滤进程。 </li>\n<li><code>F5</code> (或 <code>t</code>): 切换树状视图。 </li>\n<li><code>F6</code> (或 <code>&lt;</code> <code>&gt;</code>): 选择排序字段。 </li>\n<li><code>F9</code> (或 <code>k</code>): 杀死选中的进程。 </li>\n<li><code>F10</code> (或 <code>q</code>): 退出 <code>htop</code>。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>htop</code></li>\n</ul>\n</li>\n<li><strong><code>kill</code></strong> (向进程发送信号 Send a signal to a process)<ul>\n<li><strong>用途:</strong> 向指定的进程发送信号，常用于终止进程。 </li>\n<li><strong>语法:</strong> <code>kill [选项] PID...</code> </li>\n<li>常用信号:<ul>\n<li><code>SIGTERM</code> (15): 默认信号，请求进程正常终止。</li>\n<li><code>SIGKILL</code> (9): 强制终止进程，进程无法捕获此信号。 </li>\n<li><code>SIGHUP</code> (1): 挂起进程，常用于让守护进程重新读取配置文件。 </li>\n<li><code>SIGINT</code> (2): 中断进程，等同于 <code>Ctrl+C</code>。</li>\n</ul>\n</li>\n<li>常用选项:<ul>\n<li><code>-l</code>: 列出所有可用的信号名称。 </li>\n<li><code>-信号编号或名称</code>: 指定要发送的信号 (例如 <code>-9</code> 或 <code>-SIGKILL</code>)。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>kill 12345</code>: 向PID为12345的进程发送 <code>SIGTERM</code> 信号。</li>\n<li><code>kill -9 54321</code>: 强制杀死PID为54321的进程。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>pkill</code></strong> (根据名称和其他属性查找或发信号给进程 Signal processes based on name and other attributes)<ul>\n<li><strong>用途:</strong> 根据进程名或其他属性向进程发送信号，通常用于终止进程。 </li>\n<li><strong>语法:</strong> <code>pkill [选项] 模式</code></li>\n<li>常用选项:<ul>\n<li><code>-信号</code>: 指定要发送的信号 (例如 <code>-9</code>)。</li>\n<li><code>-u 用户名</code>: 匹配指定用户的进程。</li>\n<li><code>-f</code>: 匹配完整命令行参数。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>pkill firefox</code>: 终止所有名为 <code>firefox</code> 的进程。 </li>\n<li><code>pkill -9 -f \"stale_script.py\"</code>: 强制杀死完整命令行包含 “stale_script.py” 的进程。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>jobs</code></strong> (列出活动作业 List active jobs)<ul>\n<li><strong>用途:</strong> 显示在当前shell会话中放到后台运行或被挂起的作业。 </li>\n<li><strong>语法:</strong> <code>jobs [选项]</code> </li>\n<li>常用选项:<ul>\n<li><code>-l</code>: 同时显示作业的进程ID (PID)。 </li>\n<li><code>-p</code>: 只显示作业的进程ID。 </li>\n<li><code>-r</code>: 只显示正在运行的作业。 </li>\n<li><code>-s</code>: 只显示已停止（挂起）的作业。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>jobs -l</code></li>\n</ul>\n</li>\n<li><strong><code>bg</code></strong> (将作业放到后台运行 Resume suspended jobs in the background)<ul>\n<li><strong>用途:</strong> 将一个已挂起（stopped）的作业转到后台继续运行。 </li>\n<li><strong>语法:</strong> <code>bg</code> 51 (作业ID可通过 <code>jobs</code> 命令查看，通常以 <code>%</code> 开头，如 <code>%1</code>)</li>\n<li><strong>示例:</strong> <code>bg %1</code> (将作业号为1的挂起作业转到后台运行)</li>\n</ul>\n</li>\n<li><strong><code>fg</code></strong> (将作业放到前台运行 Resume jobs in the foreground)<ul>\n<li><strong>用途:</strong> 将一个在后台运行或已挂起的作业转到前台继续运行。 </li>\n<li><strong>语法:</strong> <code>fg</code> </li>\n<li><strong>示例:</strong> <code>fg %2</code> (将作业号为2的作业转到前台运行)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-2-系统性能分析-System-Performance-Analysis\"><a href=\"#3-2-系统性能分析-System-Performance-Analysis\" class=\"headerlink\" title=\"3.2 系统性能分析 (System Performance Analysis)\"></a>3.2 系统性能分析 (System Performance Analysis)</h3><ul>\n<li><p><strong><code>vmstat</code></strong> (报告虚拟内存统计信息 Report virtual memory statistics)</p>\n<ul>\n<li><p><strong>用途:</strong> 显示关于进程、内存、分页、块I/O、陷阱和CPU活动的即时信息。 </p>\n</li>\n<li><p><strong>语法:</strong> <code>vmstat [选项][延迟 [次数]]</code> </p>\n</li>\n<li><p>常用选项:</p>\n<ul>\n<li><code>-a</code>: 显示活动/非活动内存。 </li>\n<li><code>-s</code>: 显示各种事件计数器和内存统计信息的表格。 </li>\n<li><code>-d</code>: 显示磁盘统计信息。 </li>\n<li><code>-p 分区</code>: 显示指定分区的详细统计信息。 </li>\n<li><code>-t</code>: 在输出中添加时间戳。 </li>\n<li><code>延迟 次数</code>: 每隔“延迟”秒输出一次报告，共输出“次数”次。</li>\n</ul>\n</li>\n<li><p>输出字段解释:</p>\n<ul>\n<li><code>procs</code>: <code>r</code> (等待运行的进程数), <code>b</code> (不可中断睡眠的进程数)。</li>\n<li><code>memory</code>: <code>swpd</code> (使用的虚拟内存), <code>free</code> (空闲物理内存), <code>buff</code> (用作缓冲的内存), <code>cache</code> (用作缓存的内存)。</li>\n<li><code>swap</code>: <code>si</code> (从磁盘换入的内存量/秒), <code>so</code> (换出到磁盘的内存量/秒)。</li>\n<li><code>io</code>: <code>bi</code> (从块设备接收到的块数/秒), <code>bo</code> (发送到块设备的块数/秒)。</li>\n<li><code>system</code>: <code>in</code> (每秒中断次数), <code>cs</code> (每秒上下文切换次数)。</li>\n<li><code>cpu</code>: <code>us</code> (用户CPU时间百分比), <code>sy</code> (系统CPU时间百分比), <code>id</code> (空闲CPU时间百分比), <code>wa</code> (等待I/O的CPU时间百分比), <code>st</code> (从虚拟机窃取的CPU时间百分比)。</li>\n</ul>\n</li>\n<li><p>示例:</p>\n<ul>\n<li><code>vmstat 2 5</code>: 每2秒显示一次系统状态，共显示5次。</li>\n<li><code>vmstat -s</code>: 显示内存和事件计数器摘要。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>iostat</code></strong> (报告CPU统计信息和输入/输出统计信息 Report Central Processing Unit (CPU) statistics and input/output statistics for devices and partitions)</p>\n<ul>\n<li><p><strong>用途:</strong> 监控系统输入/输出设备和CPU的活动情况，用于识别磁盘或CPU瓶颈。 </p>\n</li>\n<li><p><strong>语法:</strong> <code>iostat [选项][间隔 [次数]]</code> </p>\n</li>\n<li><p>常用选项:</p>\n<ul>\n<li><code>-c</code>: 仅显示CPU利用率报告。 </li>\n<li><code>-d</code>: 仅显示设备利用率报告。 </li>\n<li><code>-x</code>: 显示扩展的I/O统计信息。 </li>\n<li><code>-k</code>: 以KB为单位显示统计信息。 </li>\n<li><code>-m</code>: 以MB为单位显示统计信息。 </li>\n<li><code>-t</code>: 打印每个报告的时间。 </li>\n<li><code>-p [设备 | ALL]</code>: 显示块设备及其所有分区的统计信息。 </li>\n<li><code>间隔 次数</code>: 每隔“间隔”秒输出一次报告，共输出“次数”次。</li>\n</ul>\n</li>\n<li><p>输出字段解释 (部分):</p>\n<ul>\n<li><code>%user</code>: 用户级别CPU利用率。</li>\n<li><code>%system</code>: 系统级别CPU利用率。</li>\n<li><code>%iowait</code>: CPU等待I/O操作完成的时间百分比。高 <code>%iowait</code> 通常表示I/O瓶颈。 </li>\n<li><code>%idle</code>: CPU空闲时间百分比。</li>\n<li><code>tps</code>: 每秒传输次数。</li>\n<li><code>Blk_read/s</code> (或 <code>kB_read/s</code>, <code>MB_read/s</code>): 每秒读取的块/KB/MB数。</li>\n<li><code>Blk_wrtn/s</code> (或 <code>kB_wrtn/s</code>, <code>MB_wrtn/s</code>): 每秒写入的块/KB/MB数。</li>\n<li><code>%util</code>: 存储设备繁忙的时间百分比。</li>\n</ul>\n</li>\n<li><p>示例:</p>\n<ul>\n<li><code>iostat -dx 2 5</code>: 每2秒显示一次扩展的磁盘I/O统计信息，共显示5次。</li>\n<li><code>iostat -c 1</code>: 每1秒显示一次CPU利用率。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>sar</code></strong> (收集、报告或保存系统活动信息 Collect, report, or save system activity information)</p>\n<ul>\n<li><strong>用途:</strong> System Activity Reporter，一个强大的系统性能分析工具，可以收集和报告CPU、内存、I/O、网络等多种系统活动的统计数据，支持历史数据分析。 </li>\n<li><strong>安装:</strong> <code>sar</code> 通常包含在 <code>sysstat</code> 包中，可能需要手动安装: <code>sudo apt-get install sysstat</code> 或 <code>sudo yum install sysstat</code>。 </li>\n<li><strong>语法:</strong> <code>sar [选项][间隔 [次数]]</code> </li>\n<li>常用选项:<ul>\n<li><code>-u</code>: 显示CPU利用率。 </li>\n<li><code>-r</code>: 显示内存利用率。 </li>\n<li><code>-b</code>: 显示I/O和传输速率统计。 </li>\n<li><code>-d</code>: 显示块设备（磁盘）活动。 </li>\n<li><code>-n DEV | EDEV |...</code>: 显示网络统计信息 (<code>DEV</code> 为网络接口，<code>EDEV</code> 为网络错误)。 </li>\n<li><code>-q</code>: 显示运行队列长度和平均负载。 </li>\n<li><code>-P ALL | CPU号</code>: 报告每个处理器的统计信息。</li>\n<li><code>-o 文件名</code>: 将数据保存到二进制文件。 </li>\n<li><code>-f 文件名</code>: 从指定文件读取数据。 </li>\n<li><code>间隔 次数</code>: 每隔“间隔”秒输出一次报告，共输出“次数”次。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>sar -u 2 5</code>: 每2秒显示一次CPU利用率，共显示5次。 </li>\n<li><code>sar -r 1 3</code>: 每1秒显示一次内存利用率，共显示3次。 </li>\n<li><code>sar -n DEV 1</code>: 每1秒显示一次网络接口统计。 </li>\n<li><code>sar -f /var/log/sa/saDD</code> (其中DD为日期): 查看历史系统活动报告。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>lsof</code></strong> (列出打开的文件 List open files)</p>\n<ul>\n<li><p><strong>用途:</strong> 显示系统中所有进程打开的文件列表。在Linux中，“一切皆文件”，因此 <code>lsof</code> 可以显示打开的普通文件、目录、网络套接字、设备等。 </p>\n</li>\n<li><p><strong>语法:</strong> <code>lsof [选项][文件名]</code> </p>\n</li>\n<li><p>常用选项:</p>\n<ul>\n<li><p><code>-i [条件]</code>: 显示符合条件的网络连接。例如:</p>\n<ul>\n<li><code>-i TCP:22</code>: 显示监听或连接到TCP端口22的进程。 </li>\n<li><code>-i :80</code>: 显示监听或连接到端口80的进程。</li>\n<li><code>-i @主机名/IP</code>: 显示与指定主机相关的连接。</li>\n</ul>\n</li>\n<li><p><code>-u 用户名</code>: 显示指定用户打开的文件。 </p>\n</li>\n<li><p><code>-p PID</code>: 显示指定进程ID打开的文件。 </p>\n</li>\n<li><p><code>-c 命令名</code>: 显示由指定命令名开头的进程打开的文件。 </p>\n</li>\n<li><p><code>+D 目录</code>: 递归显示目录下被打开的文件。 </p>\n</li>\n<li><p><code>-t</code>: 只输出进程ID (PID)，常用于与其他命令结合。</p>\n</li>\n</ul>\n</li>\n<li><p>示例:</p>\n<ul>\n<li><code>sudo lsof -i :80</code>: 查看哪些进程正在使用80端口。</li>\n<li><code>sudo lsof -u apache</code>: 查看用户 <code>apache</code> 打开了哪些文件。</li>\n<li><code>sudo lsof /var/log/syslog</code>: 查看哪个进程打开了 <code>/var/log/syslog</code> 文件。</li>\n<li><code>sudo lsof -p 1234</code>: 查看PID为1234的进程打开了哪些文件。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"四、文本处理-Text-Processing\"><a href=\"#四、文本处理-Text-Processing\" class=\"headerlink\" title=\"四、文本处理 (Text Processing)\"></a>四、文本处理 (Text Processing)</h2><p>Linux 提供了大量强大的文本处理工具，用于查看、搜索、编辑和分析文本文件。</p>\n<h3 id=\"4-1-文件内容查看-Viewing-File-Contents\"><a href=\"#4-1-文件内容查看-Viewing-File-Contents\" class=\"headerlink\" title=\"4.1 文件内容查看 (Viewing File Contents)\"></a>4.1 文件内容查看 (Viewing File Contents)</h3><ul>\n<li><strong><code>cat</code></strong> (连接文件并打印到标准输出 Concatenate files and print on the standard output)<ul>\n<li><strong>用途:</strong> 显示一个或多个文件的全部内容，也可用于创建或合并文件。 </li>\n<li><strong>语法:</strong> <code>cat [选项][文件...]</code> </li>\n<li>常用选项:<ul>\n<li><code>-n</code>: 显示行号。 </li>\n<li><code>-E</code>: 在每行末尾显示 <code>$</code> 符号。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>cat myfile.txt</code>: 显示 <code>myfile.txt</code> 的内容。</li>\n<li><code>cat file1.txt file2.txt &gt; combined.txt</code>: 合并 <code>file1.txt</code> 和 <code>file2.txt</code> 的内容到 <code>combined.txt</code>。</li>\n<li><code>cat -n script.sh</code>: 显示 <code>script.sh</code> 的内容并带行号。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>less</code></strong> (与 <code>more</code> 功能相反，但功能更强大 Opposite of more, but with more features)<ul>\n<li><strong>用途:</strong> 分页查看文件内容，允许向前和向后滚动，支持搜索。比 <code>cat</code> 更适合查看大文件。 </li>\n<li><strong>语法:</strong> <code>less [选项] 文件名</code> </li>\n<li>常用选项:<ul>\n<li><code>-N</code>: 显示行号。 </li>\n<li><code>-S</code>: 禁止长行自动换行 (内容超出屏幕宽度时可水平滚动)。 </li>\n<li><code>-i</code>: 搜索时忽略大小写。 </li>\n<li><code>-F</code>: 如果内容能在一屏内显示完则自动退出。 </li>\n<li><code>-X</code>: 退出 <code>less</code> 后不清屏。</li>\n</ul>\n</li>\n<li>交互命令 (在 <code>less</code> 运行时):<ul>\n<li>空格键 或 <code>f</code>: 向下翻一页。 </li>\n<li><code>b</code>: 向上翻一页。 </li>\n<li><code>j</code> 或 向下箭头: 向下滚动一行。 </li>\n<li><code>k</code> 或 向上箭头: 向上滚动一行。 </li>\n<li><code>G</code>: 跳转到文件末尾。 </li>\n<li><code>g</code>: 跳转到文件开头。 </li>\n<li><code>/模式</code>: 向下搜索指定模式。 </li>\n<li><code>?模式</code>: 向上搜索指定模式。 </li>\n<li><code>n</code>: 重复上一次搜索 (同方向)。 </li>\n<li><code>N</code>: 重复上一次搜索 (反方向)。 </li>\n<li><code>q</code>: 退出 <code>less</code>。 </li>\n<li><code>h</code>: 显示帮助。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>less large_log_file.log</code>: 查看 <code>large_log_file.log</code>。</li>\n<li><code>dmesg | less -N</code>: 分页显示内核环形缓冲区消息并带行号。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>head</code></strong> (输出文件的第一部分 Output the first part of files)<ul>\n<li><strong>用途:</strong> 显示文件的开头部分，默认显示前10行。 </li>\n<li><strong>语法:</strong> <code>head [选项][文件...]</code> </li>\n<li>常用选项:<ul>\n<li><code>-n 数字</code> 或 <code>-数字</code>: 指定显示的行数。 </li>\n<li><code>-c 字节数</code>: 指定显示的字节数。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>head access.log</code>: 显示 <code>access.log</code> 的前10行。</li>\n<li><code>head -n 20 error.log</code>: 显示 <code>error.log</code> 的前20行。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>tail</code></strong> (输出文件的最后一部分 Output the last part of files)<ul>\n<li><strong>用途:</strong> 显示文件的末尾部分，默认显示最后10行。常用于监控实时更新的日志文件。 </li>\n<li><strong>语法:</strong> <code>tail [选项][文件...]</code> </li>\n<li>常用选项:<ul>\n<li><code>-n 数字</code> 或 <code>-数字</code>: 指定显示的行数。 </li>\n<li><code>-c 字节数</code>: 指定显示的字节数。</li>\n<li><code>-f</code>: 持续显示文件末尾追加的内容，直到按 <code>Ctrl+C</code> 终止。非常适用于实时日志监控。 </li>\n<li><code>-n +数字</code>: 从第几行开始显示到文件末尾。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>tail messages.log</code>: 显示 <code>messages.log</code> 的最后10行。</li>\n<li><code>tail -n 50 system.log</code>: 显示 <code>system.log</code> 的最后50行。</li>\n<li><code>tail -f /var/log/syslog</code>: 实时监控 <code>/var/log/syslog</code> 文件的新增内容。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-2-文本搜索与模式匹配-Text-Searching-and-Pattern-Matching\"><a href=\"#4-2-文本搜索与模式匹配-Text-Searching-and-Pattern-Matching\" class=\"headerlink\" title=\"4.2 文本搜索与模式匹配 (Text Searching and Pattern Matching)\"></a>4.2 文本搜索与模式匹配 (Text Searching and Pattern Matching)</h3><ul>\n<li><p><code>grep</code></p>\n<p> (打印匹配模式的行 Print lines matching a pattern)</p>\n<ul>\n<li><strong>用途:</strong> 在文件中搜索包含指定模式（字符串或正则表达式）的行，并打印这些行。 </li>\n<li><strong>语法:</strong> <code>grep [选项] 模式 [文件...]</code> </li>\n<li>常用选项:<ul>\n<li><code>-i</code>: 忽略模式和输入数据的大小写。 </li>\n<li><code>-v</code>: 反向匹配，打印不包含模式的行。 </li>\n<li><code>-r</code> 或 <code>-R</code>: 递归搜索目录下的所有文件。 </li>\n<li><code>-n</code>: 显示匹配行的行号。 </li>\n<li><code>-c</code>: 只打印匹配行的计数。 </li>\n<li><code>-l</code>: 只打印包含匹配模式的文件名。 </li>\n<li><code>-w</code>: 整词匹配。 </li>\n<li><code>-E</code>: 使用扩展正则表达式 (ERE)。</li>\n<li><code>-A 数字</code>: 打印匹配行及其后N行。 </li>\n<li><code>-B 数字</code>: 打印匹配行及其前N行。 </li>\n<li><code>-C 数字</code>: 打印匹配行及其前后各N行。 </li>\n<li><code>-e 模式</code>: 指定多个搜索模式。 </li>\n<li><code>-o</code>: 只显示匹配模式的部分。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>grep \"error\" application.log</code>: 在 <code>application.log</code> 中搜索包含 “error” 的行。</li>\n<li><code>grep -i \"warning\" /var/log/messages</code>: 在 <code>/var/log/messages</code> 中不区分大小写地搜索 “warning”。 </li>\n<li><code>grep -r \"config_value\" /etc/myapp/</code>: 递归搜索 <code>/etc/myapp/</code> 目录中包含 “config_value” 的文件。 </li>\n<li><code>ps aux | grep -v \"grep\"</code>: 显示进程列表，但不显示 <code>grep</code> 命令本身。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-3-文本编辑与转换-Text-Editing-and-Transformation\"><a href=\"#4-3-文本编辑与转换-Text-Editing-and-Transformation\" class=\"headerlink\" title=\"4.3 文本编辑与转换 (Text Editing and Transformation)\"></a>4.3 文本编辑与转换 (Text Editing and Transformation)</h3><ul>\n<li><p><strong><code>sed</code></strong> (流编辑器，用于对输入流执行基本文本转换 Stream editor for performing basic text transformations on an input stream)</p>\n<ul>\n<li><p><strong>用途:</strong> 一个强大的流编辑器，用于对文件或输入流进行非交互式的文本替换、删除、插入、转换等操作。 </p>\n</li>\n<li><p><strong>语法:</strong> <code>sed [选项] '脚本' [输入文件...]</code> </p>\n</li>\n<li><p>常用选项:</p>\n<ul>\n<li><code>-i[后缀]</code>: 直接修改文件内容 (如果提供后缀，则创建备份)。 </li>\n<li><code>-n</code>: 禁止自动打印模式空间的内容，通常与 <code>p</code> 命令配合使用。 </li>\n<li><code>-e 脚本</code>: 添加要执行的脚本。允许多个 <code>-e</code> 来执行多个命令。 </li>\n<li><code>-f 脚本文件</code>: 从脚本文件中读取 <code>sed</code> 命令。 </li>\n<li><code>-r</code> 或 <code>-E</code>: 使用扩展正则表达式。</li>\n</ul>\n</li>\n<li><p>常用命令 (在脚本中):</p>\n<ul>\n<li><p><code>s/旧模式/新模式/[标志]</code>: 替换 (substitute)。标志可以是：</p>\n<ul>\n<li><code>g</code>: 全局替换行内所有匹配。 </li>\n<li><code>N</code>: 替换第N个匹配项。 </li>\n<li><code>I</code> 或 <code>i</code>: 忽略大小写。</li>\n</ul>\n</li>\n<li><p><code>d</code>: 删除匹配的行。 </p>\n</li>\n<li><p><code>p</code>: 打印模式空间的内容 (通常与 <code>-n</code> 选项一起使用)。 </p>\n</li>\n<li><p><code>a\\文本</code>: 在匹配行之后追加文本。</p>\n</li>\n<li><p><code>i\\文本</code>: 在匹配行之前插入文本。</p>\n</li>\n<li><p><code>c\\文本</code>: 用文本替换匹配的行。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>地址 (指定命令作用的行):</strong> 可以是行号、正则表达式、或行号范围 (如 <code>1,5</code> 表示第1到5行；<code>/pattern/</code> 表示匹配模式的行)。 </p>\n</li>\n<li><p>示例:</p>\n<ul>\n<li><code>sed 's/apple/orange/g' fruit.txt</code>: 将 <code>fruit.txt</code> 中所有的 “apple” 替换为 “orange” 并输出到标准输出。</li>\n<li><code>sed -i 's/old_domain.com/new_domain.com/g' config.file</code>: 直接修改 <code>config.file</code>，将其中的 “old_domain.com” 全部替换为 “new_domain.com”。</li>\n<li><code>sed -n '/error/p' server.log</code>: 只打印 <code>server.log</code> 中包含 “error” 的行。</li>\n<li><code>sed '1,5d' data.txt</code>: 删除 <code>data.txt</code> 文件的前5行。 </li>\n<li><code>sed '/^#/d' config.conf</code>: 删除 <code>config.conf</code> 中所有以 <code>#</code> 开头的注释行。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>awk</code></strong> (模式扫描和处理语言 Pattern scanning and processing language)</p>\n<ul>\n<li><strong>用途:</strong> 一种强大的文本处理编程语言，非常适合处理结构化数据（如按列分隔的数据）、生成报告和执行复杂的文本操作。 </li>\n<li><strong>语法:</strong> <code>awk '[选项] '模式 {动作}' [输入文件...]'</code> </li>\n<li>核心概念:<ul>\n<li>记录 (Record): <code>awk</code> 逐行处理输入，每行被视为一个记录，默认记录分隔符是换行符。</li>\n<li>字段 (Field): 每个记录被进一步分解为字段，默认字段分隔符是空格或制表符。字段可以用 <code>$1</code>, <code>$2</code>,… <code>$NF</code> (最后一个字段) 表示，<code>$0</code> 表示整个记录。 </li>\n<li>模式 (Pattern): 在执行动作之前检查的条件。可以是正则表达式、比较表达式等。如果省略模式，则对每一行都执行动作。 </li>\n<li>动作 (Action): 由花括号 <code>{}</code> 包围的一系列命令。 </li>\n<li><code>BEGIN</code> 块: 在处理任何输入行之前执行一次。 </li>\n<li><code>END</code> 块: 在处理完所有输入行之后执行一次。</li>\n</ul>\n</li>\n<li>常用选项:<ul>\n<li><code>-F 分隔符</code>: 指定输入字段分隔符。 </li>\n<li><code>-v 变量=值</code>: 定义 <code>awk</code> 脚本中可以使用的变量。 </li>\n<li><code>-f 程序文件</code>: 从文件中读取 <code>awk</code> 程序。</li>\n</ul>\n</li>\n<li>内置变量:<ul>\n<li><code>FS</code>: 输入字段分隔符 (同 <code>-F</code> 选项)。</li>\n<li><code>OFS</code>: 输出字段分隔符 (默认为空格)。 </li>\n<li><code>RS</code>: 输入记录分隔符 (默认为换行符)。</li>\n<li><code>ORS</code>: 输出记录分隔符 (默认为换行符)。</li>\n<li><code>NR</code>: 当前已处理的记录数（行号）。 </li>\n<li><code>NF</code>: 当前记录中的字段数。</li>\n</ul>\n</li>\n<li><code>awk</code> 不仅仅是一个简单的文本过滤器，它实际上是一种编程语言，拥有变量、条件语句（如 <code>if</code>）、循环（如 <code>for</code>, <code>while</code>）等编程结构 。这使其能够处理比 <code>grep</code> 或 <code>sed</code> 更复杂的文本处理任务，例如对数据进行计算、格式化输出复杂的报告等。</li>\n<li>示例:<ul>\n<li><code>awk -F':' '{print $1, $3}' /etc/passwd</code>: 打印 <code>/etc/passwd</code> 文件中以冒号分隔的第一和第三个字段（用户名和UID）。</li>\n<li><code>awk '/error/ {count++; print \"Error on line \" NR \": \" $0} END {print \"Total errors found: \" count}' system.log</code>: 搜索 <code>system.log</code> 中包含 “error” 的行，打印行号和内容，并在最后打印错误总数。</li>\n<li><code>ls -l | awk '{if ($5 &gt; 1024) print $9, \"is larger than 1KB\"}'</code>: 列出当前目录中大于1KB的文件。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>tr</code></strong> (转换或删除字符 Translate or delete characters)</p>\n<ul>\n<li><strong>用途:</strong> 用于字符级别的转换（如大小写转换）或删除。 </li>\n<li><strong>语法:</strong> <code>tr [选项] SET1</code> </li>\n<li>常用选项:<ul>\n<li><code>-d</code>: 删除 <code>SET1</code> 中指定的所有字符。 </li>\n<li><code>-s</code>: 压缩 <code>SET1</code> (或 <code>SET2</code> 如果提供了 <code>SET2</code>) 中连续重复的字符为一个。 </li>\n<li><code>-c</code>: 使用 <code>SET1</code> 的补集。</li>\n</ul>\n</li>\n<li><strong>字符集 (SET):</strong> 可以是单个字符、字符范围 (如 <code>a-z</code>, <code>0-9</code>) 或特殊字符类 (如 <code>[:lower:]</code>, <code>[:upper:]</code>, <code>[:digit:]</code>, <code>[:space:]</code>)。 </li>\n<li>示例:<ul>\n<li><code>echo \"Hello World\" | tr 'A-Z' 'a-z'</code>: 将标准输入中的大写字母转换为小写，输出 “hello world”。 </li>\n<li><code>cat myfile.txt | tr -d '\\r'</code>: 删除 <code>myfile.txt</code> 中的回车符 (Windows换行符转Unix换行符)。</li>\n<li><code>echo \"This has too many spaces\" | tr -s ' '</code>: 将多个连续空格压缩为单个空格，输出 “This has too many spaces”。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>cut</code></strong> (从每行中删除文本区域 Remove sections from each line of files)</p>\n<ul>\n<li><strong>用途:</strong> 从文件的每一行中提取（剪切）指定的列或字符。 </li>\n<li><strong>语法:</strong> <code>cut [选项][文件...]</code> </li>\n<li>常用选项:<ul>\n<li><code>-d 分隔符</code>: 指定字段分隔符 (默认是制表符 TAB)。 </li>\n<li><code>-f 字段列表</code>: 指定要提取的字段编号，可以用逗号分隔多个字段 (如 <code>1,3</code>) 或用连字符表示范围 (如 <code>2-5</code>)。 </li>\n<li><code>-c 字符列表</code>: 指定要提取的字符位置，格式同 <code>-f</code>。 </li>\n<li><code>-b 字节列表</code>: 指定要提取的字节位置，格式同 <code>-f</code>。 </li>\n<li><code>--complement</code>: 提取指定字段/字符/字节之外的部分。 </li>\n<li><code>--output-delimiter=字符串</code>: 指定输出字段的分隔符。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>cut -d':' -f1,7 /etc/passwd</code>: 提取 <code>/etc/passwd</code> 文件中以冒号分隔的第一和第七个字段（用户名和shell）。 </li>\n<li><code>date | cut -c12-19</code>: 显示当前时间的 时:分:秒 部分。</li>\n<li><code>who | cut -c1-8</code>: 提取 <code>who</code> 命令输出中每行的前8个字符（通常是用户名）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-4-文本比较与统计-Text-Comparison-and-Statistics\"><a href=\"#4-4-文本比较与统计-Text-Comparison-and-Statistics\" class=\"headerlink\" title=\"4.4 文本比较与统计 (Text Comparison and Statistics)\"></a>4.4 文本比较与统计 (Text Comparison and Statistics)</h3><ul>\n<li><strong><code>sort</code></strong> (对文本文件的行进行排序 Sort lines of text files)<ul>\n<li><strong>用途:</strong> 对文件内容按行进行排序，支持多种排序规则。 </li>\n<li><strong>语法:</strong> <code>sort [选项][文件...]</code> </li>\n<li>常用选项:<ul>\n<li><code>-r</code>: 反向排序（降序）。 </li>\n<li><code>-n</code>: 按数值大小进行排序。 </li>\n<li><code>-k 字段号[,结束字段号][选项]</code>: 按指定的字段进行排序。字段号从1开始。可以附加排序选项，如 <code>n</code> (数值), <code>r</code> (反向)。 </li>\n<li><code>-t 分隔符</code>: 指定字段分隔符。 </li>\n<li><code>-u</code>: 输出唯一的行（去除重复行，等同于 <code>sort file | uniq</code>）。 </li>\n<li><code>-f</code>: 忽略大小写进行排序。 </li>\n<li><code>-M</code>: 按月份名称排序 (Jan, Feb,…)。 </li>\n<li><code>-h</code>: 人类可读数字排序 (例如 2K, 1G)。 </li>\n<li><code>-o 输出文件</code>: 将排序结果写入指定文件，而不是标准输出。可以用于原地排序，例如 <code>sort -o file.txt file.txt</code>。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>sort names.txt</code>: 按字母顺序对 <code>names.txt</code> 的行进行排序。</li>\n<li><code>sort -rn data.log | head -n 5</code>: 对 <code>data.log</code> 中的数字进行反向（从大到小）排序，并显示前5行。</li>\n<li><code>sort -t':' -k3n /etc/passwd</code>: 以冒号为分隔符，按第三个字段（UID）的数值大小对 <code>/etc/passwd</code> 文件进行排序。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>uniq</code></strong> (报告或省略重复行 Report or omit repeated lines)<ul>\n<li><strong>用途:</strong> 从已排序的输入中删除或报告重复的相邻行。因此，<code>uniq</code> 通常与 <code>sort</code> 命令配合使用。 </li>\n<li><strong>语法:</strong> <code>uniq [选项][输入文件 [输出文件]]</code> </li>\n<li>常用选项:<ul>\n<li><code>-c</code>: 在每行前输出该行重复出现的次数。 </li>\n<li><code>-d</code>: 仅显示重复出现的行（每组重复行只显示一次）。 </li>\n<li><code>-D</code>: 显示所有重复的行（而不是每组只显示一次）。 </li>\n<li><code>-u</code>: 仅显示不重复的行。 </li>\n<li><code>-i</code>: 比较时忽略大小写。 </li>\n<li><code>-f N</code> 或 <code>--skip-fields=N</code>: 跳过比较每行的前N个字段。 </li>\n<li><code>-s N</code> 或 <code>--skip-chars=N</code>: 跳过比较每行的前N个字符。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>sort access.log | uniq -c</code>: 统计 <code>access.log</code> 中每种唯一请求的次数。</li>\n<li><code>sort data.txt | uniq -d</code>: 显示 <code>data.txt</code> 中所有重复的行。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>wc</code></strong> (打印换行符、字和字节计数 Print newline, word, and byte counts for each file)<ul>\n<li><strong>用途:</strong> 统计指定文件或标准输入的行数、单词数、字符数或字节数。 </li>\n<li><strong>语法:</strong> <code>wc [选项][文件...]</code> </li>\n<li>常用选项:<ul>\n<li><code>-l</code>: 只统计行数。 </li>\n<li><code>-w</code>: 只统计单词数。 </li>\n<li><code>-c</code>: 只统计字节数。 </li>\n<li><code>-m</code>: 只统计字符数 (考虑多字节字符)。 </li>\n<li><code>-L</code>: 打印最长行的长度。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>wc report.txt</code>: 显示 <code>report.txt</code> 的行数、单词数和字节数。</li>\n<li><code>ls -1 | wc -l</code>: 统计当前目录下的文件和目录数量。</li>\n<li><code>grep \"error\" logfile | wc -l</code>: 统计 <code>logfile</code> 中包含 “error” 的行数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>diff</code></strong> (逐行比较文件 Compare files line by line)<ul>\n<li><strong>用途:</strong> 比较两个文件的内容，并显示它们之间的差异。常用于比较代码文件、配置文件等。 </li>\n<li><strong>语法:</strong> <code>diff [选项] 文件1 文件2</code> </li>\n<li>常用选项:<ul>\n<li><code>-u</code> 或 <code>-U 数字</code>: 以统一格式 (unified format) 输出差异，通常更易读，并被 <code>patch</code> 命令使用。 </li>\n<li><code>-c</code>: 以上下文格式 (context format) 输出差异。 </li>\n<li><code>-i</code>: 比较时忽略大小写。 </li>\n<li><code>-w</code>: 忽略所有空格导致的差异。 </li>\n<li><code>-B</code>: 忽略因空行导致的差异。 </li>\n<li><code>-r</code>: 递归比较目录。如果比较的是目录，<code>diff</code> 会比较两个目录中同名的文件。 </li>\n<li><code>-q</code> 或 <code>--brief</code>: 仅报告文件是否不同，不显示具体差异。 </li>\n<li><code>-s</code>: 当文件相同时报告。</li>\n</ul>\n</li>\n<li>输出格式解释:<ul>\n<li>默认格式：<code>&lt;</code> 表示第一个文件中的行，<code>&gt;</code> 表示第二个文件中的行，行号和操作符（<code>a</code> 添加, <code>d</code> 删除, <code>c</code> 更改）指示如何从文件1转换到文件2。 </li>\n<li>统一格式 (<code>-u</code>): 以 <code>--- file1</code> 和 <code>+++ file2</code> 开头，差异部分用 <code>-</code> (来自文件1) 和 <code>+</code> (来自文件2) 标记。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>diff config_v1.conf config_v2.conf</code>: 比较两个配置文件的差异。</li>\n<li><code>diff -u old_script.sh new_script.sh &gt; script.patch</code>: 以统一格式生成补丁文件。 </li>\n<li><code>diff -r project_v1/ project_v2/</code>: 递归比较两个项目目录。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"五、用户、用户组与权限管理-User-Group-and-Permission-Management\"><a href=\"#五、用户、用户组与权限管理-User-Group-and-Permission-Management\" class=\"headerlink\" title=\"五、用户、用户组与权限管理 (User, Group, and Permission Management)\"></a>五、用户、用户组与权限管理 (User, Group, and Permission Management)</h2><p>管理用户账户、用户组以及文件和目录的访问权限是 Linux 系统安全与管理的核心。</p>\n<h3 id=\"5-1-用户信息查看-Viewing-User-Information\"><a href=\"#5-1-用户信息查看-Viewing-User-Information\" class=\"headerlink\" title=\"5.1 用户信息查看 (Viewing User Information)\"></a>5.1 用户信息查看 (Viewing User Information)</h3><ul>\n<li><strong><code>who</code></strong> (显示当前已登录的用户 Show who is logged on)<ul>\n<li><strong>用途:</strong> 显示当前登录到系统的用户信息，包括用户名、终端、登录时间、来源IP等。 </li>\n<li><strong>语法:</strong> <code>who [选项]</code> </li>\n<li>常用选项:<ul>\n<li><code>-a</code> 或 <code>--all</code>: 显示所有信息，包括空闲时间、进程ID等。 </li>\n<li><code>-b</code> 或 <code>--boot</code>: 显示上次系统启动时间。 </li>\n<li><code>-H</code> 或 <code>--heading</code>: 显示列标题。 </li>\n<li><code>-u</code> 或 <code>--users</code>: 列出已登录用户，并显示空闲时间和PID。 </li>\n<li><code>-q</code> 或 <code>--count</code>: 只显示登录用户名和数量。 </li>\n<li><code>am i</code> (或 <code>am I</code>): 显示运行 <code>who</code> 命令的当前用户信息。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>who</code>: 显示当前登录用户。</li>\n<li><code>who -H</code>: 显示当前登录用户并带列标题。</li>\n<li><code>who am i</code>: 显示当前终端会话的用户信息。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>id</code></strong> (打印真实和有效的用户和组ID Print real and effective user and group IDs)<ul>\n<li><strong>用途:</strong> 显示指定用户（默认为当前用户）的UID（用户ID）、GID（组ID）以及所属的用户组信息。 </li>\n<li><strong>语法:</strong> <code>id [选项][用户名]</code> </li>\n<li>常用选项:<ul>\n<li><code>-u</code>: 只显示有效用户ID (UID)。 </li>\n<li><code>-g</code>: 只显示有效组ID (GID)。 </li>\n<li><code>-G</code>: 显示所有组ID。 </li>\n<li><code>-n</code>: 与 <code>-u</code>, <code>-g</code>, <code>-G</code> 配合使用，显示名称而非数字ID。 </li>\n<li><code>-r</code>: 与 <code>-u</code>, <code>-g</code>, <code>-G</code> 配合使用，显示真实ID而非有效ID。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>id</code>: 显示当前用户的ID信息。</li>\n<li><code>id john</code>: 显示用户 <code>john</code> 的ID信息。</li>\n<li><code>id -Gn jane</code>: 显示用户 <code>jane</code> 所属的所有组的名称。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-用户切换与提权-Switching-Users-and-Elevating-Privileges\"><a href=\"#5-2-用户切换与提权-Switching-Users-and-Elevating-Privileges\" class=\"headerlink\" title=\"5.2 用户切换与提权 (Switching Users and Elevating Privileges)\"></a>5.2 用户切换与提权 (Switching Users and Elevating Privileges)</h3><ul>\n<li><strong><code>su</code></strong> (切换用户或成为超级用户 Switch user or become superuser)<ul>\n<li><strong>用途:</strong> 允许用户在当前终端会话中切换到另一个用户账户，如果未指定用户名，则默认切换到超级用户 (root)。 </li>\n<li><strong>语法:</strong> <code>su [选项][用户名]</code> </li>\n<li>常用选项:<ul>\n<li><code>-</code> 或 <code>-l</code> 或 <code>--login</code>: 模拟一次完整的登录过程，加载目标用户的环境变量、主目录和shell配置。这是推荐的切换用户方式，以避免环境混乱。 </li>\n<li><code>-c \"命令\"</code>: 以目标用户身份执行单个命令后退出。 </li>\n<li><code>-s shell路径</code>: 指定切换后使用的shell。 </li>\n<li><code>-p</code> 或 <code>-m</code> 或 <code>--preserve-environment</code>: 保留当前用户的环境变量。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>su - john</code>: 切换到用户 <code>john</code>，并加载其完整的登录环境。</li>\n<li><code>su -</code>: 切换到 <code>root</code> 用户，并加载其完整的登录环境 (需要输入root密码)。</li>\n<li><code>su -c \"ls /root\" someuser</code>: 以 <code>someuser</code> 的身份执行 <code>ls /root</code> 命令。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>sudo</code></strong> (以其他用户身份执行命令，通常是root Execute a command as another user, typically root)<ul>\n<li><strong>用途:</strong> 允许授权用户以超级用户 (root) 或其他指定用户的身份执行命令，而无需知道目标用户的密码（通常需要输入当前用户的密码进行验证）。这是比直接使用 <code>root</code> 账户更安全的权限提升方式。 </li>\n<li><strong>语法:</strong> <code>sudo [选项] 命令</code> </li>\n<li>常用选项:<ul>\n<li><code>-u 用户名</code>: 以指定用户的身份执行命令。 </li>\n<li><code>-i</code>: 模拟一次 <code>root</code> 用户的登录shell，加载 <code>root</code> 的环境。 </li>\n<li><code>-s</code>: 执行由 <code>SHELL</code> 环境变量指定的shell，通常是 <code>root</code> 的shell。 </li>\n<li><code>-l</code>: 列出当前用户可以通过 <code>sudo</code> 执行的命令以及禁止执行的命令。 </li>\n<li><code>-v</code>: 延长 <code>sudo</code> 的密码凭证时效，而不执行命令。 </li>\n<li><code>-k</code>: 使当前的 <code>sudo</code> 密码凭证失效，下次使用 <code>sudo</code> 时需要重新输入密码。 </li>\n<li><code>-b</code>: 在后台运行命令。</li>\n</ul>\n</li>\n<li><strong>配置文件:</strong> <code>sudo</code> 的权限配置存储在 <code>/etc/sudoers</code> 文件中，应使用 <code>visudo</code> 命令进行编辑，以确保语法正确并防止配置错误导致系统无法使用 <code>sudo</code>。 </li>\n<li>示例:<ul>\n<li><code>sudo apt update</code>: 以 <code>root</code> 权限更新软件包列表。 </li>\n<li><code>sudo -u www-data crontab -l</code>: 以 <code>www-data</code> 用户身份列出其 <code>cron</code> 作业。</li>\n<li><code>sudo -i</code>: 切换到 <code>root</code> 用户的交互式shell。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-3-用户账户管理-User-Account-Management\"><a href=\"#5-3-用户账户管理-User-Account-Management\" class=\"headerlink\" title=\"5.3 用户账户管理 (User Account Management)\"></a>5.3 用户账户管理 (User Account Management)</h3><ul>\n<li><strong><code>useradd</code></strong> (创建新用户 Create a new user or update default new user information)<ul>\n<li><strong>用途:</strong> 用于在Linux系统中添加新的用户账户。 </li>\n<li><strong>语法:</strong> <code>useradd [选项] 用户名</code> </li>\n<li>常用选项:<ul>\n<li><code>-m</code>: 创建用户的主目录（如果不存在）。 </li>\n<li><code>-d 家目录路径</code>: 指定用户的主目录路径。 </li>\n<li><code>-s shell路径</code>: 指定用户的默认登录shell (例如 <code>/bin/bash</code>, <code>/sbin/nologin</code>)。 </li>\n<li><code>-g 初始组名或GID</code>: 指定用户的主组。 </li>\n<li><code>-G 附加组列表</code>: 指定用户所属的附加组（逗号分隔）。 </li>\n<li><code>-c \"注释\"</code>: 为用户账户添加注释信息（例如全名）。 </li>\n<li><code>-e YYYY-MM-DD</code>: 设置账户的过期日期。</li>\n</ul>\n</li>\n<li><strong>注意:</strong> <code>useradd</code> 是一个底层工具，而 <code>adduser</code> 是一个更用户友好的脚本，通常在Debian/Ubuntu系统中使用，它会进行更多交互式设置。 </li>\n<li>示例:<ul>\n<li><code>sudo useradd -m -s /bin/bash -c \"John Doe\" johnd</code>: 创建一个名为 <code>johnd</code> 的用户，创建其主目录，设置shell为bash，并添加注释。</li>\n<li><code>sudo useradd -m -G developers,testers jane</code>: 创建用户 <code>jane</code>，创建其主目录，并将其加入 <code>developers</code> 和 <code>testers</code> 组。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>userdel</code></strong> (删除用户账户 Delete a user account and related files)<ul>\n<li><strong>用途:</strong> 用于从系统中删除用户账户。 </li>\n<li><strong>语法:</strong> <code>userdel [选项] 用户名</code> </li>\n<li>常用选项:<ul>\n<li><code>-r</code>: 删除用户的主目录及其中的文件，以及用户的邮件池。 </li>\n<li><code>-f</code>: 强制删除用户账户，即使该用户当前已登录或其文件仍被使用。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>sudo userdel olduser</code>: 删除用户 <code>olduser</code> (不删除其主目录)。</li>\n<li><code>sudo userdel -r former_employee</code>: 删除用户 <code>former_employee</code> 并移除其主目录和邮件池。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>usermod</code></strong> (修改用户账户 Modify a user account)<ul>\n<li><strong>用途:</strong> 用于修改现有用户账户的各种属性。 </li>\n<li><strong>语法:</strong> <code>usermod [选项] 用户名</code> </li>\n<li>常用选项:<ul>\n<li><code>-l 新登录名</code>: 更改用户的登录名。 </li>\n<li><code>-d 新家目录路径 [-m]</code>: 更改用户的主目录。<code>-m</code> 选项会将旧主目录的内容移动到新主目录。 </li>\n<li><code>-s 新shell路径</code>: 更改用户的默认登录shell。 </li>\n<li><code>-g 新主组名或GID</code>: 更改用户的主组。 </li>\n<li><code>-G 新附加组列表</code>: 更改用户所属的附加组列表（会覆盖原有的附加组）。 </li>\n<li><code>-aG 附加组</code>: 将用户追加到指定的附加组，而不影响其他已有的附加组 ( <code>-a</code> 必须与 <code>-G</code> 一起使用)。 </li>\n<li><code>-L</code>: 锁定用户账户，使其无法登录。 </li>\n<li><code>-U</code>: 解锁用户账户。 </li>\n<li><code>-e YYYY-MM-DD</code>: 设置账户的过期日期。 </li>\n<li><code>-c \"新注释\"</code>: 修改用户的注释信息。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>sudo usermod -s /usr/sbin/nologin restricted_user</code>: 将用户 <code>restricted_user</code> 的shell设置为 <code>/usr/sbin/nologin</code>，使其无法登录。</li>\n<li><code>sudo usermod -aG docker current_user</code>: 将用户 <code>current_user</code> 添加到 <code>docker</code> 组。</li>\n<li><code>sudo usermod -L problematic_user</code>: 锁定用户 <code>problematic_user</code> 的账户。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>passwd</code></strong> (更改用户密码 Change user password)<ul>\n<li><strong>用途:</strong> 用于设置或更改用户账户的密码。 </li>\n<li><strong>语法:</strong> <code>passwd [选项][用户名]</code> </li>\n<li>行为:<ul>\n<li>如果未指定用户名，则更改当前用户的密码 (需要输入当前密码)。 </li>\n<li>如果由 <code>root</code> 用户执行并指定了用户名，则可以直接更改该用户的密码，无需知道其旧密码。</li>\n</ul>\n</li>\n<li>常用选项:<ul>\n<li><code>-d</code>: 删除指定用户的密码，使其可以无密码登录 (非常不安全，慎用)。</li>\n<li><code>-l</code>: 锁定指定用户的密码，使其无法通过密码登录。 </li>\n<li><code>-u</code>: 解锁指定用户的密码。 </li>\n<li><code>-e</code> 或 <code>--expire</code>: 强制用户在下次登录时更改密码。 </li>\n<li><code>-S</code>: 显示密码状态信息。</li>\n<li><code>-n 天数</code>: 设置密码最短有效天数。 </li>\n<li><code>-x 天数</code>: 设置密码最长有效天数。</li>\n<li><code>-w 天数</code>: 设置密码过期前多少天开始警告。 </li>\n<li><code>-i 天数</code>: 密码过期后账户停用前的天数。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>passwd</code>: 更改当前用户的密码。</li>\n<li><code>sudo passwd john</code>: 更改用户 <code>john</code> 的密码。</li>\n<li><code>sudo passwd -l jane</code>: 锁定用户 <code>jane</code> 的密码。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-4-用户组管理-Group-Management\"><a href=\"#5-4-用户组管理-Group-Management\" class=\"headerlink\" title=\"5.4 用户组管理 (Group Management)\"></a>5.4 用户组管理 (Group Management)</h3><ul>\n<li><strong><code>groupadd</code></strong> (创建新用户组 Create a new group)<ul>\n<li><strong>用途:</strong> 用于在系统中创建一个新的用户组。 </li>\n<li><strong>语法:</strong> <code>groupadd [选项] 组名</code> </li>\n<li>常用选项:<ul>\n<li><code>-g GID</code>: 指定新用户组的GID (组ID)。如果省略，系统会自动分配一个。 </li>\n<li><code>-r</code>: 创建一个系统组。</li>\n</ul>\n</li>\n<li><strong>示例:</strong> <code>sudo groupadd developers</code>: 创建一个名为 <code>developers</code> 的用户组。</li>\n</ul>\n</li>\n<li><strong><code>groupdel</code></strong> (删除用户组 Delete a group)<ul>\n<li><strong>用途:</strong> 用于从系统中删除一个已存在的用户组。 </li>\n<li><strong>语法:</strong> <code>groupdel [选项] 组名</code> </li>\n<li>常用选项:<ul>\n<li><code>-f</code> 或 <code>--force</code>: 强制删除组，即使该组是某个用户的主组（通常不推荐这样做，除非明确知道后果）。</li>\n</ul>\n</li>\n<li><strong>注意:</strong> 不能删除作为任何用户主组的组，除非先更改该用户的主组。 </li>\n<li><strong>示例:</strong> <code>sudo groupdel old_project_team</code>: 删除名为 <code>old_project_team</code> 的用户组。</li>\n</ul>\n</li>\n<li><strong><code>groupmod</code></strong> (修改用户组 Modify a group definition on the system)<ul>\n<li><strong>用途:</strong> 用于修改现有用户组的属性，如组名或GID。 </li>\n<li><strong>语法:</strong> <code>groupmod [选项] 组名</code> </li>\n<li>常用选项:<ul>\n<li><code>-n 新组名</code>: 更改用户组的名称。 </li>\n<li><code>-g 新GID</code>: 更改用户组的GID。 </li>\n<li><code>-o</code>: 与 <code>-g</code> 配合使用，允许GID不唯一（通常不推荐）。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>sudo groupmod -n web_developers developers</code>: 将用户组 <code>developers</code> 重命名为 <code>web_developers</code>。</li>\n<li><code>sudo groupmod -g 1005 new_team</code>: 将用户组 <code>new_team</code> 的GID修改为1005。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>groups</code></strong> (打印用户所属的组 Print the groups a user is in)<ul>\n<li><strong>用途:</strong> 显示指定用户（默认为当前用户）所属的所有组的列表。 </li>\n<li><strong>语法:</strong> <code>groups [用户名]</code></li>\n<li>示例:<ul>\n<li><code>groups</code>: 显示当前用户所属的组。</li>\n<li><code>groups john</code>: 显示用户 <code>john</code> 所属的组。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-5-文件权限与归属管理-File-Permission-and-Ownership-Management\"><a href=\"#5-5-文件权限与归属管理-File-Permission-and-Ownership-Management\" class=\"headerlink\" title=\"5.5 文件权限与归属管理 (File Permission and Ownership Management)\"></a>5.5 文件权限与归属管理 (File Permission and Ownership Management)</h3><p>Linux 文件权限基于“用户-组-其他” (UGO) 模型，对每个文件或目录定义了读(r)、写(w)、执行(x)三种基本权限。</p>\n<ul>\n<li><p><code>chmod</code></p>\n<p> (更改文件模式位/权限 Change file mode bits)</p>\n<ul>\n<li><strong>用途:</strong> 修改文件或目录的访问权限。 </li>\n<li><strong>语法:</strong> <code>chmod [选项] 模式 文件/目录...</code> </li>\n<li>模式 (Mode):<ul>\n<li><strong>符号模式 (Symbolic Mode):</strong> 使用 <code>u</code> (所有者/用户), <code>g</code> (组), <code>o</code> (其他), <code>a</code> (所有) 结合 <code>+</code> (添加权限), <code>-</code> (移除权限), <code>=</code> (设置精确权限) 以及 <code>r</code> (读), <code>w</code> (写), <code>x</code> (执行)。 </li>\n<li><strong>数字模式 (Octal Mode):</strong> 使用三位八进制数表示权限，每位分别对应所有者、组和其他人。每位数字是r(4), w(2), x(1)权限值的和。</li>\n</ul>\n</li>\n<li>常用选项:<ul>\n<li><code>-R</code>: 递归地修改目录及其内容的权限。</li>\n</ul>\n</li>\n<li><strong>表格5.1: <code>chmod</code> 数字模式权限含义</strong></li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>数字</strong></th>\n<th><strong>r (读)</strong></th>\n<th><strong>w (写)</strong></th>\n<th><strong>x (执行)</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>无权限</td>\n</tr>\n<tr>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td>x</td>\n<td>执行权限</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-</td>\n<td>w</td>\n<td>-</td>\n<td>写入权限</td>\n</tr>\n<tr>\n<td>3</td>\n<td>-</td>\n<td>w</td>\n<td>x</td>\n<td>写入和执行权限</td>\n</tr>\n<tr>\n<td>4</td>\n<td>r</td>\n<td>-</td>\n<td>-</td>\n<td>读取权限</td>\n</tr>\n<tr>\n<td>5</td>\n<td>r</td>\n<td>-</td>\n<td>x</td>\n<td>读取和执行权限</td>\n</tr>\n<tr>\n<td>6</td>\n<td>r</td>\n<td>w</td>\n<td>-</td>\n<td>读取和写入权限</td>\n</tr>\n<tr>\n<td>7</td>\n<td>r</td>\n<td>w</td>\n<td>x</td>\n<td>读取、写入和执行权限</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">**示例:**\n<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">chmod</span> u+x script.sh<span class=\"token variable\">`</span></span><span class=\"token builtin class-name\">:</span> 为文件 <span class=\"token variable\"><span class=\"token variable\">`</span>script.sh<span class=\"token variable\">`</span></span> 的所有者添加执行权限。 \n <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">chmod</span> <span class=\"token number\">600</span> private_key.pem<span class=\"token variable\">`</span></span><span class=\"token builtin class-name\">:</span> 设置 <span class=\"token variable\"><span class=\"token variable\">`</span>private_key.pem<span class=\"token variable\">`</span></span> 文件的权限为所有者可读写，组和其他人无任何权限 <span class=\"token punctuation\">(</span>rw-------<span class=\"token punctuation\">)</span>。\n<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">chmod</span> <span class=\"token number\">755</span> public_script.sh<span class=\"token variable\">`</span></span><span class=\"token builtin class-name\">:</span> 设置 <span class=\"token variable\"><span class=\"token variable\">`</span>public_script.sh<span class=\"token variable\">`</span></span> 权限为所有者可读写执行，组和其他人可读可执行 <span class=\"token punctuation\">(</span>rwxr-xr-x<span class=\"token punctuation\">)</span>。 \n<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> <span class=\"token parameter variable\">-R</span> <span class=\"token number\">750</span> /var/www/my_app<span class=\"token variable\">`</span></span><span class=\"token builtin class-name\">:</span> 递归地设置 <span class=\"token variable\"><span class=\"token variable\">`</span>/var/www/my_app<span class=\"token variable\">`</span></span> 目录及其内容的权限为所有者读写执行，所属组读执行，其他人无权限。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><strong><code>chown</code></strong> (更改文件所有者和组 Change file owner and group)<ul>\n<li><strong>用途:</strong> 更改文件或目录的用户所有者和/或组所有者。通常需要超级用户权限。 </li>\n<li><strong>语法:</strong> <code>chown [选项][新所有者][:新组] 文件/目录...</code> </li>\n<li>常用选项:<ul>\n<li><code>-R</code>: 递归地更改目录及其内容的所有权。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>sudo chown john myfile.txt</code>: 将 <code>myfile.txt</code> 的所有者更改为用户 <code>john</code>。 </li>\n<li><code>sudo chown jane:developers report.doc</code>: 将 <code>report.doc</code> 的所有者更改为 <code>jane</code>，所属组更改为 <code>developers</code>。 </li>\n<li><code>sudo chown -R www-data:www-data /var/www/html</code>: 递归地将 <code>/var/www/html</code> 目录及其所有内容的所有者和所属组更改为 <code>www-data</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>chgrp</code></strong> (更改文件组所有权 Change file group ownership)<ul>\n<li><strong>用途:</strong> 单独更改文件或目录的组所有者。通常需要超级用户权限。 </li>\n<li><strong>语法:</strong> <code>chgrp [选项] 新组 文件/目录...</code> </li>\n<li>常用选项:<ul>\n<li><code>-R</code>: 递归地更改目录及其内容的组所有权。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>sudo chgrp editors draft.txt</code>: 将 <code>draft.txt</code> 的所属组更改为 <code>editors</code>。 </li>\n<li><code>sudo chgrp -R web_content /srv/my_website/assets</code>: 递归地将 <code>/srv/my_website/assets</code> 目录及其所有内容的所属组更改为 <code>web_content</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"六、网络命令-Networking-Commands\"><a href=\"#六、网络命令-Networking-Commands\" class=\"headerlink\" title=\"六、网络命令 (Networking Commands)\"></a>六、网络命令 (Networking Commands)</h2><p>Linux 提供了丰富的网络命令，用于测试连接、配置接口、查看状态、进行远程操作和DNS查询。</p>\n<h3 id=\"6-1-网络连接测试-Network-Connectivity-Testing\"><a href=\"#6-1-网络连接测试-Network-Connectivity-Testing\" class=\"headerlink\" title=\"6.1 网络连接测试 (Network Connectivity Testing)\"></a>6.1 网络连接测试 (Network Connectivity Testing)</h3><ul>\n<li><p><code>ping</code></p>\n<p> (向网络主机发送ICMP ECHO_REQUEST数据包 Send ICMP ECHO_REQUEST to network hosts)</p>\n<ul>\n<li><strong>用途:</strong> 测试与目标主机之间的网络连通性，通过发送ICMP回显请求并等待回显应答。 </li>\n<li><strong>语法:</strong> <code>ping [选项] 主机名或IP地址</code> </li>\n<li>常用选项:<ul>\n<li><code>-c 次数</code>: 发送指定数量的回显请求包后停止。 </li>\n<li><code>-i 间隔</code>: 设置发送每个包之间的间隔秒数。</li>\n<li><code>-s 包大小</code>: 设置发送包的大小（字节）。</li>\n<li><code>-W 超时</code>: 设置等待响应的超时时间（秒）。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>ping google.com</code>: 持续向 <code>google.com</code> 发送ping包，直到手动停止 (<code>Ctrl+C</code>)。</li>\n<li><code>ping -c 5 192.168.1.1</code>: 向 IP 地址 <code>192.168.1.1</code> 发送5个ping包。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-2-网络接口配置与查看-Network-Interface-Configuration-and-Viewing\"><a href=\"#6-2-网络接口配置与查看-Network-Interface-Configuration-and-Viewing\" class=\"headerlink\" title=\"6.2 网络接口配置与查看 (Network Interface Configuration and Viewing)\"></a>6.2 网络接口配置与查看 (Network Interface Configuration and Viewing)</h3><ul>\n<li><p><strong><code>ip</code></strong> (显示/操作路由、网络设备、接口和隧道 Show / manipulate routing, network devices, interfaces and tunnels)</p>\n<ul>\n<li><p><strong>用途:</strong> 这是Linux系统中用于网络配置的核心工具，功能强大，已取代旧的 <code>ifconfig</code> 和 <code>route</code> 等命令。 </p>\n</li>\n<li><p>子命令:</p>\n<ul>\n<li><p><code>addr</code>(或 a): 管理网络接口的IP地址。</p>\n</li>\n<li><p><code>ip addr show [dev 接口名]</code>: 显示指定接口（或所有接口）的IP地址信息。 </p>\n<ul>\n<li><code>sudo ip addr add IP地址/掩码 dev 接口名</code>: 为接口添加IP地址。</li>\n</ul>\n</li>\n<li><p><code>sudo ip addr del IP地址/掩码 dev 接口名</code>: 从接口删除IP地址。 </p>\n</li>\n<li><p><code>link</code>(或 l): 管理网络设备（接口）本身。</p>\n<ul>\n<li><code>ip link show [dev 接口名]</code>: 显示接口的状态和属性。</li>\n</ul>\n</li>\n<li><p><code>sudo ip link set 接口名 up/down</code>: 启用或禁用指定的网络接口。 </p>\n</li>\n<li><p><code>sudo ip link set 接口名 mtu 数值</code>: 设置接口的最大传输单元 (MTU)。 </p>\n</li>\n<li><p><code>route</code>(或 r): 管理路由表。</p>\n<ul>\n<li><code>ip route show</code> 或 <code>ip route list</code>: 显示内核路由表。 </li>\n<li><code>sudo ip route add 目标网络/掩码 via 网关地址 [dev 接口名]</code>: 添加一条静态路由。</li>\n</ul>\n</li>\n<li><p><code>sudo ip route del 目标网络/掩码</code>: 删除一条路由。</p>\n</li>\n</ul>\n</li>\n<li><p><code>neigh</code>(或 n): 管理ARP或NDP缓存（邻居表）。</p>\n<ul>\n<li><code>ip neigh show</code>: 显示邻居表。</li>\n</ul>\n</li>\n<li><p><code>ip</code> 命令是 <code>ifconfig</code> 的现代替代品，功能更强大，语法更一致。<code>ifconfig</code> 在许多新发行版中已不再默认安装。 </p>\n</li>\n<li><p>示例:</p>\n<ul>\n<li><code>ip addr show eth0</code>: 显示 <code>eth0</code> 接口的IP地址信息。</li>\n<li><code>sudo ip link set wlan0 down</code>: 禁用 <code>wlan0</code> 无线接口。</li>\n<li><code>ip route add default via 192.168.1.254 dev eth0</code>: 添加默认网关。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>ifconfig</code></strong> (配置网络接口 - 旧版 Configure a network interface - deprecated)</p>\n<ul>\n<li><strong>用途:</strong> 在较旧的Linux系统中用于配置和显示网络接口信息。 </li>\n<li>内容:<ul>\n<li><code>ifconfig</code>: 显示所有活动接口的信息。</li>\n<li><code>ifconfig 接口名</code>: 显示指定接口的信息。</li>\n<li><code>sudo ifconfig 接口名 IP地址 netmask 子网掩码 up</code>: 配置接口IP并启用。</li>\n</ul>\n</li>\n<li><strong>注意:</strong> 此命令已逐渐被 <code>ip</code> 命令取代，在新系统中可能未预装。 </li>\n<li><strong>示例:</strong> <code>ifconfig eth0</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-3-网络状态与套接字查看-Network-Status-and-Socket-Viewing\"><a href=\"#6-3-网络状态与套接字查看-Network-Status-and-Socket-Viewing\" class=\"headerlink\" title=\"6.3 网络状态与套接字查看 (Network Status and Socket Viewing)\"></a>6.3 网络状态与套接字查看 (Network Status and Socket Viewing)</h3><ul>\n<li><strong><code>ss</code></strong> (另一个调查套接字的实用程序 Another utility to investigate sockets)<ul>\n<li><strong>用途:</strong> 用于显示活动的套接字连接信息，是 <code>netstat</code> 的现代替代品，通常更快且提供更多信息。 </li>\n<li><strong>语法:</strong> <code>ss [选项]</code> </li>\n<li>常用选项:<ul>\n<li><code>-t</code>: 显示TCP套接字。 </li>\n<li><code>-u</code>: 显示UDP套接字。 </li>\n<li><code>-x</code>: 显示Unix域套接字。 </li>\n<li><code>-l</code>: 显示监听状态的套接字。 </li>\n<li><code>-p</code>: 显示使用套接字的进程。 </li>\n<li><code>-n</code>: 不解析服务名称，直接显示数字地址和端口号。 </li>\n<li><code>-a</code>: 显示所有状态的套接字（监听和非监听）。 </li>\n<li><code>-e</code>: 显示详细的套接字信息。 </li>\n<li><code>-o</code>: 显示计时器信息。 </li>\n<li><code>-s</code>: 显示套接字摘要统计。 </li>\n<li><code>state 状态</code>: 过滤特定状态的连接 (如 <code>established</code>, <code>listen</code>, <code>time-wait</code>)。</li>\n</ul>\n</li>\n<li><code>ss</code> 命令比 <code>netstat</code> 更快、提供更多信息，并且是 <code>netstat</code> 的推荐替代品。 </li>\n<li>示例:<ul>\n<li><code>ss -tulnp</code>: 显示所有TCP和UDP的监听端口及其对应的进程，并以数字形式显示地址和端口。</li>\n<li><code>ss -tan state established</code>: 显示所有已建立的TCP连接。 </li>\n<li><code>ss -tlp sport = :22</code>: 显示监听在SSH端口（22）的TCP连接及进程。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>netstat</code></strong> (打印网络连接、路由表、接口统计等 - 旧版 Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships - deprecated)<ul>\n<li><strong>用途:</strong> 显示网络连接、路由表、接口统计等信息。 </li>\n<li><strong>语法:</strong> <code>netstat [选项]</code> </li>\n<li>常用选项:<ul>\n<li><code>-t</code>: 显示TCP连接。 </li>\n<li><code>-u</code>: 显示UDP连接。 </li>\n<li><code>-l</code>: 显示监听套接字。 </li>\n<li><code>-p</code>: 显示与套接字关联的进程ID和名称。 </li>\n<li><code>-n</code>: 以数字形式显示地址和端口号。 </li>\n<li><code>-a</code>: 显示所有活动的连接和监听端口。 </li>\n<li><code>-r</code>: 显示内核路由表。 </li>\n<li><code>-i</code>: 显示网络接口统计信息。 </li>\n<li><code>-s</code>: 显示各协议的统计摘要。</li>\n</ul>\n</li>\n<li><strong>注意:</strong> <code>netstat</code> 已被 <code>ss</code> 命令取代，在新系统中可能未预装或不被推荐使用。 </li>\n<li><strong>示例:</strong> <code>sudo netstat -tulnp</code>: 显示所有TCP和UDP的监听端口、对应的进程，并以数字形式显示地址和端口。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-4-远程连接与文件传输-Remote-Connection-and-File-Transfer\"><a href=\"#6-4-远程连接与文件传输-Remote-Connection-and-File-Transfer\" class=\"headerlink\" title=\"6.4 远程连接与文件传输 (Remote Connection and File Transfer)\"></a>6.4 远程连接与文件传输 (Remote Connection and File Transfer)</h3><ul>\n<li><p><strong><code>ssh</code></strong> (安全Shell客户端 OpenSSH SSH client (remote login program))</p>\n<ul>\n<li><strong>用途:</strong> Secure Shell，用于安全地远程登录到另一台Linux/Unix服务器，并执行命令。所有通信都会被加密。 </li>\n<li><strong>语法:</strong> <code>ssh [选项] 用户名@主机名或IP地址 [命令]</code> </li>\n<li>常用选项:<ul>\n<li><code>-p 端口号</code>: 指定连接的远程SSH服务器端口 (默认为22)。 </li>\n<li><code>-i 身份文件路径</code>: 指定用于公钥认证的私钥文件路径。</li>\n<li><code>-X</code>: 启用X11转发，允许在本地显示远程GUI应用的界面。 </li>\n<li><code>-L 本地端口:目标主机:目标端口</code>: 设置本地端口转发。 </li>\n<li><code>-R 远程端口:目标主机:目标端口</code>: 设置远程端口转发。 </li>\n<li><code>-C</code>: 启用压缩，可以加快慢速网络下的传输速度。 </li>\n<li><code>-v</code>: 详细模式，显示连接过程的调试信息。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>ssh user@example.com</code>: 以用户 <code>user</code> 的身份登录到 <code>example.com</code>。</li>\n<li><code>ssh -p 2222 admin@192.168.1.100 \"df -h\"</code>: 通过2222端口以 <code>admin</code> 用户身份连接到 <code>192.168.1.100</code> 并执行 <code>df -h</code> 命令。</li>\n<li><code>ssh -L 8080:localhost:80 user@remote_server</code>: 将本地的8080端口转发到远程服务器的80端口。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>scp</code></strong> (安全复制文件 Secure copy (remote file copy program))</p>\n<ul>\n<li><strong>用途:</strong> Secure Copy Protocol，用于在本地主机和远程主机之间，或者两台远程主机之间安全地复制文件和目录。它使用SSH进行数据传输和认证。 </li>\n<li><strong>语法:</strong> <code>scp [选项][[用户名@]源主机:]源文件路径 [[用户名@]目标主机:]目标文件路径</code> </li>\n<li>常用选项:<ul>\n<li><code>-P 端口号</code> (注意是大写P): 指定远程主机的SSH端口。 </li>\n<li><code>-r</code>: 递归复制整个目录。 </li>\n<li><code>-i 身份文件路径</code>: 指定用于认证的私钥文件。 </li>\n<li><code>-C</code>: 启用压缩。 </li>\n<li><code>-v</code>: 显示详细的传输过程。 </li>\n<li><code>-l 带宽限制</code>: 限制传输带宽 (Kbit/s)。</li>\n</ul>\n</li>\n<li>示例:<ul>\n<li><code>scp local_document.pdf user@remote.server.com:/home/user/documents/</code>: 将本地文件 <code>local_document.pdf</code> 复制到远程服务器的指定目录。 </li>\n<li><code>scp -r user@source.server.com:/var/www/html/ /backup/website/</code>: 将远程服务器上的 <code>html</code> 目录递归复制到本地的 <code>/backup/website/</code> 目录。</li>\n<li><code>scp -P 2200 file.zip user@another.host:~/backups/</code>: 通过2200端口将 <code>file.zip</code> 复制到另一台远程主机的 <code>backups</code> 目录。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>sftp</code></strong> (安全文件传输程序 Secure File Transfer Program)</p>\n<ul>\n<li><p><strong>用途:</strong> 提供一个交互式的安全文件传输会话，类似于传统的FTP客户端，但所有操作都通过SSH加密通道进行。 </p>\n</li>\n<li><p><strong>语法:</strong> <code>sftp [选项][用户名@]主机名或IP地址</code> </p>\n</li>\n<li><p>常用选项:</p>\n<ul>\n<li><code>-P 端口号</code> (大写P): 指定远程SSH端口。 </li>\n<li><code>-b 批处理文件</code>: 从批处理文件中读取命令执行。 </li>\n<li><code>-B 缓冲区大小</code>: 指定传输缓冲区大小。</li>\n</ul>\n</li>\n<li><p>交互模式常用命令:</p>\n<p> (在 sftp&gt;提示符下使用) </p>\n<ul>\n<li><code>get 远程文件 [本地路径]</code>: 下载文件。</li>\n<li><code>put 本地文件 [远程路径]</code>: 上传文件。</li>\n<li><code>ls [远程路径]</code>: 列出远程目录内容。</li>\n<li><code>cd 远程路径</code>: 更改远程当前目录。</li>\n<li><code>lcd 本地路径</code>: 更改本地当前目录。</li>\n<li><code>pwd</code>: 显示远程当前工作目录。</li>\n<li><code>lpwd</code>: 显示本地当前工作目录。</li>\n<li><code>rm 远程文件</code>: 删除远程文件。</li>\n<li><code>mkdir 远程目录名</code>: 创建远程目录。</li>\n<li><code>rmdir 远程目录名</code>: 删除远程目录。</li>\n<li><code>help</code> 或 <code>?</code>: 显示帮助信息。</li>\n<li><code>exit</code> 或 <code>quit</code> 或 <code>bye</code>: 断开连接并退出SFTP。</li>\n</ul>\n</li>\n<li><p>示例:</p>\n<ul>\n<li><code>sftp user@fileserver.example.com</code>: 连接到SFTP服务器。</li>\n<li>(在 <code>sftp&gt;</code> 提示符下) <code>get important_data.zip /local/backups/</code>: 从远程服务器下载文件。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>ftp</code></strong> (文件传输协议客户端 - 旧版，不安全 File Transfer Protocol client - deprecated, insecure)</p>\n<ul>\n<li><p><strong>用途:</strong> 用于通过文件传输协议 (FTP) 在网络上的计算机之间传输文件。 </p>\n</li>\n<li><p><strong>内容:</strong> FTP传输数据和凭证（用户名、密码）时通常不加密，存在安全风险。推荐使用SFTP或SCP作为更安全的选择。 </p>\n</li>\n<li><p><strong>语法:</strong> <code>ftp [主机名或IP地址]</code> </p>\n</li>\n<li><p>交互模式常用命令:</p>\n<p> (在 ftp&gt; 提示符下使用) </p>\n<ul>\n<li><code>user 用户名 [密码]</code>: 登录。</li>\n<li><code>get 远程文件 [本地文件名]</code>: 下载文件。</li>\n<li><code>put 本地文件 [远程文件名]</code>: 上传文件。</li>\n<li><code>mget 远程文件模式</code>: 下载多个文件。</li>\n<li><code>mput 本地文件模式</code>: 上传多个文件。</li>\n<li><code>ls</code>: 列出远程目录内容。</li>\n<li><code>cd 远程目录</code>: 更改远程当前目录。</li>\n<li><code>pwd</code>: 显示远程当前工作目录。</li>\n<li><code>delete 远程文件</code>: 删除远程文件。</li>\n<li><code>mkdir 远程目录名</code>: 创建远程目录。</li>\n<li><code>binary</code>: 设置二进制传输模式 (传输非文本文件时必须)。</li>\n<li><code>ascii</code>: 设置ASCII传输模式 (传输文本文件时)。</li>\n<li><code>bye</code> 或 <code>quit</code>: 断开连接并退出FTP。</li>\n</ul>\n</li>\n<li><p>示例:</p>\n<ul>\n<li><code>ftp ftp.example.com</code>: 连接到FTP服务器 <code>ftp.example.com</code>。</li>\n<li>(在 <code>ftp&gt;</code> 提示符下) <code>get report.pdf</code>: 下载 <code>report.pdf</code> 文件。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>wget</code></strong> (非交互式网络下载器 The non-interactive network downloader)</p>\n<ul>\n<li><strong>用途:</strong> 从Web服务器下载文件，支持HTTP, HTTPS, FTP协议。它是一个非交互式工具，可以在后台运行。 </li>\n<li><strong>语法:</strong> <code>wget [选项]......</code> </li>\n<li>常用选项:<ul>\n<li><code>-O 文件名</code>: 将下载内容保存为指定的文件名。 </li>\n<li><code>-P 目录</code>: 指定下载文件的保存目录。 </li>\n<li><code>-c</code>: 断点续传，继续下载未完成的文件。 </li>\n<li><code>-r</code>: 递归下载整个网站或目录。 </li>\n<li><code>-l 深度</code>: 递归下载时指定最大深度。</li>\n<li><code>-np</code>: 递归下载时不进入父目录。</li>\n<li><code>-k</code>: 转换链接，使下载的HTML文件可以在本地查看。 </li>\n<li><code>-p</code>: 下载所有显示HTML页面所需的文件，如图片等。 </li>\n<li><code>-b</code>: 后台下载。 </li>\n<li><code>-i 文件</code>: 从文件中读取URL列表进行下载。 </li>\n<li><code>--limit-rate=速度</code>: 限制下载速度 (例如 <code>100k</code>,</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"wget-非交互式网络下载器-The-non-interactive-network-downloader\"><a href=\"#wget-非交互式网络下载器-The-non-interactive-network-downloader\" class=\"headerlink\" title=\"wget (非交互式网络下载器 The non-interactive network downloader)\"></a><code>wget</code> (非交互式网络下载器 The non-interactive network downloader)</h3><p><strong>用途:</strong> 从Web服务器下载文件，支持HTTP, HTTPS, FTP协议。它是一个非交互式工具，可以在后台运行。</p>\n<p><strong>语法:</strong> <code>wget [选项]...... [URL...]</code></p>\n<p><strong>常用选项:</strong></p>\n<ul>\n<li><code>-O 文件名</code>: 将下载内容保存为指定的文件名。<ul>\n<li>示例: <code>wget -O latest.tar.gz https://example.com/latest-version.tar.gz</code></li>\n</ul>\n</li>\n<li><code>-P 目录</code>: 指定下载文件的保存目录。<ul>\n<li>示例: <code>wget -P /opt/downloads https://example.com/archive.zip</code></li>\n</ul>\n</li>\n<li><code>-c</code>: 断点续传，继续下载未完成的文件。<ul>\n<li>示例: <code>wget -c https://large.example.com/bigfile.iso</code></li>\n</ul>\n</li>\n<li><code>-r</code>: 递归下载整个网站或目录。<ul>\n<li>示例: <code>wget -r http://example.com/docs/</code></li>\n</ul>\n</li>\n<li><code>-l 深度</code>: 递归下载时指定最大深度。<ul>\n<li>示例: <code>wget -r -l 2 http://example.com/</code> (下载当前页和下一层链接)</li>\n</ul>\n</li>\n<li><code>-np</code>: 递归下载时不进入父目录。<ul>\n<li>示例: <code>wget -r -np http://example.com/parent/child/</code> (不会下载 <code>http://example.com/parent/</code> 的其他内容)</li>\n</ul>\n</li>\n<li><code>-k</code>: 转换链接，使下载的HTML文件可以在本地查看。通常与 <code>-r</code>一起使用。<ul>\n<li>示例: <code>wget -r -k http://example.com/</code></li>\n</ul>\n</li>\n<li><code>-p</code>: 下载所有显示HTML页面所需的文件，如图片、CSS等。通常与 <code>-r</code>一起使用。<ul>\n<li>示例: <code>wget -r -p http://example.com/page.html</code></li>\n</ul>\n</li>\n<li><code>-b</code>: 后台下载。日志默认输出到 <code>wget-log</code>。<ul>\n<li>示例: <code>wget -b https://large.example.com/bigfile.iso</code></li>\n</ul>\n</li>\n<li><code>-i 文件</code>: 从文件中读取URL列表进行下载，每行一个URL。<ul>\n<li>示例: <code>wget -i urls.txt</code> (其中 <code>urls.txt</code> 包含多个下载链接)</li>\n</ul>\n</li>\n<li><code>--limit-rate=速度</code>: 限制下载速度 (例如 100k, 1m)。<ul>\n<li>示例: <code>wget --limit-rate=200k https://example.com/file.zip</code></li>\n</ul>\n</li>\n<li><code>--tries=数字</code>: 设置重试次数 (0 表示无限)。<ul>\n<li>示例: <code>wget --tries=5 https://example.com/file.zip</code></li>\n</ul>\n</li>\n<li><code>--user-agent=\"字符串\"</code>: 设置自定义 User-Agent。<ul>\n<li>示例: <code>wget --user-agent=\"MyCustomBrowser/1.0\" https://example.com/</code></li>\n</ul>\n</li>\n<li><code>--no-check-certificate</code>: 不检查服务器的SSL证书 (不安全，慎用)。<ul>\n<li>示例: <code>wget --no-check-certificate https://self-signed.example.com/</code></li>\n</ul>\n</li>\n<li><code>--user=用户名 --password=密码</code>: FTP或HTTP认证。<ul>\n<li>示例: <code>wget --user=myuser --password=mypass ftp://ftp.example.com/file.dat</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"curl-Client-URL-请求库\"><a href=\"#curl-Client-URL-请求库\" class=\"headerlink\" title=\"curl (Client URL 请求库)\"></a><code>curl</code> (Client URL 请求库)</h3><p><strong>用途:</strong> 用于传输数据的命令行工具，支持多种协议，包括 HTTP, HTTPS, FTP, FTPS, SCP, SFTP, LDAP, SMTP 等。非常灵活，常用于API测试和自动化脚本。</p>\n<p><strong>语法:</strong> <code>curl [选项] [URL...]</code></p>\n<p><strong>常用选项:</strong></p>\n<ul>\n<li><code>-O</code>: 将输出写入与远程文件名相同的文件。<ul>\n<li>示例: <code>curl -O https://example.com/archive.zip</code> (保存为 <code>archive.zip</code>)</li>\n</ul>\n</li>\n<li><code>-o 文件名</code>: 将输出写入指定的文件名。<ul>\n<li>示例: <code>curl -o new_archive.zip https://example.com/archive.zip</code></li>\n</ul>\n</li>\n<li><code>-L</code>: 跟随HTTP重定向。<ul>\n<li>示例: <code>curl -L http://example.com</code></li>\n</ul>\n</li>\n<li><code>-I</code> 或 <code>--head</code>: 仅获取HTTP头信息。<ul>\n<li>示例: <code>curl -I https://example.com</code></li>\n</ul>\n</li>\n<li><code>-H \"头部信息\"</code>: 添加自定义HTTP头部。<ul>\n<li>示例: <code>curl -H \"Authorization: Bearer mytoken\" https://api.example.com/data</code></li>\n</ul>\n</li>\n<li><code>-X 请求方法</code>: 指定HTTP请求方法 (GET, POST, PUT, DELETE 等)。<ul>\n<li>示例 (POST): <code>curl -X POST -H \"Content-Type: application/json\" -d '{\"key\":\"value\"}' https://api.example.com/submit</code></li>\n</ul>\n</li>\n<li><code>-d \"数据\"</code> 或 <code>--data \"数据\"</code>: 发送HTTP POST请求的数据。<ul>\n<li>示例: <code>curl -d \"param1=value1&amp;param2=value2\" https://example.com/form</code></li>\n</ul>\n</li>\n<li><code>-F \"表单数据\"</code> 或 <code>--form \"表单数据\"</code>: 模拟multipart/form-data提交，常用于文件上传。<ul>\n<li>示例: <code>curl -F \"file=@/path/to/localfile.txt\" -F \"name=myfile\" https://example.com/upload</code></li>\n</ul>\n</li>\n<li><code>-u 用户名:密码</code>: 进行服务器认证。<ul>\n<li>示例: <code>curl -u myuser:mypassword https://api.example.com/protected</code></li>\n</ul>\n</li>\n<li><code>-s</code> 或 <code>--silent</code>: 静默模式，不显示进度条或错误信息。<ul>\n<li>示例: <code>STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" https://example.com)</code></li>\n</ul>\n</li>\n<li><code>-v</code> 或 <code>--verbose</code>: 显示详细的通信信息，包括请求和响应头。<ul>\n<li>示例: <code>curl -v https://example.com</code></li>\n</ul>\n</li>\n<li><code>-k</code> 或 <code>--insecure</code>: 允许连接到没有有效SSL证书的HTTPS站点 (不安全，慎用)。<ul>\n<li>示例: <code>curl -k https://self-signed.example.com</code></li>\n</ul>\n</li>\n<li><code>--connect-timeout 秒数</code>: 设置最大连接时间。<ul>\n<li>示例: <code>curl --connect-timeout 5 https://example.com</code></li>\n</ul>\n</li>\n<li><code>--max-time 秒数</code>: 设置允许操作完成的最大总时间。<ul>\n<li>示例: <code>curl --max-time 30 https://example.com/largefile</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"nslookup-Name-Server-Lookup-🌐\"><a href=\"#nslookup-Name-Server-Lookup-🌐\" class=\"headerlink\" title=\"nslookup (Name Server Lookup) 🌐\"></a><code>nslookup</code> (Name Server Lookup) 🌐</h3><p><strong>用途:</strong> 查询DNS域名服务器，获取域名对应的IP地址或其他DNS记录。</p>\n<p><strong>语法:</strong></p>\n<ul>\n<li>非交互模式: <code>nslookup [选项] [域名] [DNS服务器]</code></li>\n<li>交互模式: <code>nslookup</code> (进入提示符后输入域名或选项)</li>\n</ul>\n<p><strong>常用选项/查询类型:</strong></p>\n<ul>\n<li>默认查询A记录 (IP地址)。</li>\n<li><code>set type=mx</code>: 查询MX记录 (邮件交换服务器)。</li>\n<li><code>set type=ns</code>: 查询NS记录 (域名服务器)。</li>\n<li><code>set type=soa</code>: 查询SOA记录 (起始授权机构记录)。</li>\n<li><code>set type=txt</code>: 查询TXT记录 (文本记录)。</li>\n<li><code>set type=ptr</code>: 查询PTR记录 (反向DNS查找)。</li>\n<li><code>server &lt;DNS服务器IP&gt;</code>: 在交互模式下指定查询使用的DNS服务器。</li>\n</ul>\n<p><strong>示例:</strong></p>\n<ul>\n<li><p><code>nslookup example.com</code> (<a href=\"https://www.google.com/search?q=%E6%9F%A5%E8%AF%A2example.com%E7%9A%84A%E8%AE%B0%E5%BD%95\">https://www.google.com/search?q=%E6%9F%A5%E8%AF%A2example.com的A记录</a>)</p>\n</li>\n<li><p><code>nslookup example.com 8.8.8.8</code> (使用Google <a href=\"https://www.google.com/search?q=DNS%E6%9F%A5%E8%AF%A2example.com\">https://www.google.com/search?q=DNS%E6%9F%A5%E8%AF%A2example.com</a>)</p>\n</li>\n<li><p>交互模式:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">nslookup\n&gt; server 8.8.8.8\n&gt; set type=mx\n&gt; google.com\n&gt; exit<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>nslookup -type=mx google.com</code> (非交互式查询MX记录)</p>\n</li>\n<li><p><code>nslookup 8.8.4.4</code> (反向查询IP地址对应的主机名)</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"dig-Domain-Information-Groper-⛏️\"><a href=\"#dig-Domain-Information-Groper-⛏️\" class=\"headerlink\" title=\"dig (Domain Information Groper) ⛏️\"></a><code>dig</code> (Domain Information Groper) ⛏️</h3><p><strong>用途:</strong> 更强大和灵活的DNS查询工具，常用于DNS故障排除。</p>\n<p><strong>语法:</strong> <code>dig [@服务器] [域名] [查询类型] [选项]</code></p>\n<p><strong>常用选项/查询类型:</strong></p>\n<ul>\n<li>默认查询A记录。</li>\n<li><code>MX</code>: 查询邮件交换记录。</li>\n<li><code>NS</code>: 查询域名服务器记录。</li>\n<li><code>SOA</code>: 查询起始授权机构记录。</li>\n<li><code>TXT</code>: 查询文本记录。</li>\n<li><code>ANY</code>: 查询所有类型的记录。</li>\n<li><code>-x &lt;IP地址&gt;</code>: 进行反向DNS查询。</li>\n<li><code>+short</code>: 只显示简短的答案。</li>\n<li><code>+trace</code>: 显示从根域名服务器开始的完整解析路径。</li>\n<li><code>+noall +answer</code>: 只显示答案部分。</li>\n<li><code>@&lt;DNS服务器IP&gt;</code>: 指定查询使用的DNS服务器。</li>\n</ul>\n<p><strong>示例:</strong></p>\n<ul>\n<li><code>dig example.com</code></li>\n<li><code>dig example.com MX</code></li>\n<li><code>dig @8.8.8.8 example.com NS</code></li>\n<li><code>dig -x 8.8.4.4</code></li>\n<li><code>dig example.com +short</code></li>\n<li><code>dig example.com +trace</code></li>\n<li><code>dig example.com ANY +noall +answer</code></li>\n</ul>\n<hr>\n<h3 id=\"traceroute-追踪路由路径-🗺️\"><a href=\"#traceroute-追踪路由路径-🗺️\" class=\"headerlink\" title=\"traceroute (追踪路由路径) 🗺️\"></a><code>traceroute</code> (追踪路由路径) 🗺️</h3><p><strong>用途:</strong> 显示数据包从本地主机到目标主机所经过的路由路径，以及每一跳的延迟。</p>\n<p><strong>语法:</strong> <code>traceroute [选项] 主机名或IP地址</code></p>\n<p><strong>常用选项:</strong></p>\n<ul>\n<li><code>-n</code>: 不将IP地址解析为主机名，加快显示速度。</li>\n<li><code>-I</code>: 使用ICMP ECHO请求代替UDP数据报 (类似Windows的tracert)。</li>\n<li><code>-T</code>: 使用TCP SYN请求代替UDP数据报。</li>\n<li><code>-p 端口号</code>: 指定UDP或TCP的目标端口号。</li>\n<li><code>-m 最大跳数</code>: 设置最大跳数 (默认为30)。</li>\n<li><code>-q 查询次数</code>: 设置对每一跳发送的探测包数量 (默认为3)。</li>\n<li><code>-w 等待时间</code>: 设置等待探测包回复的超时时间 (秒)。</li>\n</ul>\n<p><strong>示例:</strong></p>\n<ul>\n<li><code>traceroute google.com</code></li>\n<li><code>traceroute -n 8.8.8.8</code></li>\n<li><code>traceroute -I example.com</code> (使用ICMP)</li>\n<li><code>traceroute -T -p 80 example.com</code> (<a href=\"https://www.google.com/search?q=%E8%BF%BD%E8%B8%AA%E5%88%B0example.com%E7%9A%84TCP\">https://www.google.com/search?q=%E8%BF%BD%E8%B8%AA%E5%88%B0example.com的TCP</a> 80端口)</li>\n</ul>\n<hr>\n<h3 id=\"route-显示-操作IP路由表-传统\"><a href=\"#route-显示-操作IP路由表-传统\" class=\"headerlink\" title=\"route (显示/操作IP路由表 - 传统)\"></a><code>route</code> (显示/操作IP路由表 - 传统)</h3><p><strong>用途:</strong> (传统工具，推荐使用 <code>ip route</code>) 显示和管理内核的IP路由表。</p>\n<p><strong>语法:</strong></p>\n<ul>\n<li><code>route</code> 或 <code>route -n</code> (显示路由表，-n以数字形式显示IP和端口)</li>\n<li><code>route add [-net|-host] 目标 [netmask Nm] [gw Gw] [metric M] [[dev] If]</code></li>\n<li><code>route del [-net|-host] 目标 [netmask Nm] [gw Gw] [metric M] [[dev] If]</code></li>\n</ul>\n<p><strong>常用选项/参数:</strong></p>\n<ul>\n<li><code>-n</code>: 以数字形式显示地址，不解析主机名。</li>\n<li><code>add</code>: 添加一条路由。</li>\n<li><code>del</code>: 删除一条路由。</li>\n<li><code>-net 目标网络</code>: 指定目标是一个网络。</li>\n<li><code>-host 目标主机</code>: 指定目标是一个主机。</li>\n<li><code>netmask Nm</code>: 指定网络的子网掩码。</li>\n<li><code>gw Gw</code>: 指定网关地址。</li>\n<li><code>dev If</code>: 指定路由通过哪个网络接口。</li>\n<li><code>metric M</code>: 设置路由的度量值 (成本)。</li>\n</ul>\n<p><strong>示例:</strong></p>\n<ul>\n<li><code>route -n</code> (显示当前路由表)</li>\n<li><code>route add default gw 192.168.1.1</code> (添加默认网关)</li>\n<li><code>route del default gw 192.168.1.1</code> (删除默认网关)</li>\n<li><code>route add -net 10.0.0.0 netmask 255.0.0.0 gw 192.168.0.1</code> (添加一个到10.0.0.0/8网络的静态路由)</li>\n<li><code>route del -net 10.0.0.0 netmask 255.0.0.0</code> (删除上述静态路由)</li>\n</ul>\n<hr>\n<h2 id=\"七、端口查看与防火墙管理\"><a href=\"#七、端口查看与防火墙管理\" class=\"headerlink\" title=\"七、端口查看与防火墙管理\"></a>七、端口查看与防火墙管理</h2><h3 id=\"ss-Socket-Statistics-SOCKET\"><a href=\"#ss-Socket-Statistics-SOCKET\" class=\"headerlink\" title=\"ss (Socket Statistics)  SOCKET\"></a><code>ss</code> (Socket Statistics)  SOCKET</h3><p><strong>用途:</strong> 用于转储套接字统计信息，可以显示比 <code>netstat</code> 更多的TCP和状态信息。它是 <code>netstat</code> 的现代替代品。</p>\n<p><strong>语法:</strong> <code>ss [选项]</code></p>\n<p><strong>常用选项:</strong></p>\n<ul>\n<li><code>-t</code>: 显示TCP套接字。</li>\n<li><code>-u</code>: 显示UDP套接字。</li>\n<li><code>-l</code>: 显示监听状态的套接字。</li>\n<li><code>-p</code>: 显示使用套接字的进程。</li>\n<li><code>-n</code>: 不解析服务名称，直接显示端口号。</li>\n<li><code>-a</code>: 显示所有套接字 (监听和非监听)。</li>\n<li><code>-e</code>: 显示详细的套接字信息。</li>\n<li><code>-o</code>: 显示计时器信息。</li>\n<li>state &lt;状态&gt;: 过滤特定状态的连接，如 <code>established, listen, time-wait</code>。<ul>\n<li>例如: <code>ss state established</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>示例:</strong></p>\n<ul>\n<li><code>ss -tulnp</code> (最常用组合：显示所有TCP和UDP监听端口及其进程，不解析名称)</li>\n<li><code>ss -tan</code> (显示所有TCP连接，不解析名称)</li>\n<li><code>ss -s</code> (显示套接字使用摘要)</li>\n<li><code>ss -t -a dst :22</code> (显示所有到22端口的TCP连接)</li>\n<li><code>ss -t -a src 192.168.1.100:http</code> (显示源自192.168.1.100的HTTP TCP连接)</li>\n</ul>\n<hr>\n<h3 id=\"netstat-Network-Statistics-传统\"><a href=\"#netstat-Network-Statistics-传统\" class=\"headerlink\" title=\"netstat (Network Statistics - 传统)\"></a><code>netstat</code> (Network Statistics - 传统)</h3><p><strong>用途:</strong> (传统工具，推荐使用 <code>ss</code>) 显示网络连接、路由表、接口统计等信息。</p>\n<p><strong>语法:</strong> <code>netstat [选项]</code></p>\n<p><strong>常用选项:</strong></p>\n<ul>\n<li><code>-t</code>: 显示TCP连接。</li>\n<li><code>-u</code>: 显示UDP连接。</li>\n<li><code>-l</code>: 显示监听状态的套接字。</li>\n<li><code>-p</code>: 显示使用套接字的进程PID和名称 (通常需要root权限)。</li>\n<li><code>-n</code>: 以数字形式显示地址和端口号，不解析名称。</li>\n<li><code>-a</code>: 显示所有活动的连接和监听端口。</li>\n<li><code>-r</code>: 显示路由表 (类似 <code>route -n</code>)。</li>\n<li><code>-i</code>: 显示网络接口统计信息 (类似 <code>ifconfig</code> 或 <code>ip -s link</code>)。</li>\n<li><code>-c</code>: 持续显示信息。</li>\n<li><code>-e</code>: 显示扩展信息。</li>\n</ul>\n<p><strong>示例:</strong></p>\n<ul>\n<li><code>netstat -tulnp</code> (最常用组合：显示所有TCP和UDP监听端口及其进程，不解析名称)</li>\n<li><code>netstat -an</code> (显示所有活动的连接和监听端口，不解析名称)</li>\n<li><code>netstat -rn</code> (显示路由表)</li>\n<li><code>netstat -i</code> (显示网络接口)</li>\n<li><code>netstat -antp | grep ESTABLISHED</code> (显示所有已建立的TCP连接及其进程)</li>\n</ul>\n<hr>\n<h3 id=\"iptables-IPv4-Packet-Filtering-and-NAT-🔥🧱\"><a href=\"#iptables-IPv4-Packet-Filtering-and-NAT-🔥🧱\" class=\"headerlink\" title=\"iptables (IPv4 Packet Filtering and NAT) 🔥🧱\"></a><code>iptables</code> (IPv4 Packet Filtering and NAT) 🔥🧱</h3><p><strong>用途:</strong> Linux内核防火墙 <code>netfilter</code> 的用户空间命令行工具，用于配置IPv4数据包过滤规则、NAT和包处理。功能强大但语法复杂。</p>\n<p><strong>基本概念:</strong></p>\n<ul>\n<li><p>Tables (表):</p>\n<ul>\n<li><code>filter</code>: 默认表，用于数据包过滤 (INPUT, OUTPUT, FORWARD 链)。</li>\n<li><code>nat</code>: 用于网络地址转换 (PREROUTING, POSTROUTING, OUTPUT 链)。</li>\n<li><code>mangle</code>: 用于修改IP头字段 (所有链)。</li>\n<li><code>raw</code>: 用于配置豁免，使数据包不经过连接跟踪。</li>\n</ul>\n</li>\n<li><p>Chains (链):</p>\n<p> 规则的有序列表。</p>\n<ul>\n<li><code>INPUT</code>: 处理发往本机的入站数据包。</li>\n<li><code>OUTPUT</code>: 处理本机发出的出站数据包。</li>\n<li><code>FORWARD</code>: 处理流经本机的转发数据包。</li>\n<li><code>PREROUTING</code>: 在路由决策之前处理数据包 (常用于DNAT)。</li>\n<li><code>POSTROUTING</code>: 在路由决策之后，数据包即将发出时处理 (常用于SNAT)。</li>\n</ul>\n</li>\n<li><p>Targets (目标):</p>\n<p> 规则匹配后执行的动作。</p>\n<ul>\n<li><code>ACCEPT</code>: 接受数据包。</li>\n<li><code>DROP</code>: 丢弃数据包 (不响应)。</li>\n<li><code>REJECT</code>: 拒绝数据包 (通常会返回错误信息)。</li>\n<li><code>LOG</code>: 记录数据包信息。</li>\n<li><code>SNAT</code>: 源地址转换。</li>\n<li><code>DNAT</code>: 目标地址转换。</li>\n<li><code>MASQUERADE</code>: 动态源地址转换 (常用于共享上网)。</li>\n</ul>\n</li>\n</ul>\n<p><strong>语法 (通用):</strong> <code>iptables [-t 表名] 命令 链名 匹配条件 -j 目标</code></p>\n<p><strong>常用命令:</strong></p>\n<ul>\n<li><code>-L [链名]</code>: 列出规则。<ul>\n<li><code>-v</code>: 显示详细信息 (包和字节计数器)。</li>\n<li><code>-n</code>: 数字格式显示IP和端口。</li>\n<li><code>--line-numbers</code>: 显示规则编号。</li>\n</ul>\n</li>\n<li><code>-A 链名</code>: 追加新规则到链尾。</li>\n<li><code>-I 链名 [规则编号]</code>: 插入新规则到指定位置 (默认链首)。</li>\n<li><code>-D 链名 规则编号或规则定义</code>: 删除规则。</li>\n<li><code>-R 链名 规则编号 规则定义</code>: 替换规则。</li>\n<li><code>-F [链名]</code>: 清空链中的所有规则。</li>\n<li><code>-Z [链名]</code>: 清零链中所有规则的包和字节计数器。</li>\n<li><code>-P 链名 目标</code>: 设置链的默认策略 (ACCEPT, DROP)。</li>\n<li><code>-N 链名</code>: 创建用户自定义链。</li>\n<li><code>-X [链名]</code>: 删除用户自定义空链。</li>\n<li><code>-E 旧链名 新链名</code>: 重命名用户自定义链。</li>\n</ul>\n<p><strong>常用匹配条件:</strong></p>\n<ul>\n<li><code>-p 协议</code>: 指定协议 (tcp, udp, icmp, all)。</li>\n<li><code>-s 源地址/掩码</code>: 指定源IP地址或网络。</li>\n<li><code>-d 目标地址/掩码</code>: 指定目标IP地址或网络。</li>\n<li><code>-i 输入接口</code>: 指定数据包进入的网络接口。</li>\n<li><code>-o 输出接口</code>: 指定数据包流出的网络接口。</li>\n<li><code>--sport 源端口</code>: 指定源端口 (需与 <code>-p tcp</code> 或 <code>-p udp</code> 配合)。</li>\n<li><code>--dport 目标端口</code>: 指定目标端口。</li>\n<li><code>-m 模块名 --模块选项</code>: 使用扩展模块 (如 <code>state, conntrack, multiport, tcp, udp</code>)。<ul>\n<li><code>-m state --state NEW,ESTABLISHED,RELATED</code>: 匹配连接状态。</li>\n<li><code>-m multiport --dports 22,80,443</code>: 匹配多个目标端口。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例:</strong></p>\n<ol>\n<li><strong>查看规则:</strong><ul>\n<li><code>sudo iptables -L -n -v</code> (查看filter表所有链的规则)</li>\n<li><code>sudo iptables -t nat -L -n -v --line-numbers</code> (查看nat表规则并显示行号)</li>\n</ul>\n</li>\n<li><strong>设置默认策略:</strong> (通常先允许所有传出，拒绝所有传入和转发)<ul>\n<li><code>sudo iptables -P INPUT DROP</code></li>\n<li><code>sudo iptables -P FORWARD DROP</code></li>\n<li><code>sudo iptables -P OUTPUT ACCEPT</code></li>\n</ul>\n</li>\n<li><strong>允许特定端口/服务:</strong><ul>\n<li><code>sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT</code> (允许SSH)</li>\n<li><code>sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT</code> (允许HTTP)</li>\n<li><code>sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT</code> (允许HTTPS)</li>\n<li><code>sudo iptables -A INPUT -i lo -j ACCEPT</code> (允许来自本地回环接口的所有流量)</li>\n<li><code>sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</code> (允许已建立和相关的连接)</li>\n</ul>\n</li>\n<li><strong>允许特定IP:</strong><ul>\n<li><code>sudo iptables -A INPUT -s 192.168.1.100 -j ACCEPT</code></li>\n</ul>\n</li>\n<li><strong>阻止特定IP:</strong><ul>\n<li><code>sudo iptables -A INPUT -s 1.2.3.4 -j DROP</code> (阻止单个IP)</li>\n<li><code>sudo iptables -A INPUT -s 1.2.3.0/24 -j REJECT</code> (拒绝整个子网)</li>\n</ul>\n</li>\n<li><strong>删除规则:</strong><ul>\n<li><code>sudo iptables -D INPUT 3</code> (删除INPUT链中编号为3的规则)</li>\n<li><code>sudo iptables -D INPUT -s 1.2.3.4 -j DROP</code> (按规则定义删除)</li>\n</ul>\n</li>\n<li><strong>清空规则:</strong><ul>\n<li><code>sudo iptables -F INPUT</code> (清空INPUT链)</li>\n<li><code>sudo iptables -F</code> (清空filter表所有链)</li>\n<li><code>sudo iptables -t nat -F</code> (清空nat表所有链)</li>\n</ul>\n</li>\n<li><strong>NAT示例 (SNAT/MASQUERADE - 共享上网):</strong><ul>\n<li>假设 <code>eth0</code> 是外网接口，<code>eth1</code> 是内网接口 (内网IP段 <code>192.168.1.0/24</code>)。</li>\n<li><code>sudo sysctl -w net.ipv4.ip_forward=1</code> (开启IP转发)</li>\n<li><code>sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</code></li>\n<li><code>sudo iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT</code></li>\n<li><code>sudo iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT</code></li>\n</ul>\n</li>\n<li><strong>NAT示例 (DNAT - 端口转发):</strong><ul>\n<li>将外网接口 <code>eth0</code> 的TCP 8080端口转发到内网服务器 <code>192.168.1.100</code> 的80端口。</li>\n<li><code>sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.100:80</code></li>\n<li><code>sudo iptables -A FORWARD -p tcp -d 192.168.1.100 --dport 80 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>保存和恢复规则:</strong></p>\n<ul>\n<li>规则默认在重启后丢失。</li>\n<li><strong>保存:</strong> <code>sudo iptables-save &gt; /etc/iptables/rules.v4</code> (Debian/Ubuntu，需安装 <code>iptables-persistent</code>) <code>sudo ip6tables-save &gt; /etc/iptables/rules.v6</code> 在RHEL/CentOS系统上，通常使用 <code>systemctl enable iptables</code> 和 <code>systemctl start iptables</code> (需要 <code>iptables-services</code> 包)，规则保存在 <code>/etc/sysconfig/iptables</code>。</li>\n<li><strong>恢复:</strong> <code>sudo iptables-restore &lt; /etc/iptables/rules.v4</code></li>\n<li><code>iptables-persistent</code> (Debian/Ubuntu):<ul>\n<li>安装: <code>sudo apt install iptables-persistent</code></li>\n<li>保存当前规则: <code>sudo netfilter-persistent save</code> (或 <code>sudo /etc/init.d/netfilter-persistent save</code>)</li>\n<li>系统启动时会自动加载。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"ufw-Uncomplicated-Firewall-🛡️\"><a href=\"#ufw-Uncomplicated-Firewall-🛡️\" class=\"headerlink\" title=\"ufw (Uncomplicated Firewall) 🛡️\"></a><code>ufw</code> (Uncomplicated Firewall) 🛡️</h3><p><strong>用途:</strong> 一个用户友好的 <code>iptables</code> 前端，旨在简化防火墙配置。</p>\n<p><strong>语法:</strong> <code>sudo ufw [选项] 命令</code></p>\n<p><strong>常用命令与选项:</strong></p>\n<ul>\n<li><p><strong>状态管理:</strong></p>\n<ul>\n<li><code>sudo ufw enable</code>: 启用防火墙 (并设置开机自启)。</li>\n<li><code>sudo ufw disable</code>: 禁用防火墙。</li>\n<li><code>sudo ufw status</code>: 查看防火墙状态和规则。</li>\n<li><code>sudo ufw status numbered</code>: 查看规则并显示编号。</li>\n<li><code>sudo ufw status verbose</code>: 查看详细状态。</li>\n<li><code>sudo ufw reload</code>: 重载防火墙规则 (不中断现有连接)。</li>\n<li><code>sudo ufw reset</code>: 重置防火墙到默认状态 (会禁用防火墙)。</li>\n</ul>\n</li>\n<li><p><strong>默认策略:</strong></p>\n<ul>\n<li><code>sudo ufw default deny incoming</code>: 拒绝所有入站连接 (推荐)。</li>\n<li><code>sudo ufw default allow outgoing</code>: 允许所有出站连接 (推荐)。</li>\n<li><code>sudo ufw default deny outgoing</code>: 拒绝所有出站连接。</li>\n<li><code>sudo ufw default deny routed</code>: 拒绝所有转发的包。</li>\n</ul>\n</li>\n<li><p><strong>规则管理 (allow/deny/reject/limit):</strong></p>\n<ul>\n<li><p><code>sudo ufw allow &lt;端口号&gt;[/协议]</code></p>\n<ul>\n<li>示例: <code>sudo ufw allow 22/tcp</code> (允许TCP 22端口)</li>\n<li>示例: <code>sudo ufw allow 53</code> (允许TCP和UDP 53端口)</li>\n</ul>\n</li>\n<li><p><code>sudo ufw allow &lt;服务名&gt;</code></p>\n<p> (服务名在 <code>/etc/services</code>中定义)</p>\n<ul>\n<li>示例: <code>sudo ufw allow ssh</code></li>\n<li>示例: <code>sudo ufw allow http</code></li>\n<li>示例: <code>sudo ufw allow https</code></li>\n</ul>\n</li>\n<li><p><code>sudo ufw deny &lt;端口号&gt;[/协议]</code></p>\n<ul>\n<li>示例: <code>sudo ufw deny 3306</code> (拒绝访问MySQL端口)</li>\n</ul>\n</li>\n<li><p><code>sudo ufw reject &lt;端口号&gt;[/协议]</code> (拒绝并返回消息)</p>\n</li>\n<li><p><code>sudo ufw limit &lt;端口号&gt;[/协议]</code></p>\n<p> (限制连接频率，如SSH，防止暴力破解：如果在30秒内尝试连接6次以上，则拒绝连接)</p>\n<ul>\n<li>示例: <code>sudo ufw limit ssh</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>基于源/目标IP的规则:</strong></p>\n<ul>\n<li><code>sudo ufw allow from &lt;IP地址&gt;</code><ul>\n<li>示例: <code>sudo ufw allow from 192.168.1.100</code></li>\n</ul>\n</li>\n<li><code>sudo ufw allow from &lt;IP地址&gt; to any port &lt;端口号&gt;</code><ul>\n<li>示例: <code>sudo ufw allow from 192.168.1.100 to any port 22 proto tcp</code></li>\n</ul>\n</li>\n<li><code>sudo ufw deny from &lt;IP地址&gt;</code><ul>\n<li>示例: <code>sudo ufw deny from 1.2.3.4</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>基于网络接口的规则:</strong></p>\n<ul>\n<li><code>sudo ufw allow in on &lt;接口名&gt; to any port &lt;端口号&gt;</code><ul>\n<li>示例: <code>sudo ufw allow in on eth1 to any port 80</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>删除规则:</strong></p>\n<ul>\n<li><p><code>sudo ufw delete &lt;规则定义&gt;</code></p>\n<ul>\n<li>示例: <code>sudo ufw delete allow 80</code></li>\n<li>示例: <code>sudo ufw delete allow from 1.2.3.4</code></li>\n</ul>\n</li>\n<li><p><code>sudo ufw delete &lt;规则编号&gt;</code></p>\n<p> (通过 <code>sudo ufw status numbered</code> 获取编号)</p>\n<ul>\n<li>示例: <code>sudo ufw delete 3</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>应用程序配置文件:</strong></p>\n<ul>\n<li><p><code>ufw</code> 可以使用应用程序配置文件 (位于 <code>/etc/ufw/applications.d</code>)。</p>\n</li>\n<li><p><code>sudo ufw app list</code>: 列出可用的应用程序配置文件。</p>\n</li>\n<li><p><code>sudo ufw app info &lt;应用名&gt;</code>: 显示应用程序配置文件的详细信息。</p>\n</li>\n<li><p><code>sudo ufw allow &lt;应用名&gt;</code></p>\n<p>: 允许应用程序配置文件中定义的所有规则。</p>\n<ul>\n<li>示例: <code>sudo ufw allow 'Nginx Full'</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>日志:</strong></p>\n<ul>\n<li><code>sudo ufw logging on [low|medium|high|full]</code></li>\n<li><code>sudo ufw logging off</code></li>\n<li>日志通常记录在 <code>/var/log/ufw.log</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例流程:</strong></p>\n<ol>\n<li><code>sudo ufw default deny incoming</code></li>\n<li><code>sudo ufw default allow outgoing</code></li>\n<li><code>sudo ufw allow ssh</code> (或 <code>sudo ufw allow 22/tcp</code>)</li>\n<li><code>sudo ufw allow http</code> (或 <code>sudo ufw allow 80/tcp</code>)</li>\n<li><code>sudo ufw allow https</code> (或 <code>sudo ufw allow 443/tcp</code>)</li>\n<li><code>sudo ufw enable</code></li>\n<li><code>sudo ufw status</code></li>\n</ol>\n<hr>\n<h3 id=\"firewall-cmd-Firewalld-Command-Line-Client-🔥-Zones\"><a href=\"#firewall-cmd-Firewalld-Command-Line-Client-🔥-Zones\" class=\"headerlink\" title=\"firewall-cmd (Firewalld Command Line Client) 🔥 Zones\"></a><code>firewall-cmd</code> (Firewalld Command Line Client) 🔥 Zones</h3><p><strong>用途:</strong> <code>firewalld</code> 服务的命令行客户端，是 RHEL/CentOS 7+ 和 Fedora 等发行版的默认防火墙管理工具。它使用 “区域 (zones)” 和 “服务 (services)” 的概念。</p>\n<p><strong>基本概念:</strong></p>\n<ul>\n<li><strong>Zones (区域):</strong> 网络连接可以被分配到不同的区域，每个区域有自己独立的防火墙规则集。预定义区域如 <code>public</code>, <code>home</code>, <code>work</code>, <code>dmz</code>, <code>internal</code>, <code>external</code>, <code>block</code>, <code>drop</code>, <code>trusted</code>。</li>\n<li><strong>Services (服务):</strong> 预定义的 XML 文件，描述了服务所需的端口和协议 (如 <code>ssh</code>, <code>http</code>)。</li>\n<li>Permanent vs Runtime Configuration:<ul>\n<li>默认情况下，<code>firewall-cmd</code> 修改的是运行时配置，重启后失效。</li>\n<li>添加 <code>--permanent</code> 选项可以修改永久配置，但需要 <code>firewall-cmd --reload</code> 或重启 <code>firewalld</code> 服务才能生效。</li>\n</ul>\n</li>\n</ul>\n<p><strong>语法:</strong> <code>sudo firewall-cmd [选项] [操作]</code></p>\n<p><strong>常用命令与选项:</strong></p>\n<ul>\n<li><p><strong>状态与管理:</strong></p>\n<ul>\n<li><code>sudo systemctl status firewalld</code>: 查看 <code>firewalld</code> 服务状态。</li>\n<li><code>sudo systemctl start firewalld</code>: 启动服务。</li>\n<li><code>sudo systemctl stop firewalld</code>: 停止服务。</li>\n<li><code>sudo systemctl enable firewalld</code>: 设置开机自启。</li>\n<li><code>sudo systemctl disable firewalld</code>: 禁止开机自启。</li>\n<li><code>sudo firewall-cmd --state</code>: 查看防火墙运行状态。</li>\n<li><code>sudo firewall-cmd --reload</code>: 重载防火墙规则 (不中断现有连接，使永久配置生效)。</li>\n<li><code>sudo firewall-cmd --complete-reload</code>: 完全重载 (中断现有连接)。</li>\n</ul>\n</li>\n<li><p><strong>区域管理:</strong></p>\n<ul>\n<li><code>sudo firewall-cmd --get-default-zone</code>: 获取默认区域。</li>\n<li><code>sudo firewall-cmd --set-default-zone=&lt;区域名&gt;</code>: 设置默认区域。</li>\n<li><code>sudo firewall-cmd --get-active-zones</code>: 获取当前活动的区域及其绑定的接口。</li>\n<li><code>sudo firewall-cmd --get-zones</code>: 列出所有可用区域。</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --list-all</code>: 列出指定区域的所有配置。</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --add-interface=&lt;接口名&gt;</code>: 将接口添加到指定区域 (运行时)。</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --add-interface=&lt;接口名&gt; --permanent</code>: 永久添加。</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --change-interface=&lt;接口名&gt;</code>: 修改接口所属区域。</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --remove-interface=&lt;接口名&gt;</code>: 从区域移除接口。</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --add-source=&lt;IP或子网&gt;</code>: 将源IP/子网添加到区域。</li>\n</ul>\n</li>\n<li><p><strong>服务管理:</strong></p>\n<ul>\n<li><code>sudo firewall-cmd --get-services</code>: 列出所有预定义的服务。</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --add-service=&lt;服务名&gt;</code> (运行时)</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --add-service=&lt;服务名&gt; --permanent</code> (永久)<ul>\n<li>示例: <code>sudo firewall-cmd --permanent --zone=public --add-service=http</code></li>\n</ul>\n</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --remove-service=&lt;服务名&gt;</code> (运行时)</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --remove-service=&lt;服务名&gt; --permanent</code> (永久)</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --list-services</code>: 列出区域中允许的服务。</li>\n</ul>\n<p><strong>端口管理:</strong></p>\n<ul>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --add-port=&lt;端口号&gt;/&lt;协议&gt;</code> (运行时)</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --add-port=&lt;端口号&gt;/&lt;协议&gt; --permanent</code>(永久)<ul>\n<li>示例: <code>sudo firewall-cmd --permanent --zone=public --add-port=8080/tcp</code></li>\n</ul>\n</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --remove-port=&lt;端口号&gt;/&lt;协议&gt;</code> (运行时)</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --remove-port=&lt;端口号&gt;/&lt;协议&gt; --permanent</code> (永久)</li>\n<li><code>sudo firewall-cmd --zone=&lt;区域名&gt; --list-ports</code>: 列出区域中允许的端口。</li>\n</ul>\n</li>\n<li><p><strong>Panic Mode:</strong></p>\n<ul>\n<li><code>sudo firewall-cmd --panic-on</code>: 紧急模式，丢弃所有入站和出站数据包。</li>\n<li><code>sudo firewall-cmd --panic-off</code>: 关闭紧急模式。</li>\n<li><code>sudo firewall-cmd --query-panic</code>: 查询紧急模式状态。</li>\n</ul>\n</li>\n<li><p><strong>Direct Rules (直接规则 - 类似iptables语法，不推荐常规使用):</strong></p>\n<ul>\n<li><code>sudo firewall-cmd --direct --add-rule ipv4 filter INPUT 0 -p tcp --dport 22 -j ACCEPT</code></li>\n</ul>\n</li>\n<li><p><strong>Rich Rules (富规则 - 更灵活的规则定义):</strong></p>\n<ul>\n<li><code>sudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.1.0/24\" service name=\"ssh\" accept'</code></li>\n<li><code>sudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"1.2.3.4\" reject'</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>示例流程 (public区域):</strong></p>\n<ol>\n<li><code>sudo systemctl start firewalld</code></li>\n<li><code>sudo systemctl enable firewalld</code></li>\n<li><code>sudo firewall-cmd --set-default-zone=public</code> (通常public是默认)</li>\n<li><code>sudo firewall-cmd --permanent --zone=public --add-service=ssh</code></li>\n<li><code>sudo firewall-cmd --permanent --zone=public --add-service=http</code></li>\n<li><code>sudo firewall-cmd --permanent --zone=public --add-service=https</code></li>\n<li><code>sudo firewall-cmd --permanent --zone=public --add-port=8080-8090/tcp</code> (允许一个端口范围)</li>\n<li><code>sudo firewall-cmd --reload</code></li>\n<li><code>sudo firewall-cmd --zone=public --list-all</code></li>\n</ol>\n<hr>\n<h2 id=\"八、常用配置文件与文本编辑器\"><a href=\"#八、常用配置文件与文本编辑器\" class=\"headerlink\" title=\"八、常用配置文件与文本编辑器\"></a>八、常用配置文件与文本编辑器</h2><h3 id=\"常见重要配置文件-⚙️\"><a href=\"#常见重要配置文件-⚙️\" class=\"headerlink\" title=\"常见重要配置文件 ⚙️\"></a>常见重要配置文件 ⚙️</h3><p>以下是一些Linux系统中常见的配置文件及其典型路径和用途：</p>\n<ul>\n<li><p><strong>/etc/passwd</strong>:</p>\n<ul>\n<li><strong>用途</strong>: 存储用户账户信息（如用户名、用户ID (UID)、组ID (GID)、用户描述、家目录路径、默认shell）。密码字段通常是一个<code>x</code>，表示加密后的密码存储在<code>/etc/shadow</code>中。</li>\n<li><strong>格式</strong>: <code>username:password_placeholder:UID:GID:comment:home_directory:login_shell</code></li>\n</ul>\n</li>\n<li><p><strong>/etc/shadow</strong>:</p>\n<ul>\n<li><p><strong>用途</strong>: 安全地存储用户加密后的密码和密码老化信息。此文件通常只有root用户可读。</p>\n</li>\n<li><p>格式: </p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">username:encrypted_password:last_password_change_date:min_password_age:max_password_age:warning_period:inactivity_period:expiration_date:reserved_field<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><code>encrypted_password</code>: <code>!</code> 或 <code>*</code> 表示账户被锁定或没有密码。</li>\n<li>日期字段通常是从1970年1月1日开始的天数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>/etc/group</strong>:</p>\n<ul>\n<li><strong>用途</strong>: 存储用户组信息（组名、组ID (GID)、组成员列表）。</li>\n<li><strong>格式</strong>: <code>group_name:password_placeholder:GID:user_list_comma_separated</code></li>\n</ul>\n</li>\n<li><p><strong>/etc/fstab</strong> (Filesystem Table):</p>\n<ul>\n<li><p><strong>用途</strong>: 定义磁盘分区、各种块设备或远程文件系统如何在系统启动时挂载到文件系统中，或者在需要时由 <code>mount -a</code> 命令挂载。</p>\n</li>\n<li><p>格式: </p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">device_spec mount_point fstype options dump pass_num<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><code>device_spec</code>: 设备（如<code>/dev/sda1</code>）或UUID（如<code>UUID=xxxxxxxx-xxxx...</code>）</li>\n<li><code>mount_point</code>: 挂载点（如<code>/</code>、<code>/home</code>、<code>/var</code>）</li>\n<li><code>fstype</code>: 文件系统类型（如<code>ext4</code>、<code>xfs</code>、<code>ntfs</code>、<code>nfs</code>）</li>\n<li><code>options</code>: 挂载选项（如<code>defaults</code>、<code>rw</code>、<code>ro</code>、<code>noatime</code>）</li>\n<li><code>dump</code>: <code>dump</code>工具是否备份（0或1）</li>\n<li><code>pass_num</code>: <code>fsck</code>检查文件系统的顺序（0表示不检查，1表示根文件系统，2表示其他）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>/etc/hosts</strong>:</p>\n<ul>\n<li><p><strong>用途</strong>: 提供静态的IP地址到主机名的映射。在DNS解析之前，系统会检查此文件。常用于本地测试或强制解析特定域名到特定IP。</p>\n</li>\n<li><p>格式: </p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">IP_address canonical_hostname <span class=\"token punctuation\">[</span>aliases<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>示例: <code>127.0.0.1 localhost loopback</code></li>\n<li>示例: <code>192.168.1.100 myserver myapp.local</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>/etc/resolv.conf</strong>:</p>\n<ul>\n<li><strong>用途</strong>: 配置DNS解析器，指定域名服务器（nameserver）的IP地址以及搜索域（search domain）。在许多现代发行版中，此文件可能由网络管理服务（如NetworkManager或systemd-resolved）动态生成和管理，不建议手动编辑。</li>\n<li>格式:<ul>\n<li><code>nameserver IP_address_of_DNS_server</code></li>\n<li><code>search domain1.com domain2.net</code></li>\n<li><code>options timeout:1</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>~/.bashrc</strong> (用户特定):</p>\n<ul>\n<li><strong>用途</strong>: Bash shell的用户特定配置文件。当用户启动一个新的交互式非登录shell时（如打开一个新的终端窗口），此文件中的命令会被执行。常用于设置别名、环境变量、自定义提示符等。</li>\n<li><strong>位置</strong>: 用户家目录下 (<code>~</code> 表示家目录，如 <code>/home/username/.bashrc</code>)</li>\n</ul>\n</li>\n<li><p><strong>/etc/profile</strong> (系统全局):</p>\n<ul>\n<li><strong>用途</strong>: Bash (及其他Bourne兼容shell) 的系统全局配置文件。当任何用户登录系统时（登录shell），此文件中的命令会被执行。它通常会调用 <code>/etc/profile.d/</code> 目录下的脚本。</li>\n<li><strong>注意</strong>: 修改此文件会影响系统所有用户。</li>\n</ul>\n</li>\n<li><p><strong>/etc/profile.d/*.sh</strong>:</p>\n<ul>\n<li><strong>用途</strong>: <code>/etc/profile</code> 通常会执行此目录下的所有 <code>.sh</code> 脚本，用于模块化地配置系统范围的环境变量和启动程序。</li>\n</ul>\n</li>\n<li><p><strong>/etc/bash.bashrc</strong> (系统全局，某些发行版):</p>\n<ul>\n<li><strong>用途</strong>: 系统全局的bashrc文件，为所有用户的交互式非登录shell执行。</li>\n</ul>\n</li>\n<li><p><strong>/var/log/syslog</strong> (Debian/Ubuntu) 或 <strong>/var/log/messages</strong> (RHEL/CentOS):</p>\n<ul>\n<li><strong>用途</strong>: 系统主要的日志文件，记录了内核消息、系统服务消息、以及各种应用程序的日志。是故障排除的重要来源。</li>\n<li><strong>管理</strong>: 通常由 <code>rsyslogd</code> 或 <code>syslog-ng</code> 服务管理。</li>\n</ul>\n</li>\n<li><p><strong>/etc/ssh/sshd_config</strong>:</p>\n<ul>\n<li><strong>用途</strong>: OpenSSH服务器 (sshd) 的配置文件。控制SSH服务的行为，如监听端口、是否允许root登录、认证方法等。</li>\n</ul>\n</li>\n<li><p><strong>/etc/sysctl.conf</strong>:</p>\n<ul>\n<li><strong>用途</strong>: 用于在系统启动时配置内核参数。<code>sysctl -p</code> 可以加载此文件中的设置。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"常用文本编辑器-📝\"><a href=\"#常用文本编辑器-📝\" class=\"headerlink\" title=\"常用文本编辑器 📝\"></a>常用文本编辑器 📝</h3><p>在Linux命令行下，最常用的文本编辑器是 <code>vi</code> (或其增强版 <code>vim</code>) 和 <code>nano</code>。</p>\n<h4 id=\"nano\"><a href=\"#nano\" class=\"headerlink\" title=\"nano\"></a><code>nano</code></h4><p><code>nano</code> 是一个简单易用的命令行文本编辑器，适合初学者。屏幕底部会显示常用快捷键。</p>\n<p><strong>启动:</strong></p>\n<ul>\n<li><code>nano 文件名</code> (如果文件不存在，则创建新文件)</li>\n<li><code>nano</code> (不带文件名，之后可保存为新文件)</li>\n</ul>\n<p><strong>常用快捷键 (Ctrl 代表 Control 键):</strong></p>\n<ul>\n<li><code>Ctrl + G</code>: 获取帮助 (显示所有快捷键)。</li>\n<li><code>Ctrl + O</code>: 保存文件 (Write Out)。会提示输入文件名，回车确认。</li>\n<li><code>Ctrl + X</code>: 退出 <code>nano</code>。如果文件已修改但未保存，会提示是否保存。</li>\n<li><code>Ctrl + W</code>: 搜索文本 (Where is)。</li>\n<li><code>Ctrl + \\</code>: 替换文本 (Replace)。</li>\n<li><code>Ctrl + K</code>:剪切当前行 (Cut Text)。</li>\n<li><code>Ctrl + U</code>: 粘贴剪切的文本 (Uncut Text)。</li>\n<li><code>Ctrl + C</code>: 显示当前光标位置 (行号、列号)。</li>\n<li><code>Ctrl + J</code>: 对齐当前段落 (Justify)。</li>\n<li><code>Ctrl + T</code>: 检查拼写 (需要安装 <code>spell</code> 包)。</li>\n<li><code>Alt + U</code>: 撤销上一次操作。</li>\n<li><code>Alt + E</code>: 重做上一次撤销的操作。</li>\n<li>方向键: 移动光标。</li>\n<li><code>PageUp / PageDown</code>: 上下翻页。</li>\n<li><code>Home / End</code>: 移动到行首/行尾。</li>\n</ul>\n<p><strong>示例:</strong> <code>sudo nano /etc/hosts</code> (编辑hosts文件，需要sudo权限)</p>\n<h4 id=\"vi-vim-Vi-IMproved\"><a href=\"#vi-vim-Vi-IMproved\" class=\"headerlink\" title=\"vi / vim (Vi IMproved)\"></a><code>vi</code> / <code>vim</code> (Vi IMproved)</h4><p><code>vi</code> 是一个功能强大的模态编辑器，学习曲线较陡峭，但熟练后效率极高。<code>vim</code> 是 <code>vi</code> 的增强版，提供了更多功能（如语法高亮、多级撤销等）。大多数现代系统实际上的 <code>vi</code> 命令是指向 <code>vim</code> 的。</p>\n<p><strong>模式:</strong></p>\n<ol>\n<li><strong>命令模式 (Command Mode):</strong> 默认模式。用于移动光标、删除文本、复制粘贴等操作。按键不会直接输入文本。</li>\n<li><strong>插入模式 (Insert Mode):</strong> 用于输入文本。从命令模式按 <code>i</code>, <code>a</code>, <code>o</code> 等键进入。按 <code>Esc</code> 键返回命令模式。</li>\n<li><strong>末行模式 (Last Line Mode / Ex Mode):</strong> 在命令模式下按 <code>:</code> 进入。用于执行保存、退出、搜索替换等命令。</li>\n</ol>\n<p><strong>启动:</strong></p>\n<ul>\n<li><code>vi 文件名</code> 或 <code>vim 文件名</code></li>\n</ul>\n<p><strong>基本操作 (命令模式下):</strong></p>\n<ul>\n<li>移动光标:<ul>\n<li><code>h</code>: 左</li>\n<li><code>j</code>: 下</li>\n<li><code>k</code>: 上</li>\n<li><code>l</code>: 右</li>\n<li><code>w</code>: 移动到下一个单词的开头</li>\n<li><code>b</code>: 移动到上一个单词的开头</li>\n<li><code>0</code> (零): 移动到当前行行首</li>\n<li><code>^</code>: 移动到当前行第一个非空白字符</li>\n<li><code>$</code>: 移动到当前行行尾</li>\n<li><code>gg</code>: 移动到文件第一行</li>\n<li><code>G</code>: 移动到文件最后一行</li>\n<li><code>行号G</code>: 移动到指定行号 (例如 <code>10G</code> 到第10行)</li>\n</ul>\n</li>\n<li>进入插入模式:<ul>\n<li><code>i</code>: 在当前光标前插入</li>\n<li><code>I</code>: 在当前行首插入</li>\n<li><code>a</code>: 在当前光标后追加</li>\n<li><code>A</code>: 在当前行尾追加</li>\n<li><code>o</code>: 在当前行下方插入一个新行</li>\n<li><code>O</code>: 在当前行上方插入一个新行</li>\n</ul>\n</li>\n<li>删除文本:<ul>\n<li><code>x</code>: 删除当前光标处的字符</li>\n<li><code>dw</code>: 删除一个单词 (从光标处到词尾)</li>\n<li><code>dd</code>: 删除当前行</li>\n<li><code>数字dd</code>: 删除从当前行开始的指定数量的行 (例如 <code>3dd</code> 删除3行)</li>\n<li><code>D</code>: 删除从光标到行尾的内容</li>\n</ul>\n</li>\n<li>复制 (Yank) 与粘贴 (Put):<ul>\n<li><code>yw</code>: 复制一个单词</li>\n<li><code>yy</code>: 复制当前行 (y 代表 yank)</li>\n<li><code>数字yy</code>: 复制多行</li>\n<li><code>p</code>: 在光标后粘贴 (小写p)</li>\n<li><code>P</code>: 在光标前粘贴 (大写P)</li>\n</ul>\n</li>\n<li>撤销与重做:<ul>\n<li><code>u</code>: 撤销上一次操作 (undo)</li>\n<li><code>Ctrl + r</code>: 重做上一次撤销的操作 (redo)</li>\n</ul>\n</li>\n<li>搜索:<ul>\n<li><code>/模式</code>: 向下搜索 “模式” (按 <code>n</code> 查找下一个, <code>N</code> 查找上一个)</li>\n<li><code>?模式</code>: 向上搜索 “模式”</li>\n</ul>\n</li>\n</ul>\n<p><strong>末行模式命令 (按 <code>:</code> 后输入):</strong></p>\n<ul>\n<li><code>:w</code>: 保存文件 (write)。</li>\n<li><code>:w 文件名</code>:另存为指定文件名。</li>\n<li><code>:q</code>: 退出 (quit)。如果文件已修改但未保存，会阻止退出。</li>\n<li><code>:q!</code>: 强制退出，不保存修改。</li>\n<li><code>:wq</code> 或 <code>:x</code>: 保存并退出。</li>\n<li><code>:e 文件名</code>: 编辑另一个文件。</li>\n<li><code>:set number</code> 或 <code>:set nu</code>: 显示行号。</li>\n<li><code>:set nonumber</code> 或 <code>:set nonu</code>: 关闭行号。</li>\n<li><code>:%s/旧字符串/新字符串/g</code>: 全局替换 (g代表global)。</li>\n<li><code>:%s/旧字符串/新字符串/gc</code>: 全局替换，每次替换前确认 (c代表confirm)。</li>\n<li><code>:!外部命令</code>: 执行外部shell命令 (例如 <code>:!ls -l</code>)。</li>\n</ul>\n<p><strong>示例:</strong> <code>sudo vim /etc/ssh/sshd_config</code></p>\n<p><strong>学习 <code>vim</code>:</strong></p>\n<ul>\n<li>可以在终端中运行 <code>vimtutor</code> 命令，这是一个交互式的 <code>vim</code> 教程。</li>\n</ul>\n<p>这只是 <code>vim</code> 功能的冰山一角，但足以应付日常的配置文件编辑。</p>\n",
            "tags": [
                "教程"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/06/01/ji-yu-x-ui-yu-cloudflare-da-jian-jie-dian/",
            "url": "https://0xdadream.github.io/2025/06/01/ji-yu-x-ui-yu-cloudflare-da-jian-jie-dian/",
            "title": "科学上网节点技术与实践：基于 X-UI 与 Cloudflare 的全面指南",
            "date_published": "2025-06-01T04:25:00.000Z",
            "content_html": "<h1 id=\"科学上网节点技术与实践：基于-X-UI-与-Cloudflare-的全面指南\"><a href=\"#科学上网节点技术与实践：基于-X-UI-与-Cloudflare-的全面指南\" class=\"headerlink\" title=\"科学上网节点技术与实践：基于 X-UI 与 Cloudflare 的全面指南\"></a>科学上网节点技术与实践：基于 X-UI 与 Cloudflare 的全面指南</h1><h2 id=\"第一部分：科学上网节点与核心概念概述\"><a href=\"#第一部分：科学上网节点与核心概念概述\" class=\"headerlink\" title=\"第一部分：科学上网节点与核心概念概述\"></a>第一部分：科学上网节点与核心概念概述</h2><h3 id=\"1-1-科学上网概述及其重要性\"><a href=\"#1-1-科学上网概述及其重要性\" class=\"headerlink\" title=\"1.1 科学上网概述及其重要性\"></a>1.1 科学上网概述及其重要性</h3><p>“科学上网”，通常指通过技术手段绕过互联网审查和地理限制，以访问全球开放信息资源的过程。在当前信息高度互联的时代，获取未经审查的、多元化的信息对于学术研究、技术创新以及文化交流至关重要。然而，常见的网络封锁技术，如IP地址封锁、域名系统 (DNS) 污染和深度包检测 (Deep Packet Inspection, DPI)，对信息的自由流通构成了挑战 。因此，理解和掌握科学上网技术，对于需要无障碍访问全球互联网资源的用户而言，具有实际意义。</p>\n<h3 id=\"1-2-核心技术：Xray-与-x-ui-面板\"><a href=\"#1-2-核心技术：Xray-与-x-ui-面板\" class=\"headerlink\" title=\"1.2 核心技术：Xray 与 x-ui 面板\"></a>1.2 核心技术：Xray 与 x-ui 面板</h3><p>Xray 是一个功能强大且灵活的网络代理核心，被广泛用于构建科学上网节点。它支持多种代理协议和复杂的路由功能，能够有效地帮助用户绕过网络审查 。与 Xray 配合使用的 x-ui (特别是 MHSanaei 维护的 3x-ui 分支) 是一个用户友好的图形化管理面板，它极大地简化了 Xray 节点的配置和管理过程，支持多用户、多协议管理，并提供流量统计、到期时间限制等功能 。</p>\n<h3 id=\"1-3-Cloudflare-的角色\"><a href=\"#1-3-Cloudflare-的角色\" class=\"headerlink\" title=\"1.3 Cloudflare 的角色\"></a>1.3 Cloudflare 的角色</h3><p>Cloudflare 是一家全球性的网络基础设施和安全公司，其提供的服务如内容分发网络 (CDN)、Workers（边缘计算）和 Tunnel（安全隧道）可以被巧妙地用于增强科学上网节点的隐蔽性和稳定性 。通过 Cloudflare，用户可以隐藏其代理服务器的真实IP地址，抵御分布式拒绝服务 (DDoS) 攻击，并在某些情况下改善连接速度和可靠性 。</p>\n<h3 id=\"1-4-关键术语解析\"><a href=\"#1-4-关键术语解析\" class=\"headerlink\" title=\"1.4 关键术语解析\"></a>1.4 关键术语解析</h3><p>理解以下术语对于掌握本教程至关重要：</p>\n<ul>\n<li><strong>TLS (Transport Layer Security) / SSL (Secure Sockets Layer):</strong> TLS 及其前身 SSL 是保障网络通信安全和数据完整性的加密协议 。它们通过在客户端和服务器之间建立加密通道，确保数据传输不被窃听或篡改。在科学上网中，TLS 常用于伪装代理流量，使其看起来像正常的 HTTPS 流量。</li>\n<li><strong>CDN (Content Delivery Network):</strong> 内容分发网络通过在全球部署边缘服务器来缓存网站内容，使用户可以从最近的服务器获取数据，从而提高网站加载速度并减少源服务器负载 。对于代理节点，CDN 可以隐藏源服务器 IP，并可能分散流量特征。</li>\n<li><strong>WebSocket:</strong> 一种在单个 TCP 连接上进行全双工通信的协议 。它允许服务器和客户端之间进行持续的、低延迟的双向数据交换。在代理中，WebSocket 常被用作一种传输方式，可以将代理流量封装在标准的 HTTP/HTTPS 端口（如 80 或 443）上传输，从而更好地伪装流量，并兼容 CDN 。</li>\n<li><strong>gRPC (Google Remote Procedure Call):</strong> 一个高性能、开源的通用 RPC 框架，使用 HTTP/2 作为传输协议，支持多种语言 。gRPC 因其高效的序列化（Protocol Buffers）和多路复用特性，在代理应用中可以提供较低的延迟和带宽消耗，尤其适合移动端应用。Cloudflare 支持 gRPC 流量的代理 。</li>\n<li><strong>REALITY:</strong> Xray 引入的一种新的出站/入站协议特性，旨在通过借用目标网站的 TLS 证书指纹来消除服务器端 TLS 指纹特征，从而增强抗检测能力，同时保持前向保密性 。它允许用户在不购买域名或配置 TLS 服务器的情况下，向审查者呈现一个真实可信的 SNI (Server Name Indication)。</li>\n<li><strong>XTLS:</strong> 一种旨在减少 VLESS 和 Trojan 等协议中 TLS 加密层级所带来性能开销的技术 。它通过在特定条件下（如 <code>flow</code> 设置为 <code>xtls-rprx-vision</code>）直接处理内层数据，避免了多次 TLS 加解密，从而提升传输效率。</li>\n<li><strong>uTLS (μTLS):</strong> 一个 TLS 库，允许应用程序模仿不同浏览器或操作系统的 TLS 指纹 。在代理客户端中使用 uTLS 可以帮助伪装连接发起者的真实身份，使其流量特征更接近普通浏览器行为，从而降被识别的风险。</li>\n</ul>\n<h2 id=\"第二部分：代理协议深度解析\"><a href=\"#第二部分：代理协议深度解析\" class=\"headerlink\" title=\"第二部分：代理协议深度解析\"></a>第二部分：代理协议深度解析</h2><p>本部分将详细探讨几种主流的科学上网代理协议的原理、特性、优缺点及其在 x-ui 中的应用。</p>\n<h3 id=\"2-1-Shadowsocks-SS\"><a href=\"#2-1-Shadowsocks-SS\" class=\"headerlink\" title=\"2.1 Shadowsocks (SS)\"></a>2.1 Shadowsocks (SS)</h3><ul>\n<li><strong>原理与工作机制:</strong> Shadowsocks 是一种基于 SOCKS5 代理的加密传输协议，最初由 clowwindy 于 2012 年为绕过中国的防火长城 (GFW) 而设计 。它通过在客户端和远程服务器之间创建一个加密隧道来工作。客户端将流量通过本地 SOCKS5 代理发送到 Shadowsocks 客户端软件，该软件对流量进行加密后发送到 Shadowsocks 服务器，服务器解密后再将流量转发至目标地址 。</li>\n<li><strong>安全特性:</strong> Shadowsocks 使用用户选择的加密算法（如 AES-256-GCM, ChaCha20-Poly1305）对数据进行加密 。较新的 Shadowsocks AEAD (Authenticated Encryption with Associated Data) 密码套件（如 2022-blake3-aes-256-gcm）提供了更强的安全性和抗重放攻击能力 。</li>\n<li><strong>性能特点:</strong> Shadowsocks 以其轻量级和高效率著称，对网络速度影响较小，能够提供较快的浏览和流媒体体验 。</li>\n<li><strong>混淆能力:</strong> Shadowsocks 本身并不侧重于复杂的流量混淆，其主要目标是加密。然而，由于其流量模式与标准协议不同，在早期能够有效绕过基于简单规则的检测。随着 DPI 技术的发展，单纯的 Shadowsocks 流量可能被识别。</li>\n<li>优缺点:<ul>\n<li><strong>优点:</strong> 设置相对简单，速度快，资源占用低，兼容性广（支持 Windows, macOS, Linux, Android, iOS）。</li>\n<li><strong>缺点:</strong> 协议特征相对明显，容易被高级 DPI 检测；不具备传统 VPN 的所有网络流量封装能力，仅代理通过其 SOCKS5 接口的流量 。</li>\n</ul>\n</li>\n<li><strong>x-ui 中的配置:</strong> 在 x-ui 中配置 Shadowsocks 时，主要参数包括加密方法、密码、监听端口和传输协议（通常是 TCP 和 UDP）。</li>\n</ul>\n<h3 id=\"2-2-VMess-Virtual-Mess\"><a href=\"#2-2-VMess-Virtual-Mess\" class=\"headerlink\" title=\"2.2 VMess (Virtual Mess)\"></a>2.2 VMess (Virtual Mess)</h3><ul>\n<li><strong>原理与工作机制:</strong> VMess 是 V2Ray 项目（Xray 的前身和兼容核心）设计的一种主要代理协议，旨在提供比 Shadowsocks 更强的安全性和混淆性 。它在客户端和服务器之间建立加密连接，并通过动态改变数据包结构来增加流量分析的难度 。</li>\n<li><strong>安全特性:</strong> VMess 使用对称加密（如 AES-128-GCM）和动态生成的会话 ID。它要求客户端和服务器共享精确的用户 ID (UUID) 和 alterId（用于改变加密方式）进行身份验证和加密 。</li>\n<li><strong>性能特点:</strong> VMess 由于其加密和动态特性，相比 Shadowsocks 会有一定的性能开销，但通常仍能提供良好的速度 。</li>\n<li><strong>混淆能力:</strong> VMess 的设计目标之一就是抗检测。其动态协议特性使得流量难以被简单模式匹配。结合 TLS 和 WebSocket 等传输方式可以进一步增强混淆效果 。</li>\n<li>传输方式:<ul>\n<li><strong>TCP:</strong> 基础的 TCP 传输，可配合 TLS 加密。</li>\n<li><strong>WebSocket (WS):</strong> 将 VMess 流量封装在 WebSocket 连接中，通常与 TLS 结合（VMess+WS+TLS），使其看起来像 HTTPS 流量，便于通过 CDN 中转和伪装 。</li>\n<li><strong>gRPC:</strong> 将 VMess 流量封装在 gRPC 连接中，利用 HTTP/2 的多路复用特性，可以提供高效的传输，同样可以结合 TLS 。</li>\n</ul>\n</li>\n<li>优缺点:<ul>\n<li><strong>优点:</strong> 安全性高，抗检测能力强于 Shadowsocks，支持多种传输方式，配置灵活 。</li>\n<li><strong>缺点:</strong> 配置相对复杂，性能开销略高于 Shadowsocks 和 VLESS 。</li>\n</ul>\n</li>\n<li><strong>x-ui 中的配置:</strong> 在 x-ui 中配置 VMess 时，需要设置用户 UUID、alterId、监听端口、传输方式（TCP, WS, gRPC 等），以及相应的 TLS 设置（域名、证书路径）或 WebSocket 设置（路径、Host）。</li>\n</ul>\n<h3 id=\"2-3-VLESS-Virtual-Less\"><a href=\"#2-3-VLESS-Virtual-Less\" class=\"headerlink\" title=\"2.3 VLESS (Virtual Less)\"></a>2.3 VLESS (Virtual Less)</h3><ul>\n<li><p><strong>原理与工作机制:</strong> VLESS 是在 VMess 基础上发展而来的一种更轻量级的传输协议，旨在简化协议本身并提高效率 。与 VMess 不同，VLESS 本身不包含加密和身份验证机制，而是依赖于外部传输层（如 TLS）来提供这些功能 。</p>\n</li>\n<li><p><strong>安全特性:</strong> VLESS 的安全性主要依赖于其底层的传输协议，如 TLS (XTLS) 或 REALITY。当与这些技术结合时，它可以提供非常高的安全性 。VLESS 本身不进行加密，这使得其头部特征更少，更难被检测。</p>\n</li>\n<li><p><strong>性能特点:</strong> 由于其极简设计和无内置加密，VLESS 的性能开销非常低，通常比 VMess 更快，延迟更低，尤其适合对速度要求高的场景 。</p>\n</li>\n<li><p>混淆能力:</p>\n<p> VLESS 的核心优势在于其简洁性，这使得其流量本身更难被识别。当结合 XTLS 或 REALITY 时，其混淆能力非常出色。</p>\n<ul>\n<li><strong>XTLS (XTLS-Vision, XTLS-RPRX-Direct):</strong> XTLS 是一种专为 VLESS 和 Trojan 设计的 TLS 增强技术，旨在通过优化 TLS 握手和数据传输路径，减少加密层级，从而显著提高性能，同时保持强大的安全性 。<code>xtls-rprx-vision</code> 是 XTLS 的一种流控模式。</li>\n<li><strong>REALITY:</strong> 如前所述，REALITY 通过借用真实网站的 TLS 证书指纹来消除服务器端的 TLS 特征，极大地增强了抗检测能力 。VLESS 是 REALITY 的理想搭配协议。</li>\n</ul>\n</li>\n<li><p>传输方式:</p>\n<ul>\n<li><strong>TCP:</strong> VLESS 可以直接通过 TCP 传输，通常与 XTLS 或 REALITY 结合使用。</li>\n<li><strong>WebSocket (WS):</strong> VLESS 同样可以封装在 WebSocket 中，并结合 TLS (VLESS+WS+TLS)，以利用 CDN 和伪装流量 。</li>\n<li><strong>gRPC:</strong> VLESS 也可以通过 gRPC 传输，并结合 TLS (VLESS+gRPC+TLS)，提供高效的多路复用连接。</li>\n</ul>\n</li>\n<li><p>优缺点:</p>\n<ul>\n<li><strong>优点:</strong> 性能极高，延迟低，配置相对 VMess 简单（当不考虑复杂的 XTLS/REALITY 时），灵活性强，抗检测能力强（尤其配合 REALITY）。</li>\n<li><strong>缺点:</strong> 依赖外部加密，如果底层传输（如裸 TCP）未加密则不安全；高级配置（如 REALITY）对理解有一定要求 。</li>\n</ul>\n</li>\n<li><p><strong>x-ui 中的配置:</strong> 在 x-ui 中配置 VLESS 时，主要设置用户 UUID、监听端口、传输方式（TCP, WS, gRPC），以及流控模式（如 <code>xtls-rprx-vision</code> for XTLS，或不设置流控用于普通 TLS/WS）。如果使用 TLS，需要配置域名和证书路径。如果使用 REALITY，需要配置 <code>dest</code>（目标伪装域名:端口）、<code>serverNames</code>（SNI）、<code>privateKey</code>、<code>shortIds</code> 等参数 。</p>\n</li>\n</ul>\n<h3 id=\"2-4-Trojan\"><a href=\"#2-4-Trojan\" class=\"headerlink\" title=\"2.4 Trojan\"></a>2.4 Trojan</h3><ul>\n<li><strong>原理与工作机制:</strong> Trojan 协议的设计目标是模仿互联网上最常见的 HTTPS 流量，使其难以被检测和干扰 。它通过在服务器上监听一个端口（通常是 443），并处理进来的 TLS 连接。如果连接是合法的 Trojan 请求（通过密码验证），则代理流量；否则，将流量转发到服务器上预设的真实网站（如本地 Nginx 服务），从而使服务器在外部探测下表现得像一个普通的 HTTPS 网站 。</li>\n<li><strong>安全特性:</strong> Trojan 强制使用 TLS 对所有流量进行加密，确保了传输的机密性和完整性。身份验证通过预共享的密码完成 。</li>\n<li><strong>性能特点:</strong> 由于其设计直接利用 TLS，避免了额外的封装层，Trojan 通常具有较好的性能，接近于直接的 HTTPS 连接 。</li>\n<li><strong>混淆能力:</strong> Trojan 的核心优势在于其出色的混淆能力。它通过完全模拟 HTTPS 行为，包括 TLS 握手和数据传输，使得 DPI 系统很难将其与正常的 HTTPS 流量区分开来 。</li>\n<li>传输方式:<ul>\n<li><strong>TCP (over TLS):</strong> 这是 Trojan 的标准工作方式，直接在 TLS 加密的 TCP 连接上传输代理数据。</li>\n<li><strong>gRPC:</strong> Trojan 也可以通过 gRPC 传输，并结合 TLS (Trojan+gRPC+TLS)，这可以利用 gRPC 的特性，同时保持 Trojan 的 HTTPS 伪装。</li>\n</ul>\n</li>\n<li>优缺点:<ul>\n<li><strong>优点:</strong> 伪装性极好，抗检测能力强，性能较好，设置相对简单（相比 VMess 的复杂配置）。</li>\n<li><strong>缺点:</strong> 依赖于有效的 TLS 证书和域名配置；如果密码泄露或配置不当，安全性会受影响。</li>\n</ul>\n</li>\n<li><strong>x-ui 中的配置:</strong> 在 x-ui 中配置 Trojan 时，需要设置密码、监听端口（通常 443）、域名（用于 TLS 证书）、证书和私钥路径。对于 gRPC 传输，还需要配置 <code>serviceName</code> 。</li>\n</ul>\n<h3 id=\"2-5-WireGuard\"><a href=\"#2-5-WireGuard\" class=\"headerlink\" title=\"2.5 WireGuard\"></a>2.5 WireGuard</h3><ul>\n<li><strong>原理与工作机制:</strong> WireGuard 是一种现代、高性能的 VPN 协议，旨在提供比传统 VPN 协议（如 OpenVPN, IPsec）更简单、更快速、更安全的解决方案 。它使用最先进的密码学技术，通过 UDP 传输数据，并在内核空间运行以提高效率 。WireGuard 通过公钥加密进行身份验证和密钥交换 。</li>\n<li><strong>安全特性:</strong> WireGuard 使用固定的密码套件，包括 ChaCha20进行对称加密，Poly1305进行消息认证，Curve25519进行椭圆曲线 Diffie-Hellman 密钥交换，BLAKE2s进行哈希 。这种固定的选择减少了因密码套件协商错误导致的安全风险。它还提供完美前向保密。</li>\n<li><strong>性能特点:</strong> WireGuard 以其极高的性能和低延迟著称，代码量小（Linux 内核模块约 4000 行代码），易于审计，且资源消耗低，非常适合移动设备和嵌入式系统 。</li>\n<li><strong>混淆能力:</strong> WireGuard 本身不以流量混淆为主要设计目标。其流量特征（基于 UDP）相对固定，虽然不像 HTTPS 那样普遍，但在某些网络环境下可能被识别或限制。它不具备像 Trojan 或 VLESS+REALITY 那样的 HTTPS 伪装能力。</li>\n<li>优缺点:<ul>\n<li><strong>优点:</strong> 速度极快，延迟低，安全性高，配置简单，代码量小，跨平台支持良好 。</li>\n<li><strong>缺点:</strong> 基于 UDP，可能在对 UDP 不友好的网络中表现不佳；协议相对较新，虽然经过广泛审计，但历史积淀不如 OpenVPN；隐私方面，默认配置下服务器会记录对端 IP，需要服务提供商额外处理以保护用户隐私 。</li>\n</ul>\n</li>\n<li><strong>x-ui 中的配置:</strong> 3x-ui 面板支持 WireGuard 作为一种入站协议 。配置通常涉及设置监听端口、服务器私钥、客户端公钥、分配给客户端的 IP 地址以及允许的 IP 范围等。x-ui 简化了这个过程，但具体的界面选项需要参考面板本身 。</li>\n</ul>\n<h3 id=\"协议资源消耗与演进趋势\"><a href=\"#协议资源消耗与演进趋势\" class=\"headerlink\" title=\"协议资源消耗与演进趋势\"></a>协议资源消耗与演进趋势</h3><p>在资源消耗方面，一般而言，VLESS 由于其极简设计，通常比 VMess 更轻量，CPU 和内存占用更低 。Shadowsocks 也是一种非常轻量级的协议 。WireGuard 因其内核态实现和高效密码学，资源消耗极低 。Trojan 协议由于直接利用 TLS，其资源消耗主要取决于 TLS 的实现，通常也比较高效。相比之下，VMess 由于其内置的加密和动态特性，可能会有稍高的资源占用。实际的资源消耗会受到并发连接数、流量大小、服务器硬件配置以及具体实现（如 Xray 核心的优化程度）等多种因素影响。根据 Istio（使用 Envoy 代理，与 Xray 角色类似）的数据，代理本身每秒处理 1000 个请求大约消耗 0.2 至 0.5 vCPU 和 40MB 至 60MB 内存 ，这可以作为一个大致的参考，但 Xray 的具体表现会有所不同。</p>\n<p>科学上网协议的演进清晰地反映了审查技术与反审查技术之间的持续博弈。最初的 Shadowsocks 提供了基础的加密代理功能。随着 DPI 技术对 Shadowsocks 特征的识别，V2Ray 项目及其核心协议 VMess 应运而生，提供了更强的混淆和灵活性。然而，VMess 的复杂性也带来了一定的性能开销和配置难度。随后，VLESS 协议以其“更少即是更多”的理念出现，通过剥离内置加密，依赖底层传输（如 TLS/XTLS/REALITY）来保证安全，从而实现了更高的性能和更强的隐蔽性 。XTLS 和 REALITY 等技术的出现，进一步提升了 VLESS 和 Trojan 等协议的性能与抗检测能力，代表了当前协议发展的前沿方向 。这种演进趋势表明，未来的协议发展将更加注重性能、安全性和伪装性的平衡，以及对不断变化的审查策略的适应能力。</p>\n<h2 id=\"第三部分：使用-x-ui-与-Cloudflare-搭建节点\"><a href=\"#第三部分：使用-x-ui-与-Cloudflare-搭建节点\" class=\"headerlink\" title=\"第三部分：使用 x-ui 与 Cloudflare 搭建节点\"></a>第三部分：使用 x-ui 与 Cloudflare 搭建节点</h2><p>本部分将详细指导如何在 VPS 上安装 x-ui 面板，并结合 Cloudflare 服务搭建各类型的科学上网节点。</p>\n<h3 id=\"3-1-VPS-与域名准备\"><a href=\"#3-1-VPS-与域名准备\" class=\"headerlink\" title=\"3.1 VPS 与域名准备\"></a>3.1 VPS 与域名准备</h3><ol>\n<li>选择 VPS (Virtual Private Server):<ul>\n<li>选择一个位于审查区域之外的 VPS 提供商。考虑因素包括服务器位置（影响延迟）、带宽、CPU、内存、价格以及提供商的声誉。建议选择 KVM 虚拟化的 VPS 。</li>\n<li>操作系统推荐选择较新的稳定版 Linux 发行版，如 Ubuntu 20.04/22.04, Debian 10/11, CentOS 7+ (尽管 CentOS 7 即将 EOL) 。</li>\n</ul>\n</li>\n<li>注册域名:<ul>\n<li>你需要一个域名用于配置 TLS 加密，特别是当使用 WebSocket、gRPC 或 REALITY 等需要域名验证的场景时。可以选择如 Namecheap, Porkbun 等域名注册商 。</li>\n</ul>\n</li>\n<li>基础服务器设置:<ul>\n<li>通过 SSH 连接到你的 VPS。</li>\n<li>更新系统软件包：<code>sudo apt update &amp;&amp; sudo apt upgrade -y</code> (以 Debian/Ubuntu 为例) 。</li>\n<li>安装必要工具，如 <code>curl</code> 和 <code>socat</code>：<code>sudo apt install curl socat -y</code> 。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-2-安装-x-ui-面板-MHSanaei-3x-ui\"><a href=\"#3-2-安装-x-ui-面板-MHSanaei-3x-ui\" class=\"headerlink\" title=\"3.2 安装 x-ui 面板 (MHSanaei/3x-ui)\"></a>3.2 安装 x-ui 面板 (MHSanaei/3x-ui)</h3><p>MHSanaei 的 3x-ui 是一个功能丰富的 Xray 管理面板。</p>\n<ol>\n<li><p>执行安装脚本:</p>\n<p>通过 SSH 连接到 VPS 后，运行以下命令安装最新版本的 3x-ui ：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">bash &lt;(curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>安装过程中，脚本可能会提示你设置面板的用户名、密码和访问端口 。如果选择不自定义，可能会随机生成。请务必记录这些信息。</p>\n</li>\n<li><p><strong>访问 x-ui 面板:</strong> 安装完成后，通过浏览器访问 <code>http://&lt;你的VPS_IP&gt;:&lt;面板端口&gt;</code> 来打开 x-ui 登录界面 。</p>\n</li>\n<li><p><strong>初始登录与安全设置:</strong> 使用安装时设置或脚本生成的用户名和密码登录。首次登录后，强烈建议立即修改默认的用户名和密码，并考虑修改面板的访问端口和一个随机的 URL 根路径（Web Base Path）以增强安全性 。这些设置通常在 x-ui 的“面板设置”中可以找到。可以通过在 VPS 终端运行 <code>x-ui</code> 命令来访问管理菜单，其中包括重置 Web Base Path 等选项 。</p>\n</li>\n</ol>\n<h3 id=\"3-3-SSL-证书管理\"><a href=\"#3-3-SSL-证书管理\" class=\"headerlink\" title=\"3.3 SSL 证书管理\"></a>3.3 SSL 证书管理</h3><p>为了启用 TLS 加密（对于 HTTPS 伪装和安全至关重要），你需要为你的域名获取 SSL 证书。</p>\n<ol>\n<li><p><strong>使用 x-ui 内置的 ACME 功能 (推荐):</strong></p>\n<ul>\n<li>确保你的域名已正确解析到 VPS 的 IP 地址（A 记录）。</li>\n<li>在 VPS 终端运行 <code>x-ui</code> 命令，选择“SSL 证书管理” (SSL Certificate Management) 。</li>\n<li>按照提示选择“获取 SSL”(Get SSL)，输入你的域名，脚本会自动尝试通过 Let’s Encrypt 等 ACME 提供商申请证书。</li>\n<li>申请成功后，证书和私钥文件通常会保存在服务器的特定路径（如 <code>/root/.acme.sh/yourdomain.com/</code> 或由 x-ui 指定的路径），并在 x-ui 面板中配置入站规则时引用这些路径。</li>\n<li>x-ui 通常支持自动续签申请到的证书 。</li>\n</ul>\n</li>\n<li><p><strong>使用 Certbot 手动申请 (备选方案):</strong></p>\n<ul>\n<li><p>在 VPS 上安装 Certbot ：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo apt install certbot python3-certbot-nginx # (或相应的 Apache 插件)\n# 或者更通用的方式\nsudo apt install software-properties-common\nsudo add-apt-repository ppa:certbot/certbot -y # 可能需要确认\nsudo apt update\nsudo apt install certbot -y<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>申请证书（以 standalone 模式为例，需要临时占用 80 端口；确保 Cloudflare DNS 记录此时为“DNS Only”）：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo certbot certonly --standalone --agree-tos --register-unsafely-without-email -d yourdomain.com<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>将 yourdomain.com 替换为你的域名。</p>\n</li>\n<li><p>成功后，证书和私钥路径通常为 <code>/etc/letsencrypt/live/yourdomain.com/fullchain.pem</code> 和 <code>/etc/letsencrypt/live/yourdomain.com/privkey.pem</code> 。</p>\n</li>\n<li><p>设置自动续签：Certbot 通常会自动创建 systemd timer 或 cron job 来处理续签。可以通过 <code>sudo certbot renew --dry-run</code> 测试续签。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>使用 Cloudflare 源服务器证书 (Origin Certificate):</strong></p>\n<ul>\n<li>在 Cloudflare 仪表盘的 “SSL/TLS” -&gt; “源服务器” 处创建源证书。Cloudflare 会提供证书和私钥。</li>\n<li>将这些证书和私钥内容上传到你的 VPS，并在 x-ui 中配置入站规则时直接粘贴内容或引用文件路径。</li>\n<li>这种方式下，Cloudflare 与你的源服务器之间的连接是加密的，但客户端到 Cloudflare 的连接仍需由 Cloudflare 提供的边缘证书处理。SSL/TLS 模式需设置为 “Full (Strict)”。</li>\n</ul>\n</li>\n<li><p><strong>通过 Cloudflare 获取 SSL (x-ui 功能):</strong></p>\n<ul>\n<li>如果你的域名通过 Cloudflare 解析，x-ui 的某些版本提供了通过 Cloudflare API 直接申请 SSL 证书的功能 。</li>\n<li>这需要你的 Cloudflare 注册邮箱和 Global API Key。在 x-ui 命令行菜单中选择“Cloudflare SSL 证书”并按提示操作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-4-x-ui-基础节点配置-不使用-Cloudflare-CDN-Tunnel\"><a href=\"#3-4-x-ui-基础节点配置-不使用-Cloudflare-CDN-Tunnel\" class=\"headerlink\" title=\"3.4 x-ui 基础节点配置 (不使用 Cloudflare CDN/Tunnel)\"></a>3.4 x-ui 基础节点配置 (不使用 Cloudflare CDN/Tunnel)</h3><p>登录 x-ui 面板后，进入“入站列表”(Inbounds) 页面，点击“添加入站”(Add Inbound) 来创建新的代理节点。以下是一些常见协议的配置要点：</p>\n<h4 id=\"3-4-1-VLESS-TCP-XTLS-Vision-REALITY\"><a href=\"#3-4-1-VLESS-TCP-XTLS-Vision-REALITY\" class=\"headerlink\" title=\"3.4.1 VLESS + TCP + XTLS (Vision/REALITY)\"></a>3.4.1 VLESS + TCP + XTLS (Vision/REALITY)</h4><p>这是目前推荐的高性能、高隐蔽性配置之一。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 给连接起一个描述性名称，如 <code>VLESS-XTLS-Direct</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>vless</code> 。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空表示监听所有可用 IP 地址。</li>\n<li><strong>端口 (Port):</strong> 推荐使用 <code>443</code> 。</li>\n<li><strong>用户ID (ID / UUID):</strong> x-ui 会自动生成一个 UUID，保持默认即可。这是客户端连接的凭证。</li>\n<li>流控 (Flow):<ul>\n<li>对于 XTLS Vision: 选择 <code>xtls-rprx-vision</code> 。</li>\n</ul>\n</li>\n<li><strong>传输 (Transport / Network):</strong> 选择 <code>tcp</code> 。</li>\n<li>TLS 设置:<ul>\n<li><strong>启用 TLS (Enable TLS):</strong> <em>不勾选</em> (因为 XTLS/REALITY 有自己的 TLS 处理机制)。</li>\n<li><strong>启用 XTLS (Enable XTLS):</strong> <em>勾选</em> (如果使用 XTLS Vision)。</li>\n</ul>\n</li>\n<li>REALITY 设置 (如果选择 REALITY 而非 XTLS Vision):<ul>\n<li>在 x-ui 面板中，通常 VLESS 协议下会有专门的 REALITY 安全设置区域 。</li>\n<li><strong>接受代理协议 (Accept Proxy Protocol):</strong> 可能需要勾选此项或类似选项来启用 REALITY 特有的参数 。</li>\n<li><strong>目标地址 (Dest):</strong> 填写一个真实存在的、支持 TLSv1.3 和 H2 的境外网站域名和端口，例如 <code>www.microsoft.com:443</code> 或 <code>dl.google.com:443</code> 。</li>\n<li><strong>Server Names (SNI):</strong> 填写目标地址对应的域名，例如 <code>www.microsoft.com</code> 或 <code>dl.google.com</code> 。</li>\n<li><strong>私钥 (Private Key):</strong> 点击面板上的“生成新证书”或类似按钮生成 X25519 密钥对，这里填入私钥 1。公钥会自动生成或需要一并记录给客户端。</li>\n<li><strong>Short IDs:</strong> 可以留空或生成一个随机的 Short ID，用于区分客户端 。</li>\n<li><strong>uTLS 指纹 (uTLS):</strong> 选择一个浏览器指纹，如 <code>chrome</code> 或 <code>firefox</code> 。</li>\n</ul>\n</li>\n<li><strong>域名 (Domain name):</strong> 对于 XTLS Vision（非 REALITY），你需要填写真实申请过 SSL 证书的域名 。</li>\n<li><strong>证书公钥文件路径 (Certificate File Path / Public key file path):</strong> 填写 SSL 证书的 <code>fullchain.pem</code> 文件路径 。</li>\n<li><strong>证书私钥文件路径 (Key File Path / Private key file path):</strong> 填写 SSL 证书的 <code>privkey.pem</code> 文件路径 。</li>\n</ul>\n<h4 id=\"3-4-2-VMess-TCP-TLS\"><a href=\"#3-4-2-VMess-TCP-TLS\" class=\"headerlink\" title=\"3.4.2 VMess + TCP + TLS\"></a>3.4.2 VMess + TCP + TLS</h4><p>这种配置提供了较好的安全性和伪装性。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 例如 <code>VMess-TCP-TLS</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>vmess</code> 。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空。</li>\n<li><strong>端口 (Port):</strong> 推荐 <code>443</code>。</li>\n<li><strong>用户ID (UUID):</strong> 自动生成，保持默认。</li>\n<li><strong>额外ID (AlterID):</strong> 设置一个数字，如 <code>0</code> (较新版本 Xray 中 alterId 作用减弱，可以设为0或较低值)。</li>\n<li><strong>加密方式 (Security):</strong> 通常保持默认（如 <code>auto</code> 或 <code>aes-128-gcm</code>）。</li>\n<li><strong>传输 (Transport / Network):</strong> 选择 <code>tcp</code>。</li>\n<li>TLS 设置:<ul>\n<li><strong>启用 TLS (Enable TLS):</strong> <em>勾选</em> 。</li>\n<li><strong>域名 (Domain name):</strong> 填写你拥有并已申请 SSL 证书的域名。</li>\n<li><strong>证书公钥文件路径 (Certificate File Path):</strong> 填写 SSL 证书的 <code>fullchain.pem</code> 文件路径。</li>\n<li><strong>证书私钥文件路径 (Key File Path):</strong> 填写 SSL 证书的 <code>privkey.pem</code> 文件路径。</li>\n<li><strong>ALPN:</strong> 可以留空或根据需要填写 (如 <code>h2,http/1.1</code>)。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-4-3-Trojan-TCP-TLS\"><a href=\"#3-4-3-Trojan-TCP-TLS\" class=\"headerlink\" title=\"3.4.3 Trojan + TCP + TLS\"></a>3.4.3 Trojan + TCP + TLS</h4><p>Trojan 以其优秀的 HTTPS 伪装著称。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 例如 <code>Trojan-TCP-TLS</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>trojan</code> 。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空。</li>\n<li><strong>端口 (Port):</strong> 必须是 <code>443</code> 以获得最佳伪装效果。</li>\n<li><strong>密码 (Password):</strong> 设置一个强密码，客户端连接时需要使用。</li>\n<li><strong>传输 (Transport / Network):</strong> 选择 <code>tcp</code>。</li>\n<li>TLS 设置:<ul>\n<li><strong>启用 TLS (Enable TLS):</strong> <em>勾选</em>。</li>\n<li><strong>域名 (Domain name):</strong> 填写你拥有并已申请 SSL 证书的域名。</li>\n<li><strong>证书公钥文件路径 (Certificate File Path):</strong> 填写 SSL 证书的 <code>fullchain.pem</code> 文件路径。</li>\n<li><strong>证书私钥文件路径 (Key File Path):</strong> 填写 SSL 证书的 <code>privkey.pem</code> 文件路径。</li>\n<li><strong>ALPN:</strong> 建议填写 <code>h2,http/1.1</code> 以更好地模拟 HTTPS 流量。</li>\n<li><strong>Fallback (回落):</strong> 可以配置一个回落地址（如本地运行的 Web 服务器 <code>127.0.0.1:80</code>），当非 Trojan 协议访问该端口时，流量会被转发到此地址，增强伪装性。x-ui 中可能有相应配置项。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-4-4-Shadowsocks-AEAD-Ciphers\"><a href=\"#3-4-4-Shadowsocks-AEAD-Ciphers\" class=\"headerlink\" title=\"3.4.4 Shadowsocks (AEAD Ciphers)\"></a>3.4.4 Shadowsocks (AEAD Ciphers)</h4><p>简单高效的选择。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 例如 <code>SS-AEAD</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>shadowsocks</code> 。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空。</li>\n<li><strong>端口 (Port):</strong> 选择一个未被占用的端口。</li>\n<li><strong>密码 (Password):</strong> 设置一个强密码。</li>\n<li><strong>加密方式 (Encryption / Cipher):</strong> 强烈推荐使用 AEAD 加密，如 <code>2022-blake3-aes-256-gcm</code> (如果 x-ui 和客户端支持) 或 <code>aes-256-gcm</code>, <code>chacha20-ietf-poly1305</code> 。避免使用旧的非 AEAD 加密方式。</li>\n<li><strong>传输 (Network):</strong> 可以选择 <code>tcp</code> 或 <code>tcp,udp</code> 。</li>\n</ul>\n<h4 id=\"3-4-5-WireGuard\"><a href=\"#3-4-5-WireGuard\" class=\"headerlink\" title=\"3.4.5 WireGuard\"></a>3.4.5 WireGuard</h4><p>3x-ui 支持 WireGuard 作为入站协议 。</p>\n<ul>\n<li><strong>备注 (Remark):</strong> 例如 <code>WireGuard-VPN</code>。</li>\n<li><strong>协议 (Protocol):</strong> 选择 <code>wireguard</code>。</li>\n<li><strong>监听IP (Listen IP):</strong> 留空。</li>\n<li><strong>端口 (Port):</strong> WireGuard 默认使用 UDP 协议，端口通常为 <code>51820</code>，但可以自定义。</li>\n<li><strong>私钥 (Private Key):</strong> 服务器的 WireGuard 私钥。x-ui 可能会自动生成或提供生成按钮。</li>\n<li><strong>公钥 (Public Key):</strong> 服务器的 WireGuard 公钥（由私钥派生）。</li>\n<li><strong>IP 地址 (Addresses):</strong> 分配给 WireGuard 服务器接口的内部 IP 地址和子网掩码，例如 <code>10.0.8.1/24</code>。</li>\n<li><strong>MTU:</strong> 通常保持默认或根据网络情况调整。</li>\n<li><strong>DNS:</strong> 可以指定推送给客户端的 DNS 服务器。</li>\n<li>对等端 (Peers) / 用户 (Clients):<ul>\n<li>为每个客户端生成独立的密钥对（公钥和私钥）。</li>\n<li>在服务器端添加客户端的公钥。</li>\n<li>为客户端分配一个隧道内的 IP 地址（如 <code>10.0.8.2</code>）。</li>\n<li>配置 <code>AllowedIPs</code>：对于客户端，通常设为 <code>0.0.0.0/0, ::/0</code> 以路由所有流量通过 VPN。在服务器端，对应客户端的 <code>AllowedIPs</code> 设为其分配的隧道 IP (如 <code>10.0.8.2/32</code>)。</li>\n</ul>\n</li>\n</ul>\n<p><strong>重要提示:</strong> 上述 x-ui 面板中的具体选项名称可能因 3x-ui 版本略有不同。请以你实际使用的面板界面为准。配置完成后，务必点击“添加”或“保存”并根据提示重启 Xray 服务使配置生效。</p>\n<h3 id=\"3-5-集成-Cloudflare-CDN-适用于-WebSocket-和-gRPC-节点\"><a href=\"#3-5-集成-Cloudflare-CDN-适用于-WebSocket-和-gRPC-节点\" class=\"headerlink\" title=\"3.5 集成 Cloudflare CDN (适用于 WebSocket 和 gRPC 节点)\"></a>3.5 集成 Cloudflare CDN (适用于 WebSocket 和 gRPC 节点)</h3><p>将 Cloudflare CDN 置于代理服务器之前，可以隐藏源服务器 IP、防御 DDoS 攻击，并可能为特定地区用户加速。这主要适用于基于 WebSocket 或 gRPC 的传输方式，因为它们能更好地兼容 HTTP/HTTPS 流量模式。</p>\n<ol>\n<li><strong>Cloudflare DNS 设置:</strong><ul>\n<li>登录 Cloudflare 账户，选择你的域名。</li>\n<li>进入 “DNS” 管理页面。</li>\n<li>添加一个 A 记录，将你的域名（或子域名，如 <code>proxy.yourdomain.com</code>）指向你的 VPS IP 地址 。</li>\n<li><strong>关键步骤 - SSL 证书申请期间:</strong> 在申请 SSL 证书（无论是通过 x-ui 的 ACME 还是手动用 Certbot）时，必须确保此 DNS 记录的“代理状态”(Proxy status) 为“仅限 DNS”(DNS Only)，即云朵图标为灰色 。这是因为 Let’s Encrypt 等 CA 需要直接验证你的服务器 IP。</li>\n<li><strong>关键步骤 - 启用 CDN:</strong> SSL 证书成功获取并配置到 x-ui 后，回到 Cloudflare DNS 设置页面，将该 A 记录的“代理状态”切换为“已代理”(Proxied)，即云朵图标变为橙色。这样流量才会经过 Cloudflare CDN 。</li>\n</ul>\n</li>\n<li><strong>Cloudflare SSL/TLS 模式:</strong><ul>\n<li>在 Cloudflare 仪表盘的 “SSL/TLS” -&gt; “概述” (Overview) 页面，将 SSL/TLS 加密模式设置为 <strong>“Full (Strict)”</strong> (完全（严格）) 。这确保浏览器到 Cloudflare 以及 Cloudflare 到源服务器的连接都是严格加密和验证的。</li>\n</ul>\n</li>\n<li><strong>在 Cloudflare 网络设置中启用 WebSocket 和 gRPC:</strong><ul>\n<li>在 Cloudflare 仪表盘的 “网络” (Network) 页面：<ul>\n<li>确保 “WebSockets” 开关已打开（通常默认开启）。</li>\n<li>如果使用 gRPC 传输，确保 “gRPC” 开关已打开 。</li>\n</ul>\n</li>\n<li><strong>gRPC 要求:</strong> 源服务器上的 gRPC 端点必须监听 443 端口，支持 TLS 和 HTTP/2，并通过 ALPN 广播 HTTP/2。请求的 <code>Content-Type</code> 头部应为 <code>application/grpc</code> 或 <code>application/grpc+&lt;message_type&gt;</code> 。</li>\n</ul>\n</li>\n<li><strong>x-ui 配置 VLESS + WebSocket + TLS + CDN:</strong><ul>\n<li>在 x-ui 中添加入站：<ul>\n<li><strong>协议 (Protocol):</strong> <code>vless</code>。</li>\n<li><strong>端口 (Port):</strong> 设置一个源服务器上的监听端口，例如 <code>8443</code> (或其他非 443 端口，因为 443 由 Cloudflare 面向公网)。</li>\n<li><strong>传输 (Transport / Network):</strong> 选择 <code>ws</code> (WebSocket) 。</li>\n<li><strong>路径 (Path):</strong> 设置一个 WebSocket 路径，例如 <code>/myvlessws</code>。这个路径需要隐蔽一些，不要使用过于常见的词汇。</li>\n<li><strong>Host (请求头):</strong> 填写你在 Cloudflare DNS 中设置并开启代理的域名（如 <code>proxy.yourdomain.com</code>）。</li>\n<li>TLS 设置:<ul>\n<li><strong>启用 TLS (Enable TLS):</strong> <em>勾选</em>。</li>\n<li><strong>域名 (Domain name):</strong> 填写你的域名（<code>proxy.yourdomain.com</code>）。</li>\n<li><strong>证书公钥文件路径 (Certificate File Path):</strong> 填写之前申请的 SSL 证书的 <code>fullchain.pem</code> 路径。</li>\n<li><strong>证书私钥文件路径 (Key File Path):</strong> 填写 SSL 证书的 <code>privkey.pem</code> 路径。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>客户端连接时，地址填 <code>proxy.yourdomain.com</code>，端口填 <code>443</code> (Cloudflare 的端口)，传输选 WebSocket，路径填 <code>/myvlessws</code>，底层传输安全选 TLS，SNI/Host 填 <code>proxy.yourdomain.com</code>。</li>\n</ul>\n</li>\n<li><strong>x-ui 配置 VMess + WebSocket + TLS + CDN:</strong><ul>\n<li>配置方法与 VLESS+WS+TLS 类似 ：<ul>\n<li><strong>协议 (Protocol):</strong> <code>vmess</code>。</li>\n<li><strong>端口 (Port):</strong> 源服务器监听端口，如 <code>8443</code>。</li>\n<li><strong>传输 (Transport / Network):</strong> <code>ws</code>。</li>\n<li><strong>路径 (Path):</strong> 例如 <code>/myvmessws</code>。</li>\n<li><strong>Host (请求头):</strong> 你的 CDN 域名。</li>\n<li><strong>TLS 设置:</strong> 同上，使用你的域名和证书。</li>\n</ul>\n</li>\n<li>客户端连接参数类似，注意协议选择 VMess 并填写 UUID 和 AlterID。</li>\n</ul>\n</li>\n<li><strong>x-ui 配置 Trojan + gRPC + TLS + CDN:</strong><ul>\n<li><strong>协议 (Protocol):</strong> <code>trojan</code>。</li>\n<li><strong>端口 (Port):</strong> 源服务器监听端口，如 <code>8443</code>。</li>\n<li><strong>传输 (Transport / Network):</strong> <code>grpc</code>。</li>\n<li><strong>gRPC 服务名称 (serviceName / Service Name):</strong> 设置一个服务名称，例如 <code>mytrojangrpc</code>。客户端连接时需要匹配。</li>\n<li><strong>TLS 设置:</strong> 同上，使用你的域名和证书。</li>\n<li>客户端连接时，地址填 CDN 域名，端口 <code>443</code>，传输选 gRPC，服务名称填 <code>mytrojangrpc</code>，底层传输安全选 TLS，SNI 填 CDN 域名。</li>\n<li><strong>Cloudflare gRPC 注意事项:</strong> Cloudflare WAF 对 gRPC 内容的检查有限，主要在连接阶段进行头部检查 。</li>\n</ul>\n</li>\n<li><strong>x-ui 配置 VLESS + gRPC + TLS + CDN:</strong><ul>\n<li>配置方法与 Trojan+gRPC+TLS 类似：<ul>\n<li><strong>协议 (Protocol):</strong> <code>vless</code>。</li>\n<li><strong>端口 (Port):</strong> 源服务器监听端口，如 <code>8443</code>。</li>\n<li><strong>传输 (Transport / Network):</strong> <code>grpc</code>。</li>\n<li><strong>gRPC 服务名称 (serviceName / Service Name):</strong> 例如 <code>myvlessgrpc</code>。</li>\n<li><strong>TLS 设置:</strong> 同上。</li>\n</ul>\n</li>\n<li>客户端连接参数类似。</li>\n</ul>\n</li>\n</ol>\n<p>使用 Cloudflare CDN 的主要好处是隐藏了源服务器的真实 IP 地址，这对于防止 IP 被直接攻击或封锁至关重要。此外，Cloudflare 的全球网络节点可以为地理位置较远的用户提供一定的访问速度优化（通过缓存静态内容和更优的路由，尽管对于动态代理流量，缓存效果有限）。同时，Cloudflare 也提供了基础的 DDoS 防护。然而，所有流量都经过 Cloudflare 网络，意味着 Cloudflare 有能力检查（在一定程度上，特别是对于未加密或解密后的流量）和记录这些流量，并且其自身也可能因为合规原因对特定类型的流量进行限制或阻断 。这是一个需要在便利性和潜在风险之间进行权衡的因素。</p>\n<h3 id=\"3-6-使用-Cloudflare-Workers-作为代理层\"><a href=\"#3-6-使用-Cloudflare-Workers-作为代理层\" class=\"headerlink\" title=\"3.6 使用 Cloudflare Workers 作为代理层\"></a>3.6 使用 Cloudflare Workers 作为代理层</h3><p>Cloudflare Workers 允许在 Cloudflare 的边缘节点上运行 JavaScript (或其他编译到 WebAssembly 的语言) 代码，可以用来拦截和修改请求/响应，或将请求代理到后端服务。</p>\n<ol>\n<li><p><strong>基本原理:</strong> 创建一个 Worker 脚本，该脚本接收来自客户端的请求，然后将这些请求转发到你的 Xray 源服务器。对于 WebSocket 流量，Worker 需要特殊处理以正确建立和维持双向连接。</p>\n</li>\n<li><p>Worker 脚本示例 (通用 WebSocket 代理):</p>\n<p>以下是一个非常基础的通用 WebSocket 代理 Worker 脚本的逻辑框架。请注意，直接代理任意 Xray 协议流量可能违反 Cloudflare 服务条款 ，且此脚本需要根据实际 Xray 配置（如路径、头部）进行调整。</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">//addEventListener(\"fetch\", event =&gt; {\n//  event.respondWith(handleRequest(event.request))\n//})\n//\n//async function handleRequest(request) {\n//  const url = new URL(request.url);\n//  const upgradeHeader = request.headers.get('Upgrade');\n//\n//  // 后端 Xray 服务器地址和端口，以及预期的 WebSocket 路径\n//  const backendHost = 'your_vps_ip_or_hidden_domain'; // 不应是 Cloudflare CDN 域名\n//  const backendPort = your_xray_ws_listen_port; // Xray WS 入站监听的真实端口\n//  const backendPath = '/your_xray_ws_path'; // Xray WS 入站配置的路径\n//\n//  // 构建后端 URL\n//  let backendUrl = `wss://&lt;span class=\"math-inline\"&gt;\\{backendHost\\}\\:&lt;/span&gt;{backendPort}${backendPath}`;\n//  if (url.protocol === 'http:') {\n//      backendUrl = `ws://&lt;span class=\"math-inline\"&gt;\\{backendHost\\}\\:&lt;/span&gt;{backendPort}${backendPath}`;\n//  }\n//\n//  if (upgradeHeader &amp;&amp; upgradeHeader.toLowerCase() === 'websocket') {\n//    // 处理 WebSocket 升级请求\n//    const [client, server] = Object.values(new WebSocketPair());\n//    server.accept();\n//\n//    try {\n//      const wsBackend = new WebSocket(backendUrl, request.headers); // 将原始请求头传给后端\n//\n//      wsBackend.addEventListener('open', () =&gt; {\n//        // 后端连接打开\n//      });\n//\n//      wsBackend.addEventListener('message', event =&gt; {\n//        server.send(event.data); // 从后端收到消息，转发给客户端\n//      });\n//\n//      wsBackend.addEventListener('close', event =&gt; {\n//        server.close(event.code, event.reason); // 后端关闭，关闭客户端连接\n//      });\n//\n//      wsBackend.addEventListener('error', event =&gt; {\n//        server.close(1011, 'Backend WebSocket error'); // 后端错误\n//      });\n//\n//      server.addEventListener('message', event =&gt; {\n//        wsBackend.send(event.data); // 从客户端收到消息，转发给后端\n//      });\n//\n//      server.addEventListener('close', event =&gt; {\n//        wsBackend.close(event.code, event.reason); // 客户端关闭，关闭后端连接\n//      });\n//\n//      server.addEventListener('error', event =&gt; {\n//        wsBackend.close(1011, 'Client WebSocket error'); // 客户端错误\n//      });\n//\n//      return new Response(null, { status: 101, webSocket: client });\n//    } catch (e) {\n//      return new Response('WebSocket backend connection failed: ' + e.toString(), { status: 502 });\n//    }\n//  } else {\n//    // 对于非 WebSocket 请求，可以直接转发或返回错误\n//    // 如果 Xray 配置了 HTTP 回落，这里可以尝试转发 HTTP 请求\n//    // url.hostname = backendHost; // 注意：这仅适用于 HTTP 代理，不适用于 Xray 协议本身\n//    // url.port = backendPort.toString();\n//    // return fetch(new Request(url, request));\n//    return new Response('This Worker is for WebSocket proxying.', { status: 400 });\n//  }\n//}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意:</p>\n<p> 上述脚本是一个高度简化的示例，用于说明概念。实际用于 Xray 的 Worker 脚本可能需要更复杂的逻辑来处理特定的 Xray WebSocket 路径、头部信息（如 Host头部需要正确设置为 Xray 配置中的值）以及可能的认证。</p>\n<p><code>keivanipchihagh/x-ui</code> 仓库中可能包含更具体的 Worker 脚本 (scripts/worker.js)，建议参考其实现 。Cloudflare 官方文档也提供了 WebSocket 处理的示例 。</p>\n</li>\n<li><p>部署和路由设置:</p>\n<ul>\n<li>在 Cloudflare 仪表盘创建 Worker，将上述脚本（或适配后的脚本）粘贴进去并部署 。</li>\n<li>为 Worker 配置一个路由，例如 <code>worker.yourdomain.com/</code>，这样访问此路径的流量会由 Worker 处理。</li>\n</ul>\n</li>\n<li><p>Xray 入站配置:</p>\n<ul>\n<li>Xray 的 WebSocket 入站配置应监听一个本地端口（或可被 Worker 访问的地址），其路径和 Host 设置需要与 Worker 脚本转发时的目标一致。TLS 可以在源服务器上配置，也可以由 Worker 到源服务器的连接处理（如果源服务器配置了 TLS）。</li>\n</ul>\n</li>\n<li><p>优缺点:</p>\n<ul>\n<li><strong>优点:</strong> 灵活性高，可以自定义请求处理逻辑，实现更复杂的伪装。IP 地址由 Cloudflare Worker 提供。</li>\n<li><strong>缺点:</strong> Worker 有执行时间、CPU 时间和内存限制。配置比 CDN 复杂。同样存在 Cloudflare 服务条款的适用问题。</li>\n</ul>\n</li>\n</ol>\n<p>Cloudflare Workers 提供了一种比传统 CDN 更细致的流量控制和伪装能力。例如，Worker 可以根据请求的特定头部或路径，将流量路由到不同的后端 Xray 服务，甚至可以动态修改请求/响应内容以增强混淆。这种可编程性使得 Workers 成为一种强大的工具，但也要求用户具备一定的编程知识。然而，需要强调的是，滥用 Cloudflare 服务（包括 Workers）进行违反其服务条款的活动是被禁止的。</p>\n<h3 id=\"3-7-使用-Cloudflare-Tunnel-Argo-Tunnel-代理-TCP-节点\"><a href=\"#3-7-使用-Cloudflare-Tunnel-Argo-Tunnel-代理-TCP-节点\" class=\"headerlink\" title=\"3.7 使用 Cloudflare Tunnel (Argo Tunnel) 代理 TCP 节点\"></a>3.7 使用 Cloudflare Tunnel (Argo Tunnel) 代理 TCP 节点</h3><p>Cloudflare Tunnel (以前称为 Argo Tunnel) 可以安全地将你的本地服务（包括运行在 VPS 上的 Xray 服务）暴露到互联网，而无需在防火墙上打开入站端口。它通过在你的服务器上运行一个轻量级守护进程 <code>cloudflared</code>，该进程会与 Cloudflare 的边缘网络建立一个持久的、仅出站的加密连接。</p>\n<ol>\n<li><p><strong>基本原理:</strong> <code>cloudflared</code> 守护进程将本地 Xray 服务（如 VLESS+TCP、Trojan+TCP、Shadowsocks+TCP）的流量通过这个安全隧道发送到 Cloudflare 边缘，Cloudflare 再将公网用户的请求通过隧道转发给你的 Xray 服务。</p>\n</li>\n<li><p>安装和配置 <code>cloudflared</code>:</p>\n<ul>\n<li>在你的 VPS 上下载并安装 <code>cloudflared</code> 。</li>\n<li>登录 <code>cloudflared</code>：<code>cloudflared tunnel login</code>，这会在浏览器中打开 Cloudflare 登录页面，授权后 <code>cloudflared</code> 会下载一个证书文件。</li>\n<li>创建隧道：<code>cloudflared tunnel create &lt;your_tunnel_name&gt;</code>。记下返回的隧道 UUID。</li>\n<li>为隧道创建 DNS 记录（指向公共主机名）：<code>cloudflared tunnel route dns &lt;your_tunnel_name_or_UUID&gt; &lt;proxy.yourdomain.com&gt;</code>。</li>\n</ul>\n</li>\n<li><p>配置 <code>cloudflared</code> 以暴露 TCP 服务:</p>\n<ul>\n<li><p>创建一个配置文件（通常是 </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">~/.cloudflared/config.yml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 或在 </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">/etc/cloudflared/<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 目录），内容类似如下 ：</p>\n<pre class=\"line-numbers language-YAML\" data-language=\"YAML\"><code class=\"language-YAML\">tunnel: &lt;your_tunnel_UUID&gt; # 从 'cloudflared tunnel create' 命令获取\ncredentials-file: /root/.cloudflared/&lt;your_tunnel_UUID&gt;.json # 证书文件路径\n\ningress:\n  - hostname: proxy.yourdomain.com # 你希望用户连接的公共域名\n    service: tcp://localhost:&lt;xray_listen_port&gt; # Xray 服务监听的本地地址和端口\n  - service: http_status:404 # 捕获所有其他未匹配的请求<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将 <code>&lt;your_tunnel_UUID&gt;</code>、<code>&lt;proxy.yourdomain.com&gt;</code> 和 <code>&lt;xray_listen_port&gt;</code>替换为实际值。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>运行隧道:</strong> <code>cloudflared tunnel run &lt;your_tunnel_name_or_UUID&gt;</code> 或者，将 <code>cloudflared</code> 安装为系统服务以便开机自启：<code>sudo cloudflared service install</code> (需要先有配置文件)。</p>\n</li>\n<li><p>Xray 入站配置:</p>\n<ul>\n<li>Xray 的 TCP 类型入站（如 VLESS+TCP, Trojan+TCP, Shadowsocks+TCP）应配置为监听 <code>localhost:&lt;xray_listen_port&gt;</code>，与 <code>cloudflared</code> 配置文件中的 <code>service</code> 地址对应。</li>\n<li>由于 TLS 终结发生在 Cloudflare 边缘，Xray 源服务器上的这些 TCP 入站通常不需要再配置 TLS。客户端连接时，地址填写 <code>proxy.yourdomain.com</code>，端口为 Cloudflare 支持的端口（如 443，Cloudflare 会处理 TLS）。</li>\n</ul>\n</li>\n<li><p>优缺点与限制:</p>\n<ul>\n<li><strong>优点:</strong> 无需公网 IP 或开放防火墙端口即可安全暴露服务，IP 地址由 Cloudflare 提供。</li>\n<li>缺点:<ul>\n<li><strong>gRPC 限制:</strong> 通过公共主机名的 Cloudflare Tunnel 目前不支持 gRPC 流量 。gRPC 可以通过隧道的私网路由功能与 WARP 客户端结合使用。</li>\n<li><strong>UDP 限制:</strong> 通过公共主机名代理任意 UDP 流量不是标准功能。UDP 通常需要结合 Cloudflare WARP 客户端和私网路由 。对于 WireGuard (UDP)，直接通过 Tunnel 的公共主机名暴露可能不可行或效果不佳。</li>\n<li><strong>性能:</strong> 相比直接连接或 CDN，Tunnel 增加了一个 <code>cloudflared</code> 进程和到 Cloudflare 边缘的额外网络跃点，可能会引入一些延迟。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>Cloudflare Tunnel 为那些不适合通过 CDN（如原始 TCP 协议）或不希望直接暴露服务器 IP 的场景提供了一个有价值的解决方案。它特别适用于隐藏家庭网络或动态 IP 环境下的服务器。然而，用户必须清楚其对 gRPC 和 UDP 等协议在公共主机名模式下的限制。</p>\n<h3 id=\"3-8-必备表格：Cloudflare-服务用于代理的对比\"><a href=\"#3-8-必备表格：Cloudflare-服务用于代理的对比\" class=\"headerlink\" title=\"3.8 必备表格：Cloudflare 服务用于代理的对比\"></a>3.8 必备表格：Cloudflare 服务用于代理的对比</h3><p>为了帮助用户根据自身需求选择最合适的 Cloudflare 服务来增强其 Xray 节点，下表对 Cloudflare CDN、Workers 和 Tunnel 的关键特性进行了对比：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Cloudflare CDN (Orange Cloud DNS)</strong></th>\n<th><strong>Cloudflare Workers</strong></th>\n<th><strong>Cloudflare Tunnel (Public Hostname)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>主要优势</strong></td>\n<td>隐藏源 IP, DDoS 防护, 静态内容缓存, 广泛的 HTTP(S) 兼容性</td>\n<td>高度灵活, 边缘计算, 可自定义请求/响应逻辑, 动态路由, IP 来自 CF</td>\n<td>无需公网 IP/开放端口, 安全暴露本地服务, IP 来自 CF</td>\n</tr>\n<tr>\n<td><strong>适用协议/传输</strong></td>\n<td>HTTP, HTTPS, WebSocket, gRPC (有限制)</td>\n<td>HTTP, HTTPS, WebSocket (可编程处理)</td>\n<td>TCP, HTTP, HTTPS (gRPC, UDP 在公共主机名模式下受限)</td>\n</tr>\n<tr>\n<td><strong>IP 隐藏</strong></td>\n<td>是 (源服务器 IP)</td>\n<td>是 (源服务器 IP, Worker 本身 IP 是 CF 的)</td>\n<td>是 (源服务器 IP)</td>\n</tr>\n<tr>\n<td><strong>TLS 处理</strong></td>\n<td>浏览器 &lt;-&gt; CF (CF 证书), CF &lt;-&gt; 源服务器 (源服务器证书, 需 Full Strict)</td>\n<td>可自定义 (浏览器 &lt;-&gt; Worker &lt;-&gt; 源)</td>\n<td>浏览器 &lt;-&gt; CF (CF 证书), Tunnel 内部加密, CF &lt;-&gt; 源 (通常无需 TLS)</td>\n</tr>\n<tr>\n<td><strong>性能影响</strong></td>\n<td>取决于地理位置和缓存, 可能增加延迟, Argo 可优化</td>\n<td>Worker 执行有开销, 但边缘执行可减少延迟</td>\n<td>增加 <code>cloudflared</code> 跃点, 可能有额外延迟</td>\n</tr>\n<tr>\n<td><strong>配置复杂度</strong></td>\n<td>较低 (DNS 切换)</td>\n<td>中到高 (需要编写和部署脚本)</td>\n<td>中等 (安装和配置 <code>cloudflared</code>)</td>\n</tr>\n<tr>\n<td><strong>主要限制</strong></td>\n<td>对非 HTTP(S) 协议支持不佳, 可能被 WAF/Bot 管理误判</td>\n<td>执行时间/资源限制, 服务条款约束</td>\n<td>gRPC/UDP 在公共主机名模式下支持不佳</td>\n</tr>\n</tbody></table>\n<p><strong>选择考量:</strong></p>\n<ul>\n<li>如果你的 Xray 节点使用 <strong>WebSocket 或 gRPC</strong> 传输，并且希望利用 CDN 的 IP 隐藏和 DDoS 防护，<strong>Cloudflare CDN</strong> 是首选，配置也最简单。</li>\n<li>如果你需要更高级的流量伪装、自定义路由逻辑，或者希望在边缘处理一些逻辑（例如，根据特定条件选择后端），并且不介意编写代码，<strong>Cloudflare Workers</strong> 提供了极大的灵活性。</li>\n<li>如果你的 Xray 节点使用 <strong>纯 TCP 协议</strong> (如 VLESS/Trojan/SS over TCP)，或者你的服务器没有公网 IP / 不想开放入站端口，<strong>Cloudflare Tunnel</strong> 是一个很好的选择，但要注意其对 gRPC 和 UDP 的限制。</li>\n</ul>\n<h2 id=\"第四部分：安全与优化\"><a href=\"#第四部分：安全与优化\" class=\"headerlink\" title=\"第四部分：安全与优化\"></a>第四部分：安全与优化</h2><p>搭建和使用科学上网节点时，安全性和性能优化是不可忽视的重要环节。</p>\n<h3 id=\"4-1-VPS-服务器安全基础\"><a href=\"#4-1-VPS-服务器安全基础\" class=\"headerlink\" title=\"4.1 VPS 服务器安全基础\"></a>4.1 VPS 服务器安全基础</h3><p>保护承载 Xray 服务的 VPS 是首要任务。</p>\n<ul>\n<li>防火墙配置 (UFW/iptables):<ul>\n<li>UFW (Uncomplicated Firewall) 是一个用户友好的 iptables 前端。启用 UFW 并配置规则可以有效控制服务器的网络访问 。</li>\n<li>基本操作:<ul>\n<li>启用 UFW: <code>sudo ufw enable</code></li>\n<li>查看状态: <code>sudo ufw status verbose</code></li>\n<li>允许特定端口: <code>sudo ufw allow &lt;port&gt;/&lt;protocol&gt;</code></li>\n<li>拒绝特定端口: <code>sudo ufw deny &lt;port&gt;/&lt;protocol&gt;</code></li>\n</ul>\n</li>\n<li>推荐规则 (详见文末表格):<ul>\n<li>默认拒绝所有入站连接: <code>sudo ufw default deny incoming</code></li>\n<li>默认允许所有出站连接: <code>sudo ufw default allow outgoing</code></li>\n<li>允许 SSH 连接（建议使用非标准端口，并限制来源 IP）: <code>sudo ufw allow from &lt;your_trusted_IP&gt; to any port &lt;ssh_port&gt; proto tcp</code> 。</li>\n<li>允许 x-ui 面板访问端口（强烈建议限制来源 IP）: <code>sudo ufw allow from &lt;your_trusted_IP&gt; to any port &lt;xui_panel_port&gt; proto tcp</code>。</li>\n<li>允许代理服务端口（通常是 443/TCP 用于 TLS 节点，以及 WireGuard 的 UDP 端口）: <code>sudo ufw allow 443/tcp</code>, <code>sudo ufw allow &lt;wireguard_udp_port&gt;/udp</code> 。</li>\n<li>如果使用 Certbot 的 HTTP-01 验证，需要临时允许 80/TCP: <code>sudo ufw allow 80/tcp</code> (验证后可考虑移除或限制)。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>SSH 加固:<ul>\n<li><strong>禁用 root 用户密码登录:</strong> 编辑 <code>/etc/ssh/sshd_config</code>，设置 <code>PermitRootLogin prohibit-password</code> (或 <code>no</code>)。</li>\n<li><strong>使用密钥对认证:</strong> 推荐禁用密码认证 (<code>PasswordAuthentication no</code>)，仅使用 SSH 密钥对登录 。</li>\n<li><strong>更改默认 SSH 端口:</strong> 将默认的 22 端口更改为一个不常用的高位端口，以减少自动扫描攻击 。</li>\n</ul>\n</li>\n<li>定期更新:<ul>\n<li>保持操作系统和所有已安装软件包的最新状态，以修复已知的安全漏洞：<code>sudo apt update &amp;&amp; sudo apt upgrade -y</code> 。</li>\n</ul>\n</li>\n<li>其他安全措施:<ul>\n<li><strong>Fail2ban:</strong> 安装并配置 Fail2ban 可以监控日志文件（如 SSH 登录失败、x-ui 面板登录尝试），并在检测到恶意行为（如暴力破解）时自动封禁来源 IP 。3x-ui 面板本身也集成了 IP 限制功能，需要安装 Fail2ban 配合使用 。</li>\n<li><strong>禁用不必要的服务:</strong> 关闭服务器上所有不需要运行的网络服务，以减少攻击面。</li>\n</ul>\n</li>\n</ul>\n<p>采取多层次的安全措施至关重要。仅仅依赖 Cloudflare 的保护或一个强密码是不够的。VPS 自身的安全（防火墙、SSH加固、及时更新）、x-ui 面板的安全（强密码、HTTPS访问、访问IP限制）以及代理协议自身的安全性（如TLS、REALITY）共同构成了一个纵深防御体系。每一层都针对不同类型的威胁提供防护，从而整体上提升节点的安全性。</p>\n<h3 id=\"4-2-Cloudflare-安全设置\"><a href=\"#4-2-Cloudflare-安全设置\" class=\"headerlink\" title=\"4.2 Cloudflare 安全设置\"></a>4.2 Cloudflare 安全设置</h3><p>Cloudflare 提供了多种安全功能，但在用于代理节点时，某些设置可能需要调整以避免对代理流量的干扰。</p>\n<ul>\n<li>WAF 自定义规则 (Web Application Firewall):<ul>\n<li>Cloudflare WAF 可能会将某些代理流量模式识别为可疑并进行拦截。如果遇到这种情况，可以尝试在 Cloudflare WAF 设置中创建自定义规则，针对代理节点的特定路径（如 WebSocket 路径）或来源（如果固定）选择“跳过”(Skip) WAF 的部分或全部分析模块 。</li>\n<li>例如，如果 WebSocket 路径是 <code>/secretpath</code>，可以创建规则：<code>If URI Path equals /secretpath Then Skip (All WAF managed rules, Cloudflare OWASP Core Ruleset)</code>。</li>\n<li><strong>重要警示:</strong> Cloudflare 的服务条款明确禁止未经授权使用其网络提供代理或 VPN 服务 68。虽然技术上可以通过 WAF 规则绕过检查，但这并不意味着这种用法符合服务条款。用户应自行承担相关风险。</li>\n</ul>\n</li>\n<li>页面规则 (Page Rules) (主要用于 WebSocket 优化/绕过):<ul>\n<li>对于 WebSocket 连接使用的特定路径，可以考虑设置页面规则 ：<ul>\n<li>将“缓存级别”(Cache Level) 设置为“绕过”(Bypass)，因为代理流量通常是动态的，不应被缓存。</li>\n<li>在极端情况下，如果 Cloudflare 的安全级别过高导致连接问题，可以考虑将该路径的“安全级别”(Security Level) 设置为“基本关闭”(Essentially Off) 或“禁用安全性”(Disable Security)。但这样做会降低该路径的安全防护，务必谨慎使用，并尽可能缩小规则匹配范围。</li>\n</ul>\n</li>\n<li>确保 Cloudflare “网络” (Network) 设置中的 “WebSockets” 功能已开启（通常默认开启）。</li>\n</ul>\n</li>\n<li>机器人管理 (Bot Management) 注意事项:<ul>\n<li>Cloudflare 的“机器人战斗模式”(Bot Fight Mode) 或“超级机器人战斗模式”(Super Bot Fight Mode) 可能会将代理客户端的连接行为归类为“可能是自动程序”并进行质询或阻止 。</li>\n<li>如果代理连接因此受阻，可能需要禁用机器人战斗模式，或者（如果可能且符合服务条款）创建 WAF 规则来跳过对特定代理主机名或路径的机器人检测。</li>\n</ul>\n</li>\n<li>SSL/TLS 优化器 (SSL/TLS Recommender) 与自动 HTTPS 重写:<ul>\n<li>这些功能通常是有益的，但务必确保最终的 SSL/TLS 加密模式保持在 “Full (Strict)” 。</li>\n</ul>\n</li>\n<li>HTTP/2 到源站 与 HTTP/3:<ul>\n<li>在 Cloudflare “网络” 设置中启用 “HTTP/2 到源站” 通常是推荐的，特别是当源服务器（Xray）也支持 HTTP/2 时（例如使用 gRPC 传输）。HTTP/3 (QUIC) 也可以考虑启用，但要确保 Xray 和客户端都支持。</li>\n</ul>\n</li>\n</ul>\n<p>Cloudflare 的安全功能是一把双刃剑。它们在保护网站免受恶意攻击方面非常有效 7，但其某些启发式检测机制也可能将正常的代理流量误判为可疑活动，从而导致连接问题。因此，用户需要理解这些设置如何工作，并学会在 Cloudflare 仪表盘中进行细致调整，以便在获得 Cloudflare 保护的同时，确保代理服务的顺畅运行。这通常需要在安全性和可用性之间找到一个平衡点。</p>\n<h3 id=\"4-3-进阶抗封锁技巧\"><a href=\"#4-3-进阶抗封锁技巧\" class=\"headerlink\" title=\"4.3 进阶抗封锁技巧\"></a>4.3 进阶抗封锁技巧</h3><p>随着审查技术的不断发展，单一的代理协议和配置可能不足以保证长期稳定。以下是一些进阶的抗封锁思路和技术：</p>\n<ul>\n<li><strong>域名伪装 (Domain Fronting - 概念性):</strong> 传统意义上的域名伪装（通过在 TLS ClientHello 中使用一个 SNI，而在 HTTP Host 头中使用另一个域名，并依赖 CDN 的路由行为）在很大程度上已被主流 CDN 提供商（包括 Cloudflare）限制。然而，Cloudflare Workers 可以在一定程度上实现类似效果：Worker 脚本可以接收来自一个“干净”域名的请求，然后根据内部逻辑（如特定路径或头部）将请求转发到实际的、可能被审查的后端代理服务器。这需要精心设计的 Worker 脚本和 Xray 配置。</li>\n<li><strong>使用“干净”的 IP 地址和信誉良好的 VPS 提供商:</strong> 某些 IP 地址段（例如来自大型、知名云服务商的 IP）可能受到更严格的审查或更容易被列入黑名单。选择一些较小众、信誉良好或专门针对此类应用的 VPS 提供商，并获取相对“干净”的 IP 地址，可能有助于提高节点的存活率 。</li>\n<li><strong>IP 地址轮换 (高级):</strong> 这是一项更复杂的技术，通常涉及拥有多个 VPS 或使用支持 IP 轮换的服务。通过定期更换代理服务器的出口 IP 地址，可以降低单个 IP 因长时间暴露而被封锁的风险。</li>\n<li>模仿真实网站流量:<ul>\n<li><strong>真实的回落网站:</strong> 对于 Trojan 或其他配置了回落 (Fallback) 功能的协议，确保回落指向一个真实、内容丰富且在目标审查区域内访问正常的网站。这个网站应该有合法的 TLS 证书。</li>\n<li><strong>WebSocket 路径与 Host:</strong> 对于 WebSocket 类型的节点，其连接路径 (Path) 和 Host 头部应尽量模仿正常 Web 应用的 API 请求。避免使用过于简单或可识别的路径。</li>\n</ul>\n</li>\n<li><strong>TLS 指纹伪装 (uTLS):</strong> 许多审查系统会分析 TLS 握手过程中的客户端指纹（Client Hello），以识别可疑的非浏览器流量。Xray 核心及其客户端（如 Nekoray, V2RayNG, ShadowRocket 等）通常支持 uTLS 功能，允许客户端在发起 TLS 连接时模仿特定浏览器（如 Chrome, Firefox）或操作系统的 TLS 指纹 。在客户端配置中启用并选择合适的 uTLS 指纹，是增强伪装性的重要手段。对于 REALITY 协议，服务器端也会参与指纹的伪装。</li>\n<li><strong>避免使用常见代理端口 (有限效果):</strong> 虽然将代理服务运行在非标准端口（而不是常见的 80, 443, 1080 等）可能避开一些非常初级的端口扫描，但这对于能够进行深度包检测的审查系统来说几乎没有作用。对于基于 TLS 的代理协议（如 VLESS/VMess/Trojan + TLS/WS/gRPC/REALITY），使用标准的 HTTPS 端口 <code>443</code> 通常是最佳选择，因为它最符合伪装成正常 HTTPS 流量的目的。</li>\n<li><strong>流量分割与分流:</strong> 不在所有流量上都使用代理。例如，可以使用 PAC 文件、浏览器扩展或客户端的路由规则，仅对需要访问受限资源的域名或 IP 地址启用代理，而国内或其他可直连的流量则直接访问。这不仅可以节省代理服务器的带宽，减少不必要的性能开销，还能降低代理服务器因大量非敏感流量通过而被注意到的风险。</li>\n</ul>\n<p>网络审查与反审查技术始终处于动态的“军备竞赛”之中。没有任何一种技术或配置可以保证永久有效。审查方会不断分析和封锁已知的协议特征和服务器 IP，而开发者和用户则会不断寻找新的协议、传输方式和伪装技巧来应对。因此，保持对新技术和封锁动态的关注，并准备好根据需要调整和更新自己的节点配置，是维持科学上网连接稳定的关键。</p>\n<h3 id=\"4-4-性能优化与资源消耗考量\"><a href=\"#4-4-性能优化与资源消耗考量\" class=\"headerlink\" title=\"4.4 性能优化与资源消耗考量\"></a>4.4 性能优化与资源消耗考量</h3><p>节点的性能直接影响用户体验，而资源消耗则关系到 VPS 的成本和承载能力。</p>\n<ul>\n<li>协议选择对性能的影响:<ul>\n<li><strong>VLESS vs VMess:</strong> VLESS 由于其无内置加密和更简洁的头部设计，通常比 VMess 具有更低的延迟和更高的吞吐量，资源消耗也更少 。</li>\n<li><strong>WireGuard:</strong> 以其极高的速度和低资源占用著称，是性能优先场景下的优秀选择，但其基于 UDP，可能受网络环境影响 。</li>\n<li><strong>Shadowsocks:</strong> 作为一种轻量级协议，性能表现良好，资源占用低 。</li>\n<li><strong>Trojan:</strong> 性能接近原生 HTTPS，通常表现不错 。</li>\n</ul>\n</li>\n<li>传输方式对性能的影响:<ul>\n<li><strong>TCP:</strong> 作为基础传输协议，稳定可靠，但纯 TCP 传输（即使套了 TLS）的特征相对容易被识别。</li>\n<li><strong>WebSocket (WS):</strong> 为代理流量增加了额外的 HTTP 头部和 WebSocket 帧封装，会带来一定的性能开销。然而，它是通过 CDN 转发流量的常用方式。Xray 的一些配置（如 VLESS 的回落分流到 WS）据称性能优于传统的 Nginx 反代 WS 。</li>\n<li><strong>gRPC:</strong> 基于 HTTP/2，支持多路复用，可以减少连接建立的开销，对移动端和需要频繁短连接的场景友好，性能通常优于 WebSocket。</li>\n<li><strong>XTLS:</strong> 专门为 VLESS 和 Trojan 设计，通过减少 TLS 加密层级来优化性能，理论上可以达到接近或优于裸 TCP+TLS 的性能 。</li>\n</ul>\n</li>\n<li><strong>服务器硬件配置:</strong> CPU 的核心数和主频、内存大小以及网络带宽都会直接影响 Xray 服务器能处理的并发连接数和总吞吐量。高负载情况下，性能瓶颈可能出现在 CPU（加解密和协议处理）或网络I/O上 47。虽然难以给出精确的 Xray 资源消耗数据，但可以参考类似代理软件（如 Envoy）的指标：每秒处理 1000 个请求（1KB负载）大约需要 0.2-0.5 vCPU 和 40-60MB 内存 。</li>\n<li><strong>Cloudflare 引入的延迟:</strong> 使用 Cloudflare CDN、Workers 或 Tunnel 会在客户端和源服务器之间增加额外的网络跃点，这不可避免地会引入一定的延迟。Cloudflare 的 Argo Smart Routing (付费功能) 声称可以优化路由，减少延迟。对于 WebSocket 流量，Cloudflare 本身对连接的处理也可能影响性能。</li>\n<li><strong>Keepalives (连接保持):</strong> 对于长时间活动的连接，特别是 WebSocket，配置适当的 Keepalive 机制非常重要，可以防止连接因网络中间设备（如 NAT、防火墙）的超时而意外断开 。Xray 和客户端通常都有相关配置。</li>\n<li><strong>启用 BBR 拥塞控制算法:</strong> 在 VPS 服务器上启用 TCP BBR 拥塞控制算法，通常可以显著改善高延迟、有一定丢包率网络环境下的 TCP 连接吞吐量。</li>\n<li><strong>内核参数优化:</strong> 调整 Linux 内核参数，如最大文件描述符数 (<code>ulimit -n</code>)、TCP 连接队列大小 (<code>net.core.somaxconn</code>, <code>net.ipv4.tcp_max_syn_backlog</code>) 等，在高并发场景下可能有助于提升性能。</li>\n</ul>\n<p>性能并非单一因素决定的，而是协议、传输方式、加密强度、服务器负载、网络路径（包括 Cloudflare 的参与）、客户端与服务器硬件，乃至操作系统内核调优等多种因素综合作用的结果。例如，VLESS+XTLS+REALITY 在直连情况下可能速度最快，但对于与服务器地理位置遥远的用户，VLESS+WS+TLS+CDN 由于 CDN 的边缘节点效应，尽管 WebSocket 自身有开销，却可能带来更好的实际访问体验。因此，优化是一个需要综合考虑并根据具体场景进行调整的过程。</p>\n<h3 id=\"必备表格：推荐的-UFW-防火墙规则\"><a href=\"#必备表格：推荐的-UFW-防火墙规则\" class=\"headerlink\" title=\"必备表格：推荐的 UFW 防火墙规则\"></a>必备表格：推荐的 UFW 防火墙规则</h3><p>以下表格提供了一组针对运行 x-ui 和 Xray 代理服务的 VPS 的推荐 UFW 防火墙规则。请根据你的实际端口配置进行调整。</p>\n<table>\n<thead>\n<tr>\n<th><strong>规则描述</strong></th>\n<th><strong>UFW 命令 (示例)</strong></th>\n<th><strong>端口 (示例)</strong></th>\n<th><strong>协议</strong></th>\n<th><strong>注意事项</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>允许来自特定 IP 的 SSH 访问</td>\n<td><code>sudo ufw allow from 1.2.3.4 to any port 2222 proto tcp</code></td>\n<td>2222</td>\n<td>TCP</td>\n<td>将 <code>1.2.3.4</code> 替换为你的可信管理 IP，<code>2222</code> 替换为你的 SSH 端口。</td>\n</tr>\n<tr>\n<td>允许来自特定 IP 的 x-ui 面板访问</td>\n<td><code>sudo ufw allow from 1.2.3.4 to any port 54321 proto tcp</code></td>\n<td>54321</td>\n<td>TCP</td>\n<td>将 <code>1.2.3.4</code> 替换为你的可信管理 IP，<code>54321</code> 替换为你的 x-ui 面板端口。</td>\n</tr>\n<tr>\n<td>允许 HTTPS/TLS 代理流量 (通用)</td>\n<td><code>sudo ufw allow 443/tcp</code></td>\n<td>443</td>\n<td>TCP</td>\n<td>用于 VLESS/VMess/Trojan 等协议的 TLS, WS+TLS, gRPC+TLS, REALITY。</td>\n</tr>\n<tr>\n<td>允许 HTTP 流量 (SSL 证书验证)</td>\n<td><code>sudo ufw allow 80/tcp</code></td>\n<td>80</td>\n<td>TCP</td>\n<td>主要用于 Let’s Encrypt HTTP-01 验证。验证完成后可考虑限制或移除此规则。</td>\n</tr>\n<tr>\n<td>允许 WireGuard 流量</td>\n<td><code>sudo ufw allow 51820/udp</code></td>\n<td>51820</td>\n<td>UDP</td>\n<td>将 <code>51820</code> 替换为你的 WireGuard 监听端口。</td>\n</tr>\n<tr>\n<td>允许 Xray 源服务器监听端口 (如果使用 CDN/Tunnel)</td>\n<td><code>sudo ufw allow 8443/tcp</code></td>\n<td>8443</td>\n<td>TCP</td>\n<td>示例端口，用于 CDN/Tunnel 回源。应仅允许来自 Cloudflare IP 段的访问。</td>\n</tr>\n<tr>\n<td>默认拒绝所有其他入站连接</td>\n<td><code>sudo ufw default deny incoming</code></td>\n<td>N/A</td>\n<td>N/A</td>\n<td>重要的安全基线。</td>\n</tr>\n<tr>\n<td>默认允许所有出站连接</td>\n<td><code>sudo ufw default allow outgoing</code></td>\n<td>N/A</td>\n<td>N/A</td>\n<td>允许服务器主动向外发起连接。</td>\n</tr>\n<tr>\n<td>启用 UFW</td>\n<td><code>sudo ufw enable</code></td>\n<td>N/A</td>\n<td>N/A</td>\n<td>在所有规则配置完成后执行。</td>\n</tr>\n</tbody></table>\n<p><strong>注意:</strong></p>\n<ul>\n<li>在执行 <code>sudo ufw enable</code> 之前，务必确保已添加允许 SSH 访问的规则，否则可能导致无法远程连接服务器。</li>\n<li>对于通过 CDN 或 Tunnel 回源的端口（如上例中的 8443/TCP），更安全的做法是仅允许来自 Cloudflare IP 地址段的流量访问这些端口。Cloudflare 公布了其 IP 范围列表，可以用于配置更精细的防火墙规则。</li>\n<li>定期审查和更新防火墙规则，确保其符合当前的安全需求。</li>\n</ul>\n<p>防火墙是服务器安全的第一道防线，正确配置 UFW 对于保护你的 Xray 节点免受未经授权的访问和潜在攻击至关重要 54。上述规则提供了一个基础模板，用户应根据自己的具体服务端口和安全策略进行调整。</p>\n<h2 id=\"第五部分：客户端配置与使用\"><a href=\"#第五部分：客户端配置与使用\" class=\"headerlink\" title=\"第五部分：客户端配置与使用\"></a>第五部分：客户端配置与使用</h2><p>成功搭建节点后，需要在客户端设备上进行相应配置才能连接和使用。</p>\n<h3 id=\"5-1-主流客户端介绍\"><a href=\"#5-1-主流客户端介绍\" class=\"headerlink\" title=\"5.1 主流客户端介绍\"></a>5.1 主流客户端介绍</h3><p>市面上有众多支持 Xray 核心及其协议的客户端软件，覆盖各类操作系统平台。</p>\n<ul>\n<li>跨平台:<ul>\n<li><strong>Nekoray / Nekobox:</strong> 支持 Windows, Linux, Android，并有非官方 macOS 版本。功能强大，支持 Shadowsocks (包括 SS-2022), VLESS, VMess, Trojan, XTLS-Reality 等多种协议和特性 。</li>\n</ul>\n</li>\n<li>Android:<ul>\n<li><strong>V2RayNG:</strong> 基于 Xray 核心，支持 Xray 的所有协议和功能，界面简洁，广受欢迎 。</li>\n<li><strong>Hiddify (FoXray Hiddify):</strong> 提及与 3X-UI VLESS REALITY 配合使用，可能基于 FoXray 或类似核心 。</li>\n<li><strong>SagerNet / Matsuri:</strong> 同样是功能丰富的 Android 客户端。</li>\n</ul>\n</li>\n<li>iOS:<ul>\n<li><strong>FoXray:</strong> 基于 Xray 核心，支持 Shadowsocks, VLESS, Socks, VMess, XTLS, REALITY, Trojan 以及 TCP, HTTP/2, WebSocket, mKCP, gRPC, QUIC 等多种传输方式 。</li>\n<li><strong>ShadowRocket (小火箭):</strong> 付费应用，功能强大，支持 Shadowsocks (包括 SS-2022), VMess, VLESS, Trojan, TUIC, Hysteria, WireGuard, XTLS-Vision, uTLS 等多种协议和特性 。</li>\n<li><strong>V2BOX:</strong> 支持 Xray 核心的免费 iOS 客户端 。</li>\n<li><strong>Streisand:</strong> 提及与 3x-ui VLESS 配合使用 。</li>\n<li><strong>Quantumult X / Loon / Surge:</strong> 均为功能强大的付费网络工具，支持多种代理协议。</li>\n</ul>\n</li>\n<li>Windows:<ul>\n<li><strong>V2RayN:</strong> 流行的 Windows 客户端，支持 Xray/V2Ray 核心，界面直观 。</li>\n<li><strong>Nekoray / Nekobox:</strong> 如上所述，也支持 Windows。</li>\n<li><strong>Qv2ray:</strong> (项目已停止维护，但仍有用户使用) 跨平台客户端，基于 Qt。</li>\n</ul>\n</li>\n<li>macOS:<ul>\n<li><strong>V2RayX:</strong> (项目可能更新较慢) 针对 macOS 的 V2Ray 客户端。</li>\n<li><strong>Nekoray / Nekobox (非官方):</strong> 如上所述。</li>\n<li><strong>V2BOX:</strong> 如上所述，也支持 macOS 。</li>\n<li><strong>ClashX / Clash for Windows (CFW) (macOS 版本):</strong> 基于 Clash 核心的客户端，支持多种协议，通过配置文件进行管理。</li>\n</ul>\n</li>\n<li>Linux:<ul>\n<li><strong>Nekoray / Nekobox:</strong> 如上所述。</li>\n<li><strong>Qv2ray:</strong> (项目已停止维护)。</li>\n<li><strong>Clash (命令行) / Clash Verge (图形界面):</strong> 基于 Clash 核心。</li>\n</ul>\n</li>\n<li>WireGuard 客户端:<ul>\n<li>WireGuard 官方为各主流平台（Windows, macOS, Linux, Android, iOS）均提供了客户端软件 。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-各协议客户端配置示例\"><a href=\"#5-2-各协议客户端配置示例\" class=\"headerlink\" title=\"5.2 各协议客户端配置示例\"></a>5.2 各协议客户端配置示例</h3><p>从 x-ui 面板导出配置通常是最便捷的方式，支持通过分享链接、二维码或复制配置信息。如果需要手动配置，以下是一些关键参数说明：</p>\n<ul>\n<li>通用参数:<ul>\n<li><strong>地址 (Address/Server):</strong> 填写你的服务器域名（如 <code>proxy.yourdomain.com</code>，如果使用 CDN 或 Worker 域名）或服务器 IP 地址（如果直连）。</li>\n<li><strong>端口 (Port):</strong> 填写服务器监听的端口。对于 CDN/Worker 后的 TLS 节点，通常是 <code>443</code>。对于直连节点，填写 x-ui 中设置的监听端口。</li>\n<li><strong>用户ID (ID/UUID):</strong> 对应 VLESS/VMess 协议中 x-ui 生成的 UUID。</li>\n<li><strong>密码 (Password):</strong> 对应 Trojan 或 Shadowsocks 协议中设置的密码。</li>\n</ul>\n</li>\n<li>VMess 特定参数:<ul>\n<li><strong>额外ID (AlterID):</strong> 对应 x-ui 中设置的 AlterID。</li>\n<li><strong>加密方式 (Security/Cipher):</strong> 客户端选择的加密方式需与服务器端兼容，通常选 <code>auto</code> 或服务器指定的。</li>\n</ul>\n</li>\n<li>VLESS 特定参数:<ul>\n<li><strong>流控 (Flow):</strong> 如果服务器端 VLESS 配置了 <code>flow</code> (如 <code>xtls-rprx-vision</code>)，客户端需要相应配置。对于 REALITY，此项通常不直接配置，而是通过 REALITY 的特定参数。</li>\n</ul>\n</li>\n<li>TLS 相关参数 (适用于 VLESS/VMess/Trojan + TLS/XTLS/REALITY):<ul>\n<li><strong>传输层安全 (TLS/Security):</strong> 选择 <code>tls</code> 或 <code>xtls</code> 或 <code>reality</code>。</li>\n<li><strong>SNI (Server Name Indication) / Peer / Host:</strong> 填写用于 TLS 握手的域名，通常是你的服务器域名或 CDN/Worker 域名。对于 REALITY，这里填写的是你伪装的目标网站域名 。</li>\n<li><strong>允许不安全连接 (Allow Insecure):</strong> 通常应设为 <code>false</code> (不勾选)，除非特殊调试目的且了解风险。</li>\n<li><strong>ALPN (Application-Layer Protocol Negotiation):</strong> 客户端可以指定 ALPN，如 <code>h2,http/1.1</code>，以更好地模拟浏览器行为。</li>\n<li><strong>证书验证 (Skip Cert Verify):</strong> 通常不应跳过证书验证。</li>\n</ul>\n</li>\n<li>WebSocket (WS) 特定参数 (适用于 VLESS/VMess/Trojan + WS):<ul>\n<li><strong>传输协议 (Network/Transport):</strong> 选择 <code>ws</code>。</li>\n<li><strong>路径 (Path):</strong> 填写与 x-ui 中 WebSocket 配置一致的路径 (如 <code>/myvlessws</code>)。</li>\n<li><strong>Host (请求头):</strong> 填写你的服务器域名或 CDN/Worker 域名。</li>\n</ul>\n</li>\n<li>gRPC 特定参数 (适用于 VLESS/VMess/Trojan + gRPC):<ul>\n<li><strong>传输协议 (Network/Transport):</strong> 选择 <code>grpc</code>。</li>\n<li><strong>gRPC 服务名称 (serviceName):</strong> 填写与 x-ui 中 gRPC 配置一致的服务名称 (如 <code>mytrojangrpc</code>)。</li>\n<li><strong>模式 (Mode):</strong> <code>multi</code> (多路复用) 模式通常性能更好。</li>\n</ul>\n</li>\n<li>REALITY 特定参数 (VLESS + REALITY):<ul>\n<li><strong>公钥 (PublicKey):</strong> 填写服务器端 x-ui 生成的 X25519 公钥 。</li>\n<li><strong>ShortID:</strong> 填写服务器端配置的 ShortID (可以为空，如果服务器允许) 。</li>\n<li><strong>SpiderX / Fingerprint:</strong> 客户端通常会自动选择或允许用户选择一个 TLS 指纹 (uTLS) 来模仿，如 <code>chrome</code> 或 <code>firefox</code> 。</li>\n</ul>\n</li>\n<li>Shadowsocks 特定参数:<ul>\n<li><strong>加密方法 (Cipher/Method):</strong> 选择与服务器端一致的 AEAD 加密方法。</li>\n</ul>\n</li>\n<li>WireGuard 特定参数:<ul>\n<li><strong>私钥 (PrivateKey):</strong> 客户端的私钥。</li>\n<li><strong>地址 (Address):</strong> 分配给客户端的隧道内 IP 地址 (如 <code>10.0.8.2/32</code>)。</li>\n<li><strong>DNS:</strong> 可选，指定通过 VPN 使用的 DNS 服务器。</li>\n<li>[Peer] 部分:<ul>\n<li><strong>公钥 (PublicKey):</strong> 服务器的 WireGuard 公钥。</li>\n<li><strong>预共享密钥 (PresharedKey):</strong> 可选，用于增强安全性。</li>\n<li><strong>端点 (Endpoint):</strong> 服务器的公网 IP 地址和 WireGuard 监听端口 (如 <code>your_vps_ip:51820</code>)。</li>\n<li><strong>允许的 IP (AllowedIPs):</strong> 通常设为 <code>0.0.0.0/0, ::/0</code>，表示所有流量都通过 VPN。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>许多现代客户端，特别是那些支持 Xray 核心的，都允许用户精细调整 TLS 握手行为，例如通过 uTLS 设置来模仿特定浏览器的 TLS 指纹 。这对于增强连接的隐蔽性，特别是在连接到使用 REALITY 或其他高级伪装技术的服务器时，非常重要。用户应在客户端设置中寻找类似“TLS 指纹”、“uTLS”、“Fingerprint”或“SpiderX”的选项，并选择一个常见浏览器的指纹（如 Chrome 或 Firefox），以使代理流量更难与普通网页浏览流量区分开来。</p>\n<h2 id=\"结论与展望\"><a href=\"#结论与展望\" class=\"headerlink\" title=\"结论与展望\"></a>结论与展望</h2><p>本教程详细介绍了多种主流科学上网代理协议的原理、特性，并逐步指导了如何使用 x-ui (MHSanaei 3x-ui) 面板在 VPS 上搭建这些节点，以及如何结合 Cloudflare CDN、Workers 和 Tunnel 服务来增强节点的隐蔽性和可用性。同时，也涵盖了服务器安全、Cloudflare 安全配置、进阶抗封锁技巧、性能优化和客户端配置等关键方面。</p>\n<p><strong>核心结论包括：</strong></p>\n<ol>\n<li><strong>协议多样性与演进:</strong> 从 Shadowsocks 的简洁高效，到 VMess 的安全灵活，再到 VLESS 的极致性能与 REALITY 的卓越伪装，以及 Trojan 的 HTTPS 模拟和 WireGuard 的现代高速，用户可以根据自身对安全性、性能、抗检测能力和配置复杂度的不同需求选择合适的协议。协议的演进体现了与审查技术持续对抗的趋势。</li>\n<li><strong>x-ui 的便捷性:</strong> x-ui 面板极大地简化了 Xray 节点的部署和管理，使得即便是初学者也能相对容易地配置和维护多种复杂的代理协议。</li>\n<li><strong>Cloudflare 的双重角色:</strong> Cloudflare 的 CDN、Workers 和 Tunnel 服务为代理节点提供了强大的 IP 隐藏、DDoS 防护和流量中转能力。然而，其安全机制也可能对代理流量造成干扰，需要用户仔细配置 WAF、页面规则和机器人管理等设置。同时，用户需注意 Cloudflare 的服务条款。</li>\n<li><strong>安全是基础:</strong> 无论是 VPS 服务器自身的安全加固（防火墙、SSH 安全、系统更新、Fail2ban），还是 x-ui 面板和代理协议的安全配置（强密码、TLS 加密、uTLS 指纹），都是确保节点稳定和用户数据安全不可或缺的环节。分层安全策略是抵御潜在风险的关键。</li>\n<li><strong>性能与伪装的权衡:</strong> 极致的性能（如 VLESS+XTLS）和极致的伪装（如 VLESS+REALITY 或 Trojan）往往需要更精细的配置。通过 CDN 或 Tunnel 虽然能隐藏 IP，但也可能引入额外延迟。用户需要在这些因素之间做出权衡。</li>\n<li><strong>客户端的重要性:</strong> 选择功能全面、支持最新协议特性（如 uTLS）的客户端，并正确配置，对于发挥节点的全部潜力至关重要。</li>\n</ol>\n<p><strong>未来展望：</strong></p>\n<p>网络审查技术和科学上网技术之间的博弈仍将持续。未来可能会出现更智能、更难被检测的审查手段，同时也会催生出更先进、更具适应性的代理协议和混淆技术。对于用户而言，持续学习、关注技术动态、灵活调整配置策略，将是长期维持稳定、安全科学上网能力的关键。</p>\n<p>希望本教程能为读者在理解和实践科学上网技术方面提供有价值的参考。请务必在遵守当地法律法规的前提下使用相关技术。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"常见问题解答-FAQ\"><a href=\"#常见问题解答-FAQ\" class=\"headerlink\" title=\"常见问题解答 (FAQ)\"></a>常见问题解答 (FAQ)</h3><ul>\n<li><p><strong>问：连接节点时遇到问题（如超时、无法连接）怎么办？</strong></p>\n<ul>\n<li><p>答：</p>\n<p> 首先检查：</p>\n<ul>\n<li>VPS 服务器是否在线，x-ui 和 Xray 服务是否正常运行 (<code>systemctl status x-ui</code>, <code>systemctl status xray</code>)。</li>\n<li>VPS 防火墙 (UFW) 是否允许了相应的代理端口和 x-ui 面板端口的入站连接。</li>\n<li>x-ui 面板中的入站配置是否正确（协议、端口、ID/密码、域名、证书路径、传输设置等）。</li>\n<li>客户端配置是否与服务器端完全一致。</li>\n<li>域名是否正确解析到 VPS IP（如果直连）或 Cloudflare IP（如果使用 CDN）。</li>\n<li>Cloudflare 相关设置：DNS 代理状态（橙色云朵）、SSL/TLS 模式（应为 Full Strict）、WAF 或机器人管理是否拦截了流量（查看 Cloudflare 事件日志）。</li>\n<li>服务器和客户端的时间是否同步。</li>\n<li>尝试更换客户端或网络环境测试。</li>\n<li>查看 x-ui 和 Xray 的日志（通过 x-ui 面板或服务器命令 <code>journalctl -u xray -f</code>）获取错误信息。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>问：如何更新 x-ui 面板和 Xray 核心？</strong></p>\n<ul>\n<li>答：<ul>\n<li><strong>更新 x-ui 面板 (MHSanaei/3x-ui):</strong> 通常可以再次运行官方安装脚本 <code>bash &lt;(curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh)</code>，脚本会自动检测已安装版本并进行升级 。也可以在 x-ui 命令行菜单中选择更新选项。</li>\n<li><strong>更新 Xray 核心:</strong> 3x-ui 面板通常会捆绑特定版本的 Xray 核心。一些 x-ui 分支可能在面板内提供一键更新 Xray 核心的功能。或者，可以从 Xray-core 的 GitHub Releases 页面下载最新的二进制文件，手动替换 VPS 上 x-ui 使用的 Xray 执行文件（通常位于 <code>/usr/local/x-ui/bin/xray-core</code> 或类似路径，请先备份旧版）。替换后需要重启 Xray 服务。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>问：我的 VPS IP 地址被封锁了怎么办？</strong></p>\n<ul>\n<li>答：<ul>\n<li><strong>更换 IP:</strong> 联系 VPS 提供商更换 IP 地址（可能需要额外费用）。</li>\n<li><strong>使用 Cloudflare 隐藏 IP:</strong> 如果之前是直连，可以尝试将节点配置为通过 Cloudflare CDN、Workers 或 Tunnel 接入，这样暴露给外界的是 Cloudflare 的 IP。</li>\n<li><strong>迁移服务器:</strong> 将 x-ui 数据备份后，在新的 VPS 上重新部署。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>问：Cloudflare 是否允许使用其网络进行代理？</strong></p>\n<ul>\n<li><strong>答：</strong> Cloudflare 的服务条款（ToS Section 2.8）通常禁止使用其网络（特别是免费计划）作为大规模、未经授权的代理或 VPN 服务出口 68。虽然技术上可以通过 CDN、Workers 或 Tunnel 搭建代理，但如果流量模式被 Cloudflare 识别为滥用，账户或相关域名可能会受到限制。用户应了解并自行承担此风险。使用 Cloudflare WARP 是其官方推荐的个人安全上网方式。</li>\n</ul>\n</li>\n<li><p><strong>问：REALITY 和 XTLS 有什么区别？</strong></p>\n<ul>\n<li><strong>答：</strong> XTLS 是一种旨在减少 VLESS/Trojan 协议中 TLS 加密层级开销的技术，核心在于优化数据传输路径，提高性能。REALITY 则是一种更侧重于消除服务器端 TLS 指纹、增强抗检测能力的协议特性，它通过“借用”真实网站的 TLS 证书指纹来实现伪装。两者可以独立使用（VLESS+XTLS+TLS 或 VLESS+TCP+REALITY），也可以在某些配置下（如 VLESS over TCP with XTLS-Vision and REALITY）协同工作，但 REALITY 本身通常不与传统的 TLS 证书配置同时用于同一入站。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"相关资源链接\"><a href=\"#相关资源链接\" class=\"headerlink\" title=\"相关资源链接\"></a>相关资源链接</h3><ul>\n<li><strong>Xray-core GitHub:</strong>(<a href=\"https://github.com/XTLS/Xray-core\">https://github.com/XTLS/Xray-core</a>)</li>\n<li><strong>3x-ui (MHSanaei) GitHub:</strong>(<a href=\"https://github.com/MHSanaei/3x-ui\">https://github.com/MHSanaei/3x-ui</a>) 6</li>\n<li><strong>Cloudflare 官方文档:</strong> <a href=\"https://developers.cloudflare.com/\">https://developers.cloudflare.com/</a></li>\n<li><strong>Nekoray 客户端:</strong>(<a href=\"https://github.com/MatsuriDayo/nekoray\">https://github.com/MatsuriDayo/nekoray</a>)</li>\n<li><strong>V2RayNG 客户端 (Android):</strong> <a href=\"https://github.com/2dust/v2rayNG\">https://github.com/2dust/v2rayNG</a></li>\n<li><strong>ShadowRocket (iOS):</strong> App Store (付费应用)</li>\n<li><strong>FoXray (iOS):</strong> App Store</li>\n<li><strong>WireGuard 官方网站:</strong> <a href=\"https://www.wireguard.com/\">https://www.wireguard.com/</a></li>\n</ul>\n",
            "tags": [
                "教程"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/31/cloudflare-dai-li-pei-zhi-duan-kou/",
            "url": "https://0xdadream.github.io/2025/05/31/cloudflare-dai-li-pei-zhi-duan-kou/",
            "title": "Cloudflare代理配置端口",
            "date_published": "2025-05-31T08:25:00.000Z",
            "content_html": "<h1 id=\"Cloudflare代理配置端口\"><a href=\"#Cloudflare代理配置端口\" class=\"headerlink\" title=\"Cloudflare代理配置端口\"></a>Cloudflare代理配置端口</h1><h2 id=\"一、前提条件\"><a href=\"#一、前提条件\" class=\"headerlink\" title=\"一、前提条件\"></a>一、前提条件</h2><ul>\n<li>已有注册好的Cloudflare账号（免费即可）。</li>\n<li>已将你的域名成功接入Cloudflare（DNS已指向Cloudflare的Name Server）。</li>\n</ul>\n<hr>\n<h2 id=\"二、Cloudflare可用端口概述\"><a href=\"#二、Cloudflare可用端口概述\" class=\"headerlink\" title=\"二、Cloudflare可用端口概述\"></a>二、Cloudflare可用端口概述</h2><p>Cloudflare 仅能代理特定的HTTP和HTTPS端口。常用端口总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>可用端口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP</td>\n<td>80, 8080, 8880, 2052, 2082, 2086, 2095</td>\n</tr>\n<tr>\n<td>HTTPS</td>\n<td>443, 8443, 2053, 2083, 2087, 2096</td>\n</tr>\n</tbody></table>\n<p>如果你的应用需要使用其他端口（如SSH、FTP），则必须使用Cloudflare的Spectrum服务（通常为付费企业版服务）。</p>\n<hr>\n<h2 id=\"三、具体配置流程\"><a href=\"#三、具体配置流程\" class=\"headerlink\" title=\"三、具体配置流程\"></a>三、具体配置流程</h2><p>以将服务器的<code>8080</code>端口通过Cloudflare实现域名访问为例：</p>\n<h3 id=\"①-服务器端准备\"><a href=\"#①-服务器端准备\" class=\"headerlink\" title=\"① 服务器端准备\"></a>① 服务器端准备</h3><p>确保你的服务器端应用正常监听指定端口：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 例如：测试8080端口是否开启</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">netstat</span> <span class=\"token parameter variable\">-tunlp</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token number\">8080</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"②-Cloudflare-DNS设置\"><a href=\"#②-Cloudflare-DNS设置\" class=\"headerlink\" title=\"② Cloudflare DNS设置\"></a>② Cloudflare DNS设置</h3><ul>\n<li>登录Cloudflare后台：<a href=\"https://dash.cloudflare.com/\">https://dash.cloudflare.com/</a></li>\n<li>选择已接入Cloudflare的域名。</li>\n<li>点击菜单栏中的<code>DNS</code>选项卡。</li>\n</ul>\n<h4 id=\"添加DNS记录：\"><a href=\"#添加DNS记录：\" class=\"headerlink\" title=\"添加DNS记录：\"></a>添加DNS记录：</h4><ul>\n<li>点击 <code>Add record</code>（添加记录）。</li>\n<li>类型选择 <code>A</code> 或 <code>CNAME</code>：<ul>\n<li>若为IP地址（例如服务器IP），选择<code>A</code>。</li>\n<li>若为其他域名，选择<code>CNAME</code>。</li>\n</ul>\n</li>\n</ul>\n<p>示例：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>示例值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Type</td>\n<td>A</td>\n</tr>\n<tr>\n<td>Name</td>\n<td><code>example</code> （即你希望访问的子域名）</td>\n</tr>\n<tr>\n<td>IPv4 address</td>\n<td><code>你的服务器IP</code></td>\n</tr>\n<tr>\n<td>Proxy status</td>\n<td>选择橙色云图标（✅代理）</td>\n</tr>\n</tbody></table>\n<ul>\n<li>最终访问域名形式如：<code>example.yourdomain.com</code></li>\n</ul>\n<h3 id=\"③-服务端口访问说明\"><a href=\"#③-服务端口访问说明\" class=\"headerlink\" title=\"③ 服务端口访问说明\"></a>③ 服务端口访问说明</h3><p>Cloudflare不会直接显示端口号在URL中。因此：</p>\n<ul>\n<li>如果你的服务器使用Cloudflare默认支持的端口（如8080），你在访问时<strong>不需要明确指定端口号</strong>。<ul>\n<li>实际请求如：<code>http://example.yourdomain.com</code></li>\n</ul>\n</li>\n<li>你的服务器上仍然监听的是8080端口，Cloudflare则自动将访问请求代理至此端口。</li>\n</ul>\n<p><strong>示例场景</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>用户访问URL</th>\n<th>实际服务器监听端口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>http://example.yourdomain.com</code></td>\n<td>8080</td>\n</tr>\n<tr>\n<td><code>https://example.yourdomain.com</code>（HTTPS）</td>\n<td>8443、443等（按需设置）</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"四、HTTPS-配置\"><a href=\"#四、HTTPS-配置\" class=\"headerlink\" title=\"四、HTTPS 配置\"></a>四、HTTPS 配置</h2><p>若你希望使用HTTPS访问：</p>\n<ol>\n<li>到Cloudflare后台 → <code>SSL/TLS</code> 选项：<ul>\n<li>推荐设置为<code>Flexible</code>（最简单）或<code>Full</code>模式。</li>\n</ul>\n</li>\n<li>如果是<code>Full</code>模式（推荐）：<ul>\n<li>服务器上需要配置SSL证书（可以使用免费的证书如Let’s Encrypt）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例-Nginx-配置（Full-模式）：\"><a href=\"#示例-Nginx-配置（Full-模式）：\" class=\"headerlink\" title=\"示例 Nginx 配置（Full 模式）：\"></a>示例 Nginx 配置（Full 模式）：</h3><pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span> <span class=\"token number\">8443</span> ssl</span><span class=\"token punctuation\">;</span> \n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span> example.yourdomain.com</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">ssl_certificate</span>     /path/to/cert.pem</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">ssl_certificate_key</span> /path/to/key.pem</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://localhost:8080</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Host <span class=\"token variable\">$host</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> X-Forwarded-For <span class=\"token variable\">$proxy_add_x_forwarded_for</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> X-Real-IP <span class=\"token variable\">$remote_addr</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>Cloudflare → 8443（HTTPS）→ Nginx → 8080（HTTP内网服务）</li>\n</ul>\n<hr>\n<h2 id=\"五、其他非标准端口（如SSH、FTP）支持方法\"><a href=\"#五、其他非标准端口（如SSH、FTP）支持方法\" class=\"headerlink\" title=\"五、其他非标准端口（如SSH、FTP）支持方法\"></a>五、其他非标准端口（如SSH、FTP）支持方法</h2><ul>\n<li>默认Cloudflare免费版不支持SSH、FTP等非HTTP端口代理。</li>\n<li>若有这类需求，可以购买Cloudflare Spectrum服务：<ul>\n<li>在Cloudflare后台，进入Spectrum（频谱）服务，选择协议和端口映射到你的服务器IP地址即可。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"六、常见问题与解决办法\"><a href=\"#六、常见问题与解决办法\" class=\"headerlink\" title=\"六、常见问题与解决办法\"></a>六、常见问题与解决办法</h2><ul>\n<li><strong>访问失败或返回522错误</strong>：<ul>\n<li>检查服务器端防火墙是否允许Cloudflare IP段访问服务器端口。</li>\n<li>检查服务器程序是否正常运行，端口是否已开启。</li>\n</ul>\n</li>\n<li><strong>SSL问题</strong>：<ul>\n<li>Flexible模式下，无需服务器端SSL证书（Cloudflare自动处理）。</li>\n<li>Full模式必须安装SSL证书。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "cloudflare"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/31/sing-box-da-jian-jie-dian/",
            "url": "https://0xdadream.github.io/2025/05/31/sing-box-da-jian-jie-dian/",
            "title": "Sing-box 搭建您的专属科学上网节点实用指南",
            "date_published": "2025-05-31T04:25:00.000Z",
            "content_html": "<h1 id=\"Sing-box-搭建您的专属“科学上网”节点实用指南\"><a href=\"#Sing-box-搭建您的专属“科学上网”节点实用指南\" class=\"headerlink\" title=\"Sing-box 搭建您的专属“科学上网”节点实用指南\"></a>Sing-box 搭建您的专属“科学上网”节点实用指南</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h3 id=\"Sing-box-简介：强大的通用代理平台\"><a href=\"#Sing-box-简介：强大的通用代理平台\" class=\"headerlink\" title=\"Sing-box 简介：强大的通用代理平台\"></a>Sing-box 简介：强大的通用代理平台</h3><p>Sing-box 是一款新兴且功能强大的通用代理平台，被广泛认为是 V2Ray 和 Xray 等成熟工具的有力替代品 。它凭借其卓越的性能、轻量化的设计、对多种代理协议的广泛支持、高度模块化的架构以及积极的社区开发，迅速获得了用户的青睐 。Sing-box 基于 Go 语言开发，并以开源形式发布，这不仅保证了其透明度和安全性，也促进了社区的共同发展和完善 。</p>\n<h3 id=\"本教程目标\"><a href=\"#本教程目标\" class=\"headerlink\" title=\"本教程目标\"></a>本教程目标</h3><p>本教程旨在提供一个从零开始的详尽指南，帮助具备一定技术背景的用户在自己的服务器上成功安装和配置 sing-box，并部署多种当前流行且高效的代理协议。通过本教程，用户将能够：</p>\n<ul>\n<li>选择合适的服务器并完成 sing-box 的安装。</li>\n<li>理解 sing-box 的核心概念和配置文件结构。</li>\n<li>配置服务器防火墙，确保代理服务的正常运行。</li>\n<li>详细配置 VLESS (配合 Reality)、Trojan (配合 TLS)、Shadowsocks (2022新加密)、Hysteria2 和 TUIC 等主流代理协议。</li>\n<li>了解客户端的基本配置方法和主流客户端软件。</li>\n<li>初步接触如使用 CDN 隐藏服务器 IP、配置基本路由和故障转移等高级技巧。</li>\n</ul>\n<p>尽管本教程力求详尽，但 sing-box 的功能远不止于此。鼓励用户在掌握基础后，进一步查阅其官方文档 ，探索更多高级定制功能，以满足个性化需求。</p>\n<h2 id=\"第一章：理解与安装-Sing-box\"><a href=\"#第一章：理解与安装-Sing-box\" class=\"headerlink\" title=\"第一章：理解与安装 Sing-box\"></a>第一章：理解与安装 Sing-box</h2><h3 id=\"1-1-Sing-box-核心概念：构建代理节点的基石\"><a href=\"#1-1-Sing-box-核心概念：构建代理节点的基石\" class=\"headerlink\" title=\"1.1. Sing-box 核心概念：构建代理节点的基石\"></a>1.1. Sing-box 核心概念：构建代理节点的基石</h3><p>理解 sing-box 的核心组件及其交互方式，是成功配置和高效使用该平台的基础。其模块化设计允许用户灵活组合不同的功能模块，以适应多样化的网络环境和需求。</p>\n<ul>\n<li><p><strong>入站连接 (Inbounds):</strong> 入站连接负责处理从客户端设备（例如您的电脑或手机）传入 sing-box 服务器的连接请求。Sing-box 支持多种入站协议类型，常见的包括 Shadowsocks、Trojan、VLESS、VMess、Hysteria2、TUIC、Naive、ShadowTLS，以及用于创建虚拟网卡的 Tun 和用于透明代理的 Redirect 等 。用户可以根据客户端的支持情况和安全需求选择合适的入站协议。</p>\n</li>\n<li><p><strong>出站连接 (Outbounds):</strong> 出站连接定义了 sing-box 服务器如何处理经过其的数据流，即如何将数据转发到目标互联网地址或其他代理服务器。常见的出站类型有 Direct（直接连接）、Block（阻止连接）、Shadowsocks、Trojan、VLESS、WireGuard、Hysteria2、TUIC，以及专门用于 DNS 查询的 DNS、用于节点选择的 Selector 和用于故障转移的 URLTest 等 。这种设计使得 sing-box 不仅能作为代理服务器，还能作为客户端连接其他代理，或实现复杂的代理链。</p>\n</li>\n<li><p><strong>路由 (Route):</strong> 路由模块是 sing-box 实现精细化流量控制的核心。用户可以通过定义一系列路由规则，根据流量的目标地址（如 GeoIP 数据库判断的地理位置、Geosite 预设的网站域名集合）、域名、协议类型等多种条件，将特定的流量导向不同的出站连接 。例如，可以配置国内网站直连，国外网站通过代理访问，从而优化访问速度和资源利用。</p>\n</li>\n<li><p><strong>DNS 配置:</strong> DNS（域名系统）在网络通信中扮演着将域名转换为 IP 地址的关键角色。Sing-box 内建了强大的 DNS 处理能力，允许用户配置自定义 DNS 服务器、设定 DNS 路由规则，并支持如 FakeIP（虚拟 IP）等高级功能，以防止 DNS 泄露，确保域名解析的准确性和安全性 。</p>\n</li>\n<li><p><strong>配置文件 (<code>config.json</code>):</strong> Sing-box 的所有配置均通过一个 JSON 格式的文件进行管理，通常命名为 <code>config.json</code> 。该文件包含了日志、DNS、入站、出站、路由等所有模块的配置信息。其顶层结构通常如下所示：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"log\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"dns\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"route\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"experimental\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>熟悉 JSON 语法并理解各配置项的含义对于手动配置 sing-box至关重要。</p>\n</li>\n</ul>\n<p>sing-box 的架构设计体现了高度的模块化，官方文档 在其配置结构中明确区分了入站、出站和路由等组件。这种设计带来了显著的灵活性，例如支持同时作为客户端和服务器运行 ，以及实现多协议负载均衡 。这意味着用户可以根据具体需求自由组合这些模块，构建从简单的个人代理到复杂的多跳转发网关等各种应用场景，这相较于一些功能固化的工具是一个显著的优势。</p>\n<h3 id=\"1-2-选择您的服务器-VPS-：地理位置与操作系统考量\"><a href=\"#1-2-选择您的服务器-VPS-：地理位置与操作系统考量\" class=\"headerlink\" title=\"1.2. 选择您的服务器 (VPS)：地理位置与操作系统考量\"></a>1.2. 选择您的服务器 (VPS)：地理位置与操作系统考量</h3><p>选择一台合适的虚拟专用服务器（VPS）是搭建稳定高效代理服务的前提。以下是一些关键考量因素：</p>\n<ul>\n<li><strong>地理位置:</strong> 服务器的地理位置直接影响到您的访问速度和能否顺畅访问特定区域的内容。应选择距离用户较近且能提供良好国际网络连接的地区。</li>\n<li><strong>服务商信誉:</strong> 选择知名且信誉良好的 VPS 服务商，以确保服务的稳定性、可靠的技术支持和合理的资源分配。</li>\n<li><strong>资源需求:</strong> 根据预期的负载情况，选择合适的 CPU、内存（RAM）和带宽。对于个人使用，通常入门级配置即可满足需求，但如果用户较多或流量较大，则需相应提高配置。</li>\n<li><strong>操作系统:</strong> 强烈推荐选用 Linux 发行版，特别是 <strong>Ubuntu 或 Debian</strong>。这两个发行版拥有庞大的用户社区、丰富的文档资源，并且 sing-box 官方提供了便捷的安装脚本和软件包支持 。</li>\n</ul>\n<p>绝大多数关于 sing-box 及类似代理工具的安装指南和社区讨论都集中在 Linux 平台 。这并非偶然，Linux 服务器以其经济高效、命令行环境的强大管理能力以及 <code>systemd</code> 等标准化服务管理工具 1成为自建代理服务的首选。Sing-box 本身也对 Linux 提供了深度支持，包括一些依赖特定操作系统内核的功能（如 TUN 模式） 。因此，对于追求稳定、文档完善且易于维护的服务器端部署而言，选择 Ubuntu 或 Debian Linux 将是最直接且高效的路径。</p>\n<h3 id=\"1-3-在您的服务器上安装-Sing-box-以-Ubuntu-Debian-为例\"><a href=\"#1-3-在您的服务器上安装-Sing-box-以-Ubuntu-Debian-为例\" class=\"headerlink\" title=\"1.3. 在您的服务器上安装 Sing-box (以 Ubuntu/Debian 为例)\"></a>1.3. 在您的服务器上安装 Sing-box (以 Ubuntu/Debian 为例)</h3><p>Sing-box 提供了多种安装方式，对于 Ubuntu/Debian 系统，推荐使用官方提供的安装脚本，操作简便快捷。</p>\n<ul>\n<li><p>使用官方通用安装脚本:</p>\n<p>通过以下命令下载并执行安装脚本，该脚本会自动检测系统并安装最新稳定版的 sing-box：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">curl -fsSL https://sing-box.app/install.sh | sudo bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果偏好专门为 Debian/Ubuntu 优化的脚本，可以使用：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">curl -fsSL https://sing-box.app/deb-install.sh | sudo bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>安装特定版本或 Beta 测试版:</p>\n<p>如果需要安装 Beta 版本以体验最新功能，或指定安装某一特定版本，可以在执行脚本时附加参数：</p>\n<ul>\n<li><p>安装最新 Beta 版：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">curl -fsSL https://sing-box.app/install.sh | sudo bash -s -- --beta<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>安装特定版本 (例如 1.8.0)：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">curl -fsSL https://sing-box.app/install.sh | sudo bash -s -- --version 1.8.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>通过 APT 软件源安装 (适用于 Debian/Ubuntu):</p>\n<p>对于希望通过系统包管理器管理 sing-box 的用户，可以添加 SagerNet 的官方 APT 软件源：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo mkdir -p /etc/apt/keyrings &amp;&amp; \\\nsudo curl -fsSL https://sing-box.app/gpg.key -o /etc/apt/keyrings/sagernet.asc &amp;&amp; \\\nsudo chmod a+r /etc/apt/keyrings/sagernet.asc &amp;&amp; \\\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/sagernet.asc] https://deb.sagernet.org/ * *\" | \\\nsudo tee /etc/apt/sources.list.d/sagernet.list &gt; /dev/null &amp;&amp; \\\nsudo apt-get update &amp;&amp; \\\nsudo apt-get install sing-box<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这种方式便于后续的更新和维护。</p>\n</li>\n<li><p>其他操作系统安装简介:</p>\n<p>尽管本教程主要关注 Linux 服务器，但 sing-box 的命令行版本也支持其他操作系统。例如，macOS 用户可以通过 Homebrew (brew install sing-box) 安装，Windows 用户可以使用 Scoop (scoop install sing-box) 或 Chocolatey (choco install sing-box) 进行安装 。这些主要适用于在本地计算机上使用 sing-box 命令行客户端的场景。</p>\n</li>\n</ul>\n<h3 id=\"1-4-Sing-box-核心命令行工具-CLI\"><a href=\"#1-4-Sing-box-核心命令行工具-CLI\" class=\"headerlink\" title=\"1.4. Sing-box 核心命令行工具 (CLI)\"></a>1.4. Sing-box 核心命令行工具 (CLI)</h3><p>掌握 sing-box 的命令行工具对于服务器管理、配置调试和自动化操作至关重要。以下是一些最常用的命令：</p>\n<ul>\n<li><code>sing-box version</code>: 显示已安装的 sing-box 版本信息，包括构建标签 (build tags) 。构建标签指明了编译时包含了哪些特性，例如 <code>with_reality_server</code> 表示支持 Reality 协议，<code>with_quic</code> 表示支持 QUIC 协议。</li>\n<li><code>sing-box run -c /etc/sing-box/config.json</code>: 使用指定的配置文件启动 sing-box 服务 。默认情况下，sing-box 会查找 <code>/etc/sing-box/config.json</code>。</li>\n<li><code>sing-box check -c /etc/sing-box/config.json</code>: 校验配置文件的语法和基本逻辑是否正确，这是在启动或重启服务前非常重要的一步 。</li>\n<li><code>sing-box format -w -c /etc/sing-box/config.json</code>: 格式化（美化）JSON 配置文件，使其更易读。<code>-w</code> 参数表示直接写入修改到原文件 。</li>\n<li><code>sing-box generate uuid</code>: 生成一个标准的 UUID (通用唯一识别码)，常用于 VLESS、VMess 等协议的用户ID配置 。</li>\n<li><code>sing-box generate reality-keypair</code>: 生成一对公私钥，专用于配置 VLESS Reality 协议 。</li>\n<li><strong>通过 <code>systemd</code> 管理服务 (若已安装为系统服务):</strong><ul>\n<li><code>sudo systemctl start sing-box</code>: 启动服务。</li>\n<li><code>sudo systemctl stop sing-box</code>: 停止服务。</li>\n<li><code>sudo systemctl restart sing-box</code>: 重启服务。</li>\n<li><code>sudo systemctl enable sing-box</code>: 设置服务开机自启。</li>\n<li><code>sudo systemctl status sing-box</code>: 查看服务运行状态。</li>\n<li><code>sudo journalctl -u sing-box -f --output cat</code>: 实时查看服务日志（ <code>-f</code> 表示 follow，<code>--output cat</code> 以简化格式输出） 。</li>\n</ul>\n</li>\n</ul>\n<p>sing-box 提供的一系列命令行工具，覆盖了从运行、配置管理到密钥生成的各个核心环节 。这些工具不仅是手动管理 sing-box 实例的基础，更是实现自动化部署、配置更新等高级操作的基石。例如，<code>generate uuid</code> 和 <code>generate reality-keypair</code> 等命令简化了需要特定加密材料的协议的配置过程。同时，通过 <code>systemctl</code> 与 Linux 标准服务管理体系的集成，确保了 sing-box 服务的稳定可靠运行。因此，即使未来出现更多图形化管理界面，熟练运用这些命令行工具对于任何希望深度掌控和高效运维 sing-box 服务器的管理员来说，都是不可或缺的技能。</p>\n<h3 id=\"1-5-config-json-文件结构解析-再探\"><a href=\"#1-5-config-json-文件结构解析-再探\" class=\"headerlink\" title=\"1.5. config.json 文件结构解析 (再探)\"></a>1.5. <code>config.json</code> 文件结构解析 (再探)</h3><p>再次强调 <code>config.json</code> 的核心地位及其主要构成部分，有助于用户在后续章节中更好地理解和修改配置。</p>\n<ul>\n<li><strong><code>log</code></strong>: 配置日志记录的级别（如 <code>info</code>, <code>warn</code>, <code>error</code>, <code>debug</code>, <code>trace</code>）、输出位置（默认标准输出，可指定文件路径）以及是否添加时间戳等 。</li>\n<li><strong><code>dns</code></strong>: 管理 DNS 解析行为，包括设置上游 DNS 服务器、DNS 策略（如 IPv4_only）、DNS 规则（如根据域名分流到不同 DNS 服务器）、FakeIP 等 。</li>\n<li><strong><code>ntp</code></strong>: 网络时间协议 (NTP) 配置，用于同步服务器时间，确保时间准确性，这对于某些依赖时间戳的加密协议和证书验证非常重要 。</li>\n<li><strong><code>inbounds</code></strong>: 定义一个或多个入站连接处理器。每个入站配置指定了监听的 IP 地址、端口、协议类型（如 VLESS, Trojan）以及该协议所需的用户认证、TLS 等参数 。</li>\n<li><strong><code>outbounds</code></strong>: 定义一个或多个出站连接处理器。每个出站配置指定了连接的目标服务器、端口、协议类型（如 <code>direct</code> 直连, <code>block</code> 阻止, 或具体的代理协议）以及相应的认证和传输参数 。</li>\n<li><strong><code>route</code></strong>: 包含路由规则列表。这些规则决定了符合特定条件的入站流量应该被转发到哪个出站连接。规则可以基于域名、IP、地理位置、端口、进程名等多种条件 。</li>\n<li><strong><code>experimental</code></strong>: 用于配置一些实验性功能，例如 Clash API 兼容接口，允许通过 Clash 兼容的控制面板管理 sing-box 。</li>\n</ul>\n<p>对这些主要部分的理解，将为后续针对不同协议的具体配置打下坚实基础。</p>\n<h2 id=\"第二章：准备您的服务器环境\"><a href=\"#第二章：准备您的服务器环境\" class=\"headerlink\" title=\"第二章：准备您的服务器环境\"></a>第二章：准备您的服务器环境</h2><p>在正式配置 sing-box 代理协议之前，确保服务器环境的安全性与网络通畅性至关重要。</p>\n<h3 id=\"2-1-基础服务器安全加固-简述\"><a href=\"#2-1-基础服务器安全加固-简述\" class=\"headerlink\" title=\"2.1. 基础服务器安全加固 (简述)\"></a>2.1. 基础服务器安全加固 (简述)</h3><p>一台暴露在公网的服务器需要基本的安全防护措施：</p>\n<ul>\n<li><p>系统更新:</p>\n<p> 始终保持操作系统及其软件包为最新版本，以修复已知的安全漏洞。</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo apt update &amp;&amp; sudo apt upgrade -y<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>SSH 安全:</p>\n<ul>\n<li><strong>使用密钥认证:</strong> 强烈建议禁用密码登录，转而使用 SSH 密钥对进行认证，这能极大提高登录安全性。</li>\n<li><strong>禁止 root 登录:</strong> 修改 SSHD 配置 (<code>/etc/ssh/sshd_config</code>)，设置 <code>PermitRootLogin no</code>，并使用普通用户登录后再通过 <code>sudo</code> 执行特权命令。</li>\n<li><strong>(可选) 修改 SSH 默认端口:</strong> 将 SSH 服务从默认的 22 端口迁移到其他非标准端口，可以在一定程度上减少自动化的扫描和爆破尝试，但这更多的是一种“安全靠隐蔽”的次要措施。</li>\n</ul>\n</li>\n</ul>\n<p>本教程不提供详尽的服务器安全指南，以上仅为最基础的建议。用户应根据自身情况参考更专业的安全文档进行加固。</p>\n<h3 id=\"2-2-防火墙配置：为代理协议开放端口\"><a href=\"#2-2-防火墙配置：为代理协议开放端口\" class=\"headerlink\" title=\"2.2. 防火墙配置：为代理协议开放端口\"></a>2.2. 防火墙配置：为代理协议开放端口</h3><p>防火墙是服务器的第一道网络防线，它控制着哪些端口允许外部访问。您必须为计划使用的代理协议开放相应的服务器端口。</p>\n<ul>\n<li><p>在 Ubuntu/Debian 上使用 UFW (Uncomplicated Firewall):</p>\n<p>UFW 是一个用户友好的防火墙管理工具。</p>\n<ol>\n<li><p>安装 UFW (如果尚未安装):</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo apt install ufw<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>设置默认策略:</p>\n<p> 拒绝所有传入连接，允许所有传出连接。</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw default deny incoming\nsudo ufw default allow outgoing<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>允许 SSH 连接 (关键步骤):</p>\n<p> 在启用 UFW 之前，务必先允许 SSH 连接，否则您可能会失去对服务器的访问权限。</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw allow ssh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或者，如果您修改了 SSH 端口：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw allow &lt;您的_SSH_端口&gt;/tcp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>为代理协议开放端口:</p>\n<p> 根据您选择的协议和配置的端口，使用以下命令开放 TCP 和/或 UDP 端口。例如，如果您计划在 8443 端口上运行一个 TCP 协议，在 9000-9005 端口范围运行一个 UDP 协议：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw allow 8443/tcp\nsudo ufw allow 9000:9005/udp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>启用 UFW:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw enable<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>系统会提示操作可能中断现有 SSH 连接，确认即可。 </p>\n</li>\n<li><p>查看状态:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo ufw status verbose<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n</li>\n<li><p>在 CentOS/RHEL/Fedora (及部分 Debian/Ubuntu) 上使用 firewalld:</p>\n<p>firewalld 是另一款常用的动态防火墙管理工具。</p>\n<ol>\n<li><p>查看 <code>firewalld</code> 状态:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --state<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>永久开放端口:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --permanent --add-port=&lt;端口号&gt;/tcp\nsudo firewall-cmd --permanent --add-port=&lt;端口号&gt;/udp\nsudo firewall-cmd --permanent --add-port=&lt;起始端口&gt;-&lt;结束端口&gt;/tcp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>永久开放服务 (例如 HTTPS，如果协议伪装在 443 端口):</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --permanent --add-service=https<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>重新加载 <code>firewalld</code> 配置使其生效:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>查看已开放的端口:</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo firewall-cmd --list-ports<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n</li>\n<li><p><strong>表 2.2.1: 常见代理协议及其默认/推荐端口</strong></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>协议</strong></th>\n<th><strong>默认/常用端口</strong></th>\n<th><strong>TCP/UDP</strong></th>\n<th><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VLESS (Reality)</td>\n<td>443, 80, 其他自定义端口</td>\n<td>TCP</td>\n<td>常使用 443 端口伪装成 HTTPS。Reality 可灵活使用多种端口。</td>\n</tr>\n<tr>\n<td>Trojan (TLS)</td>\n<td>443</td>\n<td>TCP</td>\n<td>通常使用 443 端口进行 TLS 加密通信。</td>\n</tr>\n<tr>\n<td>Shadowsocks</td>\n<td>用户自定义 (如 8388, 443)</td>\n<td>TCP/UDP</td>\n<td>无标准端口；443 端口可用于流量混淆。</td>\n</tr>\n<tr>\n<td>Hysteria2</td>\n<td>用户自定义</td>\n<td>UDP</td>\n<td>基于 QUIC，常使用高位端口或 443/udp。</td>\n</tr>\n<tr>\n<td>TUIC</td>\n<td>用户自定义</td>\n<td>UDP</td>\n<td>基于 QUIC，常使用高位端口或 443/udp。</td>\n</tr>\n<tr>\n<td>VMess</td>\n<td>用户自定义</td>\n<td>TCP/UDP</td>\n<td>无标准端口。</td>\n</tr>\n<tr>\n<td>ShadowTLS</td>\n<td>443 (外层)</td>\n<td>TCP</td>\n<td>包装其他协议，外层连接通常在 443 端口。</td>\n</tr>\n<tr>\n<td>NaiveProxy</td>\n<td>443, 80</td>\n<td>TCP</td>\n<td>模仿标准 Web 流量。</td>\n</tr>\n</tbody></table>\n<p>无论是 UFW  还是 <code>firewalld</code>，其默认策略通常是拒绝所有未经明确允许的入站连接。这是一种基础且重要的安全实践，旨在最小化服务器的潜在攻击面。因此，用户必须显式地为 SSH（远程管理）和计划运行的代理协议开放端口。忽略或错误配置防火墙，不仅可能导致代理服务无法访问，还可能使服务器暴露于不必要的安全风险之下。因此，防火墙的正确配置是保障代理节点正常运作和安全性的前提条件。</p>\n<h2 id=\"第三章：在-Sing-box-中配置热门协议\"><a href=\"#第三章：在-Sing-box-中配置热门协议\" class=\"headerlink\" title=\"第三章：在 Sing-box 中配置热门协议\"></a>第三章：在 Sing-box 中配置热门协议</h2><p>本章节将详细介绍如何在 sing-box 中配置当前流行且在“科学上网”场景下表现优异的几种代理协议。每个协议的配置都将包含服务器端（入站）和客户端（出站）的 JSON 代码片段，并对关键字段进行解释。</p>\n<p><em>通用说明：</em></p>\n<ul>\n<li><em>每个协议小节都会简要介绍其特性、基于的传输方式（TCP/UDP）、加密和混淆技术，以及其在规避审查方面的有效性。</em></li>\n<li><em>所有配置示例均为 sing-box 的 JSON 格式，并附带注释说明。</em></li>\n<li><em>会提及配置该协议可能需要的前提条件，如域名、SSL 证书、生成的密钥对等。</em></li>\n</ul>\n<h3 id=\"3-1-VLESS-配合-Reality-和-或-XTLS-Vision\"><a href=\"#3-1-VLESS-配合-Reality-和-或-XTLS-Vision\" class=\"headerlink\" title=\"3.1. VLESS (配合 Reality 和/或 XTLS-Vision)\"></a>3.1. VLESS (配合 Reality 和/或 XTLS-Vision)</h3><ul>\n<li><p><strong>协议概述:</strong> VLESS 以其高性能和灵活性著称。Reality 是一种先进的流量伪装技术，它使得代理服务器在未授权的探测者看来完全像一个真实的、普通的网站（例如 <code>www.microsoft.com</code>），从而极大地增强了抗审查能力。XTLS-Vision 是一种流控模式，旨在进一步优化性能 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置 (VLESS + Reality):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"tls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"server_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.actual.domain.com\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 你的真实域名，用于申请证书 (如果使用 ACME)</span>\n        <span class=\"token property\">\"reality\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"handshake\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token property\">\"server\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"www.microsoft.com\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 伪装的目标网站域名</span>\n            <span class=\"token property\">\"server_port\"</span><span class=\"token operator\">:</span> <span class=\"token number\">443</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"private_key\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"YOUR_REALITY_PRIVATE_KEY\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 使用 'sing-box generate reality-keypair' 生成</span>\n          <span class=\"token property\">\"short_id\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 1到2个字节的十六进制字符串，例如 \"01\" 或 \"abcd\"</span>\n          <span class=\"token property\">\"max_time_difference\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1m\"</span> <span class=\"token comment\">// 允许客户端与服务器的最大时间差</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 如果不使用 Reality 自签名证书，而是为 your.actual.domain.com 申请真实证书，</span>\n        <span class=\"token comment\">// 则需要配置 ACME 或 certificate_path/key_path</span>\n        <span class=\"token comment\">// \"acme\": {</span>\n        <span class=\"token comment\">//   \"domain\": \"your.actual.domain.com\",</span>\n        <span class=\"token comment\">//   \"email\": \"your-email@example.com\"</span>\n        <span class=\"token comment\">// }</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>uuid</code>: 用户的唯一标识符。</li>\n<li><code>tls.server_name</code>: 对于 Reality 而言，此处的 <code>server_name</code> 是您希望 Reality “伪装”成的目标网站的域名，客户端连接时会使用这个 SNI。</li>\n<li><code>reality.handshake.server</code>: 实际发起 TLS 握手的目标服务器，通常是知名的大型网站，以增加伪装的真实性。</li>\n<li><code>reality.private_key</code>: 通过 <code>sing-box generate reality-keypair</code> 命令生成的私钥。公钥需要配置在客户端。</li>\n<li><code>reality.short_id</code>: 一个或多个短ID（1-2字节的十六进制字符串），客户端连接时需要匹配其中一个。</li>\n<li><code>flow: \"xtls-rprx-vision\"</code>: VLESS 的一种流处理模式，可提升性能 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置 (VLESS + Reality):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>tls.server_name</code>: 客户端在发起 TLS 握手时使用的 SNI，<strong>必须</strong>与服务器端 <code>reality.handshake.server</code> 字段中配置的域名完全一致。</li>\n<li><code>tls.reality.public_key</code>: 服务器端通过 <code>sing-box generate reality-keypair</code> 生成的公钥。</li>\n<li><code>tls.utls.fingerprint</code>: 模拟特定浏览器的 TLS 指纹，例如 “chrome”, “firefox”, “safari” 等，这有助于使流量看起来更像普通浏览器发出的流量，从而进一步抵抗指纹识别 。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Reality 技术的出现，是针对日益复杂的网络审查中主动探测和基于 SNI 封锁的有效回应 。传统的代理协议，即使流量加密，其 TLS 握手特征或服务器行为也可能被主动探测识别。同时，审查系统也可能直接封锁指向可疑服务器 IP 的特定 SNI 请求。Reality 通过“借用”一个高信誉、大流量的知名网站（如 <code>www.microsoft.com</code>）的 TLS 握手信息作为“外壳”，使得 sing-box 服务器在初始连接阶段的行为与该知名网站无法区分，从而有效规避主动探测。在这次“伪装”握手之后，真实的 VLESS 代理流量才通过这对由 <code>private_key</code> 和 <code>public_key</code> 保护的加密通道进行传输。这种机制使得 VLESS + Reality 组合在当前环境下拥有极高的隐蔽性和抗封锁能力，是其广受欢迎的主要原因。</p>\n<h3 id=\"3-2-Trojan-配合-TLS，可选-WebSocket-传输\"><a href=\"#3-2-Trojan-配合-TLS，可选-WebSocket-传输\" class=\"headerlink\" title=\"3.2. Trojan (配合 TLS，可选 WebSocket 传输)\"></a>3.2. Trojan (配合 TLS，可选 WebSocket 传输)</h3><ul>\n<li><p><strong>协议概述:</strong> Trojan 协议通过模仿 HTTPS 流量的特征，使其在网络传输中难以被识别和区分。它通常需要配合一个真实的域名和有效的 SSL/TLS 证书使用。WebSocket (WS) 作为一种可选的传输层协议，可以将 Trojan 流量进一步封装在标准的 HTTP/HTTPS 连接中，这不仅增强了伪装性，还使得流量可以通过 CDN (内容分发网络) 进行中转，隐藏真实服务器 IP 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置 (Trojan + TLS):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"tls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"server_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 你的域名</span>\n        <span class=\"token comment\">// 使用 ACME 自动申请和续签证书 (推荐)</span>\n        <span class=\"token property\">\"acme\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"domain\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your-email@example.com\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 或者手动指定证书路径</span>\n        <span class=\"token comment\">// \"certificate_path\": \"/path/to/your/fullchain.pem\",</span>\n        <span class=\"token comment\">// \"key_path\": \"/path/to/your/private.key\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"multiplex\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 启用多路复用以提高性能</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 如果需要 WebSocket 传输 (例如配合 CDN)</span>\n      <span class=\"token comment\">// \"transport\": {</span>\n      <span class=\"token comment\">//   \"type\": \"ws\",</span>\n      <span class=\"token comment\">//   \"path\": \"/your-secret-websocket-path\" // 自定义 WebSocket 路径</span>\n      <span class=\"token comment\">// }</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>users.password</code>: Trojan 协议的认证密码。</li>\n<li><code>tls.server_name</code>: 必须是您拥有的、并且 DNS 解析指向您服务器 IP 的域名。</li>\n<li><code>tls.acme</code>: 推荐使用 ACME 自动管理 TLS 证书，sing-box 支持 Let’s Encrypt 等机构。</li>\n<li><code>multiplex.enabled</code>: 启用多路复用可以减少连接数，提高并发处理能力 。</li>\n<li><code>transport</code> (可选): 如果配置为 <code>\"ws\"</code>，则启用 WebSocket 传输。<code>path</code> 是 WebSocket 的访问路径，应设置为一个不易被猜到的字符串。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置 (Trojan + TLS):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>29 (WebSocket 部分参考 39)</p>\n<ul>\n<li>关键解释:<ul>\n<li><code>server</code>: 连接的服务器地址，推荐使用域名。</li>\n<li><code>tls.server_name</code>: 客户端进行 TLS 握手时提供的 SNI，必须与服务器证书绑定的域名一致，否则会导致握手失败。</li>\n<li><code>tls.utls.fingerprint</code>: 模拟特定浏览器的 TLS 客户端行为，增强伪装性 。</li>\n<li><code>transport.headers.Host</code> (使用 WS 时): 当通过 CDN 或反向代理连接时，通常需要设置正确的 <code>Host</code> 头，使其指向您的源服务器域名。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Trojan 协议的核心设计理念在于其高度的 HTTPS 流量模拟能力 。配置中对 TLS 参数（如 <code>server_name</code>、<code>certificate_path</code>、<code>key_path</code>）的强调，正是为了实现这种逼真的伪装 。一个与 <code>server_name</code>（即您的域名）匹配的有效 TLS 证书，是构成可信 HTTPS 通信的基础。如果使用自签名证书或 SNI 不匹配，很容易被中间的网络设备识别为异常流量。将 Trojan 服务部署在标准的 HTTPS 端口 443 上，能进一步增强其隐蔽性。因此，选择 Trojan 协议的用户，必须准备好获取一个域名，并为该域名配置有效的 TLS 证书（可以通过 sing-box 内置的 ACME 功能自动申请，或手动配置）。若缺乏这些要素，Trojan 协议主要的伪装特性将大打折扣，其抗审查能力也会显著下降。</p>\n<h3 id=\"3-3-Shadowsocks-重点关注-AEAD-2022-系列加密算法\"><a href=\"#3-3-Shadowsocks-重点关注-AEAD-2022-系列加密算法\" class=\"headerlink\" title=\"3.3. Shadowsocks (重点关注 AEAD 2022 系列加密算法)\"></a>3.3. Shadowsocks (重点关注 AEAD 2022 系列加密算法)</h3><ul>\n<li><p><strong>协议概述:</strong> Shadowsocks 是一种轻量级、广泛应用的代理协议。其 2022 系列的 AEAD (Authenticated Encryption with Associated Data) 加密算法，如 <code>2022-blake3-aes-128-gcm</code>，因其在安全性和抗探测性方面的提升而被官方推荐使用 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>method</code>: 选择一个 2022 系列的 AEAD 加密算法。</li>\n<li><code>password</code>: Shadowsocks 的连接密码。</li>\n<li><code>multiplex.enabled</code>: 启用多路复用。对于 Shadowsocks 而言，这不仅能提升性能，还能改善 UDP 流量的传输和隐蔽性 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>sing-box 官方文档在介绍 Shadowsocks 时，<em>强烈建议</em>开启多路复用功能来传输 UDP 流量，并指出“否则很容易受到被动检测” 。究其原因，传统的 Shadowsocks 实现（尤其是较早的加密方式或未启用多路复用的 UDP 传输）存在一些可被深度包检测（DPI）识别的流量特征 。多路复用技术（如 Shadowsocks 常用的 smux）允许在单个 TCP 连接上承载多个逻辑数据流，这不仅改变了流量模式，使其更难与使用连接池的常规网络流量区分开来，还为在 TCP 连接内隧道化 UDP 数据包提供了一种更为健壮和标准化的方式，这在许多受审查的网络环境中比直接转发原始 UDP 包更为可靠。因此，在 sing-box 中配置 Shadowsocks 时，用户应始终启用多路复用，特别是当需要可靠传输 UDP 流量（例如用于 QUIC 协议的应用、WebRTC 或在线游戏）时。忽视此建议将显著增加协议被探测和封锁的风险。</p>\n<h3 id=\"3-4-Hysteria2-基于-QUIC，高性能\"><a href=\"#3-4-Hysteria2-基于-QUIC，高性能\" class=\"headerlink\" title=\"3.4. Hysteria2 (基于 QUIC，高性能)\"></a>3.4. Hysteria2 (基于 QUIC，高性能)</h3><ul>\n<li><p><strong>协议概述:</strong> Hysteria2 专为在不稳定和高丢包网络环境下提供高速传输而设计。它基于定制的 QUIC 协议，并采用名为 “Brutal” 的拥塞控制算法，力求在恶劣网络条件下榨干带宽。其流量特征旨在伪装成标准的 HTTP/3 流量 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"tls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"server_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 你的域名</span>\n        <span class=\"token comment\">// 使用 ACME 自动申请证书</span>\n        <span class=\"token property\">\"acme\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"domain\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your-email@example.com\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 或手动指定证书</span>\n        <span class=\"token comment\">// \"certificate_path\": \"/path/to/your/fullchain.pem\",</span>\n        <span class=\"token comment\">// \"key_path\": \"/path/to/your/private.key\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"obfs\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 可选的 QUIC 流量混淆</span>\n         <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"salamander\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 目前仅支持 salamander</span>\n         <span class=\"token property\">\"password\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"YOUR_OBFS_PASSWORD\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>关键解释:<ul>\n<li><code>up_mbps</code>, <code>down_mbps</code>: 定义服务器的上下行带宽限制。客户端也需要配置相应的值。</li>\n<li><code>users.password</code> (或顶层 <code>password</code>): Hysteria2 的认证密码。注意 sing-box 不支持官方 Hysteria 客户端的 <code>username:password</code> 组合作为 <code>userpass</code> 的别名，需要直接填写组合后的密码 。</li>\n<li><code>tls</code>: Hysteria2 依赖 TLS 进行加密和认证，配置方式与 Trojan 类似，需要域名和证书。</li>\n<li><code>obfs</code> (可选): Salamander 混淆器可以对 QUIC 流量进行额外处理，可能增加抗检测性，但也会带来性能开销 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>Hysteria2 的核心优势在于其基于 UDP (QUIC) 的特性以及独特的 “Brutal” 拥塞控制算法，这使其在网络质量较差、丢包率高的环境下仍能努力维持高吞吐量 。然而，这也可能成为其潜在的弱点。正如 sing-box 文档所警示的，“基于 UDP 的代理……实际上比基于 TCP 的代理具有更明显的特征” 。尽管 QUIC 对大部分头部信息进行了加密，但在某些严格审查的网络中，大量非标准端口的 UDP 通信本身就可能引起注意。此外，“Brutal”拥塞控制算法为了追求带宽最大化，其产生的流量模式可能与常规 Web 流量所使用的标准 TCP 拥塞控制算法（如 Cubic 或 BBR）有所不同，长期来看存在被指纹识别的风险。因此，用户在选择 Hysteria2 时，应权衡其在恶劣网络下的性能优势与这种潜在的可检测性。</p>\n<h3 id=\"3-5-TUIC-基于-QUIC，低延迟\"><a href=\"#3-5-TUIC-基于-QUIC，低延迟\" class=\"headerlink\" title=\"3.5. TUIC (基于 QUIC，低延迟)\"></a>3.5. TUIC (基于 QUIC，低延迟)</h3><ul>\n<li><p><strong>协议概述:</strong> TUIC 是另一款基于 QUIC 的代理协议，其设计重点在于最小化连接握手延迟，并支持 0-RTT 连接建立。它也提供了高效的 UDP 代理能力 。</p>\n</li>\n<li><p><strong>服务器 (入站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"congestion_control\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bbr\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 拥塞控制算法，可选 \"cubic\", \"new_reno\", \"bbr\"</span>\n      <span class=\"token property\">\"auth_timeout\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"3s\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 认证超时时间</span>\n      <span class=\"token property\">\"heartbeat_interval\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"10s\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 心跳间隔 (sing-box v1.9+ 使用此字段名)</span>\n      <span class=\"token property\">\"tls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"server_name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"acme\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"domain\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your.domain.com\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your-email@example.com\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 或手动指定证书</span>\n        <span class=\"token comment\">// \"certificate_path\": \"/path/to/your/fullchain.pem\",</span>\n        <span class=\"token comment\">// \"key_path\": \"/path/to/your/private.key\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// \"zero_rtt_handshake\": false // 服务端通常不建议开启 0-RTT，有安全风险</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>(字段名 <code>heartbeat_interval</code> 对应新版 sing-box，旧版可能为 <code>heartbeat</code>)</p>\n<ul>\n<li>关键解释:<ul>\n<li><code>users</code>: 包含 <code>uuid</code> 和 <code>password</code> 用于认证。</li>\n<li><code>congestion_control</code>: 选择适合网络环境的 QUIC 拥塞控制算法。</li>\n<li><code>tls</code>: 与 Hysteria2 类似，需要域名和证书。</li>\n<li><code>zero_rtt_handshake</code>: 服务端通常应保持禁用（默认或显式设置为 <code>false</code>），以避免重放攻击的风险 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>客户端 (出站) 配置:</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// QUIC 通常使用 h3 作为 ALPN</span>\n        <span class=\"token property\">\"utls\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">\"enabled\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n          <span class=\"token property\">\"fingerprint\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"chrome\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// \"insecure\": true, // 如果服务器使用自签名证书且了解风险</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>TUIC 协议以其 0-RTT（零往返时间）握手能力作为提升连接速度、降低延迟的一大亮点 。0-RTT 允许客户端在第一个数据包中就携带应用数据，这通过复用先前连接中协商好的会话参数来实现。然而，正如 sing-box 官方入站配置文档所强调的，服务端启用 <code>zero_rtt_handshake</code> 存在被重放攻击的风险，并引用了 Cloudflare 关于“克隆人攻击”的文章作为佐证 。这种攻击的原理是，如果攻击者捕获了包含 0-RTT 数据的初始数据包，他们可以将这些数据包重放给服务器。由于服务器在处理 0-RTT 数据时无法轻易判断其新鲜度，这可能导致数据被重复处理或引发其他安全问题。尽管 QUIC 协议自身包含一些针对 0-RTT 的重放缓解措施，但并非万无一失。因此，对于注重安全性的应用场景，普遍建议谨慎对待 0-RTT，或避免将其用于非幂等请求。这意味着，尽管 TUIC 的 0-RTT 特性对延迟敏感型应用很有吸引力，用户必须清醒认识到相关的安全风险。为最大化安全性，服务端通常应禁用 0-RTT，即便这会牺牲部分握手延迟的极致优化。客户端仍可尝试发起 0-RTT 连接，但服务器端是否接受应由用户在充分理解并接受潜在风险后决定。</p>\n<ul>\n<li><strong>表 3.1: 特色协议对比概览</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>特性/协议</strong></th>\n<th><strong>VLESS (+Reality)</strong></th>\n<th><strong>Trojan (+TLS/WSS)</strong></th>\n<th><strong>Shadowsocks (2022)</strong></th>\n<th><strong>Hysteria2</strong></th>\n<th><strong>TUIC</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>基础协议</strong></td>\n<td>TCP (VLESS 本身传输层无关)</td>\n<td>TCP</td>\n<td>TCP (UDP via Mux)</td>\n<td>UDP (QUIC)</td>\n<td>UDP (QUIC)</td>\n</tr>\n<tr>\n<td><strong>主要混淆方式</strong></td>\n<td>TLS (Reality 伪装真实网站)</td>\n<td>TLS (模仿 HTTPS)</td>\n<td>加密流, AEAD 加密</td>\n<td>QUIC 加密 (伪装 HTTP/3)</td>\n<td>QUIC 加密</td>\n</tr>\n<tr>\n<td><strong>隐蔽性 (vs GFW)</strong></td>\n<td>高 (Reality)</td>\n<td>高 (如果配置得当)</td>\n<td>中到高 (2022 + Mux)</td>\n<td>中 (UDP 可能被针对)</td>\n<td>中 (UDP 可能被针对)</td>\n</tr>\n<tr>\n<td><strong>性能表现</strong></td>\n<td>良好至优秀</td>\n<td>良好</td>\n<td>良好</td>\n<td>优秀 (尤其在恶劣网络)</td>\n<td>优秀 (低延迟)</td>\n</tr>\n<tr>\n<td><strong>配置复杂度</strong></td>\n<td>中 (Reality 增加步骤)</td>\n<td>中 (需域名/证书)</td>\n<td>低到中</td>\n<td>中</td>\n<td>中</td>\n</tr>\n<tr>\n<td><strong>核心优势</strong></td>\n<td>Reality 带来的高隐蔽性</td>\n<td>强大的 HTTPS 模仿能力</td>\n<td>简洁, 广泛支持</td>\n<td>恶劣网络下的高吞吐</td>\n<td>低握手延迟, 0-RTT 选项</td>\n</tr>\n<tr>\n<td><strong>主要劣势</strong></td>\n<td>Reality 配置可能较复杂</td>\n<td>域名/证书管理</td>\n<td>旧版/不当配置易被检测</td>\n<td>UDP 封锁/限速, “明显特征” 30</td>\n<td>UDP 封锁/限速, 0-RTT 风险</td>\n</tr>\n</tbody></table>\n<h2 id=\"第四章：配置您的客户端设备\"><a href=\"#第四章：配置您的客户端设备\" class=\"headerlink\" title=\"第四章：配置您的客户端设备\"></a>第四章：配置您的客户端设备</h2><p>成功搭建 sing-box 服务器后，下一步是在您的设备上配置客户端以连接并使用该服务。</p>\n<h3 id=\"4-1-Sing-box-客户端通用配置原则\"><a href=\"#4-1-Sing-box-客户端通用配置原则\" class=\"headerlink\" title=\"4.1. Sing-box 客户端通用配置原则\"></a>4.1. Sing-box 客户端通用配置原则</h3><p>无论是使用 sing-box 命令行作为客户端，还是使用图形化客户端，其核心配置逻辑是相似的：客户端的 <code>outbounds</code>（出站）设置必须与服务器端的 <code>inbounds</code>（入站）设置相匹配。</p>\n<p>关键匹配参数包括：</p>\n<ul>\n<li><strong>服务器地址 (server) 和端口 (server_port):</strong> 客户端必须正确指向服务器的 IP 地址或域名，以及服务器上相应协议监听的端口。</li>\n<li><strong>用户凭证 (UUID/password):</strong> 对于需要认证的协议（如 VLESS, Trojan, Shadowsocks, Hysteria2, TUIC），客户端配置的 UUID 或密码必须与服务器端为该用户设定的凭证完全一致。</li>\n<li><strong>加密方法 (method/security):</strong> 客户端选择的加密算法必须是服务器端支持并为该用户启用的。</li>\n<li><strong>传输设置 (transport):</strong> 如果服务器端使用了特定的传输方式（如 WebSocket 的路径 <code>path</code>，gRPC 的服务名 <code>serviceName</code>），客户端必须进行相应的配置。</li>\n<li>TLS 设置 (tls):<ul>\n<li><strong>SNI (Server Name Indication):</strong> 对于使用 TLS 的协议，客户端配置的 <code>server_name</code> (SNI) 通常需要与服务器证书的域名或 Reality/Trojan 等协议期望的 SNI 一致。</li>\n<li><strong>证书验证:</strong> 客户端默认会验证服务器证书的有效性。如果服务器使用自签名证书，客户端需要配置信任该证书或（在了解风险的前提下）设置为不安全连接 (<code>insecure: true</code>)。</li>\n<li><strong>Reality/uTLS:</strong> 如果服务器端配置了 Reality，客户端必须配置对应的 <code>public_key</code> 和 <code>short_id</code>。使用 <code>utls</code> 模拟浏览器指纹可以增强伪装性。</li>\n</ul>\n</li>\n<li><strong>协议类型 (type):</strong> 客户端 <code>outbounds</code> 中的 <code>type</code> 字段必须与服务器端 <code>inbounds</code> 中配置的协议类型相对应。</li>\n</ul>\n<h3 id=\"4-2-使用-Sing-box-命令行作为客户端-适用于高级用户或连接其他服务器\"><a href=\"#4-2-使用-Sing-box-命令行作为客户端-适用于高级用户或连接其他服务器\" class=\"headerlink\" title=\"4.2. 使用 Sing-box 命令行作为客户端 (适用于高级用户或连接其他服务器)\"></a>4.2. 使用 Sing-box 命令行作为客户端 (适用于高级用户或连接其他服务器)</h3><p>对于高级用户，或者当您希望将一台设备（如另一台服务器或本地 Linux/macOS 机器）作为连接到主 sing-box 服务器的客户端时，可以直接使用 sing-box 命令行程序。</p>\n<p>以下是一个最小化的客户端 <code>config.json</code> 示例，它包含日志、DNS、一个连接到 VLESS+Reality 服务器的出站，以及一个本地 SOCKS5 入站，允许本机其他应用程序通过此 sing-box 客户端进行代理：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"log\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"level\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"info\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 日志级别，可根据需要调整为 \"debug\" 获取更详细信息</span>\n    <span class=\"token property\">\"timestamp\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"dns\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"servers\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"final\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"dns-remote\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 默认所有 DNS 查询走 \"dns-remote\"</span>\n    <span class=\"token property\">\"strategy\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ipv4_only\"</span> <span class=\"token comment\">// DNS 解析策略，可按需选择</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"inbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"route\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"rules\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"outbound\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"direct\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// { \"geosite\": \"category-ads-all\", \"outbound\": \"block\" }</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"final\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"proxy\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 默认情况下，所有其他流量都通过名为 \"proxy\" 的出站</span>\n    <span class=\"token property\">\"auto_detect_interface\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// 自动检测出口网络接口，某些情况下需要</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将上述配置保存为 <code>client_config.json</code>，然后通过 <code>sing-box run -c client_config.json</code> 运行。之后，将需要代理的应用程序的 SOCKS5 代理设置为 <code>127.0.0.1:1080</code> 即可。</p>\n<h3 id=\"4-3-主流图形化客户端-GUI-概览\"><a href=\"#4-3-主流图形化客户端-GUI-概览\" class=\"headerlink\" title=\"4.3. 主流图形化客户端 (GUI) 概览\"></a>4.3. 主流图形化客户端 (GUI) 概览</h3><p>对于不习惯命令行的用户，或者希望在日常设备上便捷使用代理，可以选择各种支持 sing-box 内核或其协议的图形化客户端。</p>\n<ul>\n<li><strong>桌面端 (Windows/macOS/Linux):</strong><ul>\n<li><strong>GUI.for.SingBox (下一代 Clash Verge):</strong> 这是一款专为 sing-box 设计的图形化配置和管理工具，支持通过 GUI 创建和调整配置，管理配置文件（Profiles），最终生成 sing-box 可用的 <code>config.json</code> 。</li>\n<li><strong>Nekoray / NekoBox:</strong> 广受欢迎的多协议客户端，支持 sing-box、Xray、Clash 等多种核心，界面友好，易于上手 。</li>\n<li><strong>Hiddify-Next:</strong> 另一款支持多种协议和 sing-box 的第三方 GUI 客户端 。</li>\n<li><strong>Clash Verge:</strong> 主要为 Clash 核心设计，但由于其配置范式与 sing-box 有相似之处，且社区活跃，部分衍生项目或新版本可能增强对 sing-box 的兼容性或提供类似体验 。</li>\n</ul>\n</li>\n<li><strong>移动端:</strong><ul>\n<li>Android:<ul>\n<li><strong>Sing-box for Android (官方):</strong> 由 SagerNet 开发的官方 Android 客户端，功能全面，紧跟 sing-box 内核更新 。</li>\n<li><strong>SagerNet:</strong> 也是 SagerNet 开发的一款支持多种协议（包括 sing-box 协议）的客户端 。</li>\n<li><strong>NekoBox for Android:</strong> Nekoray 的 Android 版本，同样支持 sing-box 。</li>\n</ul>\n</li>\n<li>iOS:<ul>\n<li><strong>Sing-box for Apple (官方):</strong> 官方 iOS 客户端，提供原生体验 。</li>\n<li><strong>Shadowrocket (“小火箭”):</strong> 老牌且功能强大的 iOS 网络工具，支持包括 Trojan, VLESS, Shadowsocks, Hysteria2, TUIC 在内的多种 sing-box 兼容协议 。</li>\n<li><strong>Stash:</strong> 另一款流行的 iOS 代理客户端，以其强大的规则引擎和 sing-box 协议支持闻名 。</li>\n<li><strong>Egern:</strong> 支持多种协议，包括 sing-box 的主流协议 。</li>\n<li><strong>FoXray:</strong> 也被推荐用于 iOS 设备，支持 VLESS 等协议 。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>大多数图形化客户端都支持通过订阅链接（机场服务商提供）自动更新节点信息和配置，或者允许用户手动导入 sing-box 的 JSON 配置文件、单个节点的分享链接或扫描二维码添加节点 。</p>\n<p>近年来，通用型图形化客户端的兴起极大地简化了用户在多协议环境下的使用体验。诸如 Nekoray、GUI.for.SingBox、Hiddify 以及移动端的官方 sing-box 应用、Shadowrocket、Stash 等客户端，其设计目标就是兼容多种代理核心（如 sing-box, Clash, Xray）或 sing-box 所支持的广泛协议集 。这种趋势的背后，是用户往往拥有运行不同协议的服务器，或者需要根据网络状况和特定需求灵活切换协议。为每种协议维护独立的客户端应用显然十分繁琐。通用客户端通过提供统一的用户界面，简化了配置管理（通常通过配置文件或订阅链接实现）和代理切换的流程。Sing-box 作为库或核心的能力 ，也为其被集成到这些第三方 GUI 客户端提供了便利。这意味着用户不再被束缚于单一协议的特定客户端，而是可以选择功能丰富、支持 sing-box 的图形化工具，从而更便捷地管理和使用其“科学上网”服务。</p>\n<h2 id=\"第五章：增强您的配置-高级技巧\"><a href=\"#第五章：增强您的配置-高级技巧\" class=\"headerlink\" title=\"第五章：增强您的配置 (高级技巧)\"></a>第五章：增强您的配置 (高级技巧)</h2><p>在掌握了 sing-box 的基本安装和协议配置之后，可以进一步探索一些高级技巧，以增强代理服务的隐蔽性、稳定性和灵活性。</p>\n<h3 id=\"5-1-使用-CDN-隐藏服务器-IP-例如-Cloudflare\"><a href=\"#5-1-使用-CDN-隐藏服务器-IP-例如-Cloudflare\" class=\"headerlink\" title=\"5.1. 使用 CDN 隐藏服务器 IP (例如 Cloudflare)\"></a>5.1. 使用 CDN 隐藏服务器 IP (例如 Cloudflare)</h3><ul>\n<li><p><strong>核心概念:</strong> 将代理服务器的流量通过内容分发网络 (CDN) 如 Cloudflare 进行中转，可以有效隐藏真实服务器的 IP 地址。这使得即使代理服务器的 IP 被直接探测或封锁，只要 CDN 节点可用，服务依然能够访问，从而提高了抗封锁能力 。</p>\n</li>\n<li><p><strong>工作原理:</strong></p>\n<ol>\n<li>将您的域名解析指向 Cloudflare 的服务器（在 Cloudflare DNS 设置中开启橙色云朵代理）。</li>\n<li>Sing-box 服务器配置为监听来自 Cloudflare IP 段的流量。</li>\n<li>客户端连接您的域名（实际上是连接到离客户端最近的 Cloudflare 边缘节点）。</li>\n<li>Cloudflare 接收到流量后，再将其转发到您的源代理服务器。</li>\n</ol>\n</li>\n<li><p><strong>必要条件:</strong></p>\n<ul>\n<li>一个您拥有的域名。</li>\n<li>一个 Cloudflare 账户（免费套餐通常已足够）。</li>\n<li>选择能够被 CDN 可靠代理的协议和传输方式。通常是基于 WebSocket (WS) 并通过 TLS 加密（通常在 443 端口）的协议，例如 Trojan + WS 或 VLESS + WS 。</li>\n</ul>\n</li>\n<li><p>Sing-box 配置示例 (客户端 Trojan + WS over CDN):</p>\n<p>服务器端需要配置相应的 Trojan + WebSocket 入站。客户端出站配置如下：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>注意：这里的 <code>server</code> 字段直接使用您的域名，因为 Cloudflare 会处理 IP 解析和转发。</p>\n</li>\n<li><p><strong>服务器端注意事项:</strong></p>\n<ul>\n<li>服务器上的 sing-box 需配置为监听 WebSocket 流量，并使用与客户端一致的路径。</li>\n<li>在 Cloudflare 的 DNS 设置中，确保对应域名的代理状态（橙色云朵）已开启。</li>\n<li>Cloudflare 的 SSL/TLS 加密模式建议设置为“完全”或“完全（严格）”，以确保从客户端到 Cloudflare 以及从 Cloudflare 到源服务器的全程加密。</li>\n</ul>\n</li>\n<li><p><strong>益处:</strong></p>\n<ul>\n<li>显著提高抵抗 IP 直接封锁的能力。</li>\n<li>CDN 的全球节点分布可能（但不一定）为部分用户带来访问延迟的改善（对于动态代理流量，CDN 缓存效果有限，但其路由优化仍有一定作用）。</li>\n</ul>\n</li>\n</ul>\n<p>将 CDN 置于代理服务器之前，相当于引入了一个广受信赖的中间层 。这种做法通常与 WebSocket 等能封装在标准 HTTP/HTTPS 请求中的传输协议配合使用。直接连接代理服务器 IP 的方式，一旦该 IP 地址被标记并封锁，服务即告中断。而 CDN 服务商（如 Cloudflare）拥有海量的 IP 地址资源，这些 IP 被大量合法网站共享。大规模封锁这些共享 IP 会造成巨大的“附带伤害”，审查机构对此通常较为谨慎。通过 CDN 传输的、使用 WebSocket 并以 TLS 加密的流量（尤其是在 443 端口），其外观与普通网站的 HTTPS 流量极为相似。CDN 在其边缘节点处理 TLS 握手，然后将流量（可能重新加密）转发至源服务器。这种方式不仅隐藏了真实服务器的 IP，还使得代理流量能够混入海量的、通过 CDN 的合法 HTTPS 流量之中，从而显著提升了抗审查的持久性。这对于在严格审查环境下维持代理服务的长期可用性是一项关键技术。</p>\n<h3 id=\"5-2-Sing-box-基础路由：智能分流流量\"><a href=\"#5-2-Sing-box-基础路由：智能分流流量\" class=\"headerlink\" title=\"5.2. Sing-box 基础路由：智能分流流量\"></a>5.2. Sing-box 基础路由：智能分流流量</h3><p>Sing-box 强大的路由功能允许用户根据多种条件精细控制流量走向，实现国内外分流、广告屏蔽、特定服务加速等目的。路由配置在 <code>config.json</code> 文件的 <code>route</code> 块中定义 。</p>\n<ul>\n<li><p><strong>常用规则类型:</strong></p>\n<ul>\n<li><strong>域名匹配:</strong> <code>domain</code> (精确匹配), <code>domain_suffix</code> (域名后缀匹配，如 <code>google.com</code>), <code>domain_keyword</code> (域名关键词匹配)。</li>\n<li><strong>IP 匹配:</strong> <code>ip_cidr</code> (IP 地址段匹配), <code>geoip</code> (基于 IP 的地理位置，如 <code>geoip:cn</code> 匹配中国大陆 IP) 。</li>\n<li><strong>预设网站列表:</strong> <code>geosite</code> (匹配预定义的网站分类，如 <code>geosite:google</code> 匹配谷歌相关服务) 。</li>\n<li><strong>协议类型:</strong> <code>protocol</code> (如 <code>dns</code> 专门匹配 DNS 查询流量) 。</li>\n<li><strong>端口:</strong> <code>port</code> (匹配目标端口)。</li>\n<li><strong>进程名/包名 (客户端):</strong> <code>process_name</code> (Windows/Linux 进程名) 或 <code>package_name</code> (Android 应用包名)。</li>\n</ul>\n</li>\n<li><p><strong>简单分流示例 (国内直连，国外代理):</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"route\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"rules\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"final\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"proxy\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 所有未匹配上述规则的流量，默认通过名为 \"proxy\" 的出站 (即您的主代理出站)</span>\n    <span class=\"token property\">\"auto_detect_interface\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// 建议开启，自动检测网络接口</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>规则集 (<code>rule_set</code>):</strong> 为了方便管理大量的域名或 IP 列表，可以使用 <code>rule_set</code> 功能，引用预先编译好的规则文件（通常是 <code>.srs</code> 或 <code>.db</code> 格式）。这些规则集可以从远程 URL 下载更新。</p>\n</li>\n</ul>\n<h3 id=\"5-3-实现故障转移与基础负载均衡-URLTest-和-Selector\"><a href=\"#5-3-实现故障转移与基础负载均衡-URLTest-和-Selector\" class=\"headerlink\" title=\"5.3. 实现故障转移与基础负载均衡 (URLTest 和 Selector)\"></a>5.3. 实现故障转移与基础负载均衡 (URLTest 和 Selector)</h3><p>为了提高代理连接的稳定性和可用性，sing-box 提供了 <code>URLTest</code> 和 <code>Selector</code> 两种特殊的出站类型。</p>\n<ul>\n<li><p><strong>URLTest 出站 (自动选择最佳节点):</strong></p>\n<ul>\n<li><p><strong>用途:</strong> <code>URLTest</code> 会定期测试一组预定义的出站代理节点，并自动选择其中延迟最低（或最先成功响应）的节点作为当前使用的出站9。这主要用于实现故障自动切换 (failover) 和基于延迟的简单负载均衡。</p>\n</li>\n<li><p>关键字段:</p>\n<ul>\n<li><code>outbounds</code>: 一个包含多个代理出站标签（tag）的列表，<code>URLTest</code> 将对这些出站进行测试。</li>\n<li><code>url</code>: 用于测试的 URL，例如 <code>http://www.gstatic.com/generate_204</code> (谷歌提供的用于测试网络连通性的 URL，返回 HTTP 204 No Content)。如果为空，sing-box 有默认测试地址。</li>\n<li><code>interval</code>: 测试间隔时间，例如 <code>\"5m\"</code> 表示每 5 分钟测试一次。</li>\n<li><code>tolerance</code>: 延迟容忍度（毫秒），用于判断节点是否可用或切换的阈值。</li>\n</ul>\n</li>\n<li><p>示例:</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"outbounds\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 参与测试的代理出站标签列表</span>\n      <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://www.gstatic.com/generate_204\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"interval\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"5m\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 每5分钟测试一次</span>\n      <span class=\"token property\">\"tolerance\"</span><span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token comment\">// 延迟容忍度 100ms</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后，在路由规则中（例如 route.final）使用 “auto-proxy-selector”作为出站。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Selector 出站 (手动选择节点):</strong></p>\n<ul>\n<li><p><strong>用途:</strong> <code>Selector</code> 允许用户从一个预定义的出站列表中手动选择一个当前使用的出站。这种选择通常通过外部 API (例如 sing-box 的 Clash API 兼容接口) 进行控制，图形化客户端常利用此功能提供节点切换界面 。</p>\n</li>\n<li><p>关键字段:</p>\n<ul>\n<li><code>outbounds</code>: 一个包含多个出站标签（可以是具体代理，也可以是 <code>direct</code> 或其他 <code>URLTest</code> 组）的列表。</li>\n<li><code>default</code>: 默认选中的出站标签。</li>\n</ul>\n</li>\n<li><p>示例:</p>\n<pre class=\"line-numbers language-JSON\" data-language=\"JSON\"><code class=\"language-JSON\">{\n  \"outbounds\":, // 可供选择的出站列表\n      \"default\": \"proxy-vless\" // 默认选择 \"proxy-vless\"\n    }\n  ]\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同样，可以在路由规则中使用 “manual-proxy-selector”。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>URLTest</code> 和 <code>Selector</code> 为 sing-box 提供了强大的流量管理能力。<code>URLTest</code> 通过自动化的健康检查和延迟测试 ，确保了连接的韧性：当某个代理节点失效或表现不佳时，它能自动切换到其他可用节点，从而在无需用户干预的情况下维持“科学上网”的通畅。这对于故障转移至关重要。另一方面，<code>Selector</code> 则赋予用户明确的控制权 ，允许用户根据特定需求（如访问特定区域的地理限制内容，或临时切换到直连）主动选择出口。Clash API 的支持使得图形化客户端能够方便地集成这种手动选择功能。实际应用中，一种常见的模式是将多个 <code>URLTest</code> 分组（例如，一组美国服务器，一组日本服务器），然后使用一个 <code>Selector</code> 在这些分组或单个优质代理之间进行选择。这种组合既满足了自动化故障恢复的需求，也兼顾了用户的主动偏好。</p>\n<h2 id=\"第六章：故障排除与日常维护\"><a href=\"#第六章：故障排除与日常维护\" class=\"headerlink\" title=\"第六章：故障排除与日常维护\"></a>第六章：故障排除与日常维护</h2><p>即使配置无误，有时也可能遇到连接问题。了解如何排查故障和进行日常维护，是确保代理服务长期稳定运行的关键。</p>\n<h3 id=\"6-1-“芝麻开门”：通过-Sing-box-日志寻找线索\"><a href=\"#6-1-“芝麻开门”：通过-Sing-box-日志寻找线索\" class=\"headerlink\" title=\"6.1. “芝麻开门”：通过 Sing-box 日志寻找线索\"></a>6.1. “芝麻开门”：通过 Sing-box 日志寻找线索</h3><p>日志是排查问题的第一手资料。当遇到连接失败、速度缓慢或其他异常行为时，首先应该查看 sing-box 的日志。</p>\n<ul>\n<li><p><strong>服务器端日志:</strong> 如果 sing-box 作为系统服务运行 (通过 <code>systemd</code> 管理)，可以使用以下命令查看实时日志：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sudo journalctl -u sing-box -f --output cat<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果直接通过 sing-box run 命令在前台运行，日志会直接输出到终端，或者根据 config.json 中 log.output 的设置输出到指定文件。</p>\n</li>\n<li><p><strong>客户端日志:</strong></p>\n<ul>\n<li>如果使用 sing-box 命令行作为客户端，日志同样会输出到终端或配置文件中指定的位置。</li>\n<li>图形化客户端通常内置了日志查看器，方便用户查阅。</li>\n</ul>\n</li>\n<li><p><strong>关注日志中的关键信息:</strong></p>\n<ul>\n<li><strong>错误信息 (Error messages):</strong> 明确指示问题的发生，如连接超时、认证失败、证书错误等。</li>\n<li><strong>警告信息 (Warning messages):</strong> 可能提示潜在问题或配置不当。</li>\n<li><strong>连接尝试与结果:</strong> 可以看到客户端的连接请求、使用的协议、目标地址等。</li>\n<li><strong>路由决策:</strong> 对于复杂的路由配置，日志可以显示流量是如何根据规则被导向特定出站的。</li>\n<li><strong>日志级别 (<code>log.level</code>):</strong> 在 <code>config.json</code> 中，可以将 <code>log.level</code> 设置为 <code>\"debug\"</code> 甚至 <code>\"trace\"</code> 以获取更详细的诊断信息，但在正常运行时建议使用 <code>\"info\"</code> 或 <code>\"warn\"</code> 以避免日志过于庞大 。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-2-配置检查：使用-sing-box-check-进行预检\"><a href=\"#6-2-配置检查：使用-sing-box-check-进行预检\" class=\"headerlink\" title=\"6.2. 配置检查：使用 sing-box check 进行预检\"></a>6.2. 配置检查：使用 <code>sing-box check</code> 进行预检</h3><p>在修改 <code>config.json</code> 文件后，启动或重启 sing-box 服务之前，务必使用 <code>sing-box check</code> 命令校验配置文件的有效性：</p>\n<pre class=\"line-numbers language-Bash\" data-language=\"Bash\"><code class=\"language-Bash\">sing-box check -c /path/to/your/config.json<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>该命令会检查 JSON 语法是否正确、字段名和值是否符合 sing-box 的规范。</p>\n<p><code>sing-box check</code> 命令是配置管理流程中不可或缺的“预飞检查”环节 。JSON 格式对逗号、括号、引号等符号要求严格，而 sing-box 的配置项众多且可能存在嵌套，手动编辑时很容易出现笔误或使用了不正确的字段名。如果直接运行一个有错误的配置文件，可能导致 sing-box 服务启动失败、意外崩溃或行为异常。例如，某些 GitHub issue 中报告的崩溃问题，部分可能源于配置不当（提到的一个与 tun 配置相关的崩溃，如果涉及到需要 root 权限的资源访问，<code>check</code> 命令在尝试校验时或许能提前发现权限问题或配置冲突）。因此，在每次修改配置文件后、重启服务前，执行 <code>sing-box check</code>，可以及时发现并修正这些低级错误，从而节省大量的排错时间和避免不必要的服务中断。</p>\n<h3 id=\"6-3-常见连接问题及其解决方案\"><a href=\"#6-3-常见连接问题及其解决方案\" class=\"headerlink\" title=\"6.3. 常见连接问题及其解决方案\"></a>6.3. 常见连接问题及其解决方案</h3><ul>\n<li><strong>防火墙阻挡端口:</strong><ul>\n<li><strong>症状:</strong> 客户端无法连接到服务器的指定端口。</li>\n<li><strong>排查:</strong> 仔细检查服务器的防火墙规则 (UFW, firewalld)，确保已为 sing-box 使用的协议和端口正确开放了 TCP 和/或 UDP 流量。</li>\n</ul>\n</li>\n<li><strong>客户端配置错误:</strong><ul>\n<li><strong>症状:</strong> 连接失败，日志提示认证错误、地址错误等。</li>\n<li><strong>排查:</strong> 逐项核对客户端配置中的服务器地址、端口、用户ID (UUID)、密码、加密方法、传输参数（如 WebSocket 路径）、TLS SNI 等，确保与服务器端的入站配置完全一致。</li>\n</ul>\n</li>\n<li><strong>TLS 相关错误 (适用于 VLESS, Trojan, Hysteria2, TUIC 等):</strong><ul>\n<li><strong>SNI 不匹配:</strong> 客户端 <code>tls.server_name</code> 与服务器证书或 Reality/Trojan 期望的 SNI 不符。</li>\n<li><strong>服务器证书无效/过期:</strong> 检查服务器证书状态，及时续签或修复。</li>\n<li><strong>客户端无法验证服务器证书:</strong> 如果服务器使用自签名证书，客户端需要导入该证书或（不推荐，但可用于测试）设置 <code>insecure: true</code>。对于 Reality，确保客户端的 <code>tls.server_name</code> 与服务器 <code>reality.handshake.server</code> 一致。</li>\n</ul>\n</li>\n<li><strong>DNS 解析问题:</strong><ul>\n<li><strong>症状:</strong> 可以连接代理，但无法访问网站，或特定网站无法打开。</li>\n<li>排查:<ul>\n<li>检查客户端和服务器 <code>dns</code> 配置块。</li>\n<li>确保代理服务器自身能够正常解析外部域名（可在服务器上用 <code>ping</code> 或 <code>nslookup</code> 测试）。</li>\n<li>客户端 DNS 是否正确通过代理或指定 DNS 服务器解析，避免 DNS 泄露。</li>\n<li>因 IPv6 偏好设置导致的 DNS 解析问题，提示注意 DNS 策略配置。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Reality 握手失败:</strong><ul>\n<li><strong>症状:</strong> VLESS+Reality 连接失败。</li>\n<li><strong>排查:</strong> 确认客户端的 <code>public_key</code>、<code>short_id</code> 与服务器端的 <code>private_key</code>、<code>short_id</code> 对应且正确。确认客户端 <code>tls.server_name</code> 与服务器端 <code>reality.handshake.server</code> 配置的域名一致。检查伪装的目标网站 (<code>reality.handshake.server</code>) 是否可访问且其 TLS 证书有效。</li>\n</ul>\n</li>\n<li><strong>网络不可达 (“network is unreachable”):</strong><ul>\n<li><strong>症状:</strong> 日志中出现此类错误。</li>\n<li><strong>排查:</strong> 服务器可能已宕机，服务器 IP 可能被 ISP 封锁，或者存在网络路由问题。检查服务器状态和网络连通性 。</li>\n</ul>\n</li>\n<li><strong>时间同步问题:</strong><ul>\n<li><strong>症状:</strong> 某些协议（特别是依赖 TLS 和证书的）连接失败。</li>\n<li><strong>排查:</strong> 确保客户端和服务器的时间基本同步。在服务器上配置并启用 NTP 服务（sing-box 配置中也有 <code>ntp</code> 模块）。</li>\n</ul>\n</li>\n<li><strong>服务器资源耗尽:</strong><ul>\n<li><strong>症状:</strong> 连接不稳定，速度极慢，服务频繁重启。</li>\n<li><strong>排查:</strong> 登录服务器检查 CPU、内存、带宽使用情况。如果资源不足，考虑升级 VPS 配置或优化 sing-box 配置（如限制并发连接数）。</li>\n</ul>\n</li>\n<li><strong>Sing-box 进程崩溃 (panic):</strong><ul>\n<li><strong>症状:</strong> 服务意外停止，日志中出现 <code>panic:</code> 开头的错误信息和堆栈跟踪。</li>\n<li><strong>排查:</strong> <code>panic</code> 通常指示程序内部错误（bug）、不兼容的配置、或严重的资源问题 24。仔细阅读 <code>panic</code> 信息和相关的上下文日志。如果怀疑是 sing-box 的 bug，可以附上详细的日志、可复现的配置和操作步骤，到 sing-box 的 GitHub Issues 页面报告。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-4-保持更新：维护-Sing-box-及配置的有效性\"><a href=\"#6-4-保持更新：维护-Sing-box-及配置的有效性\" class=\"headerlink\" title=\"6.4. 保持更新：维护 Sing-box 及配置的有效性\"></a>6.4. 保持更新：维护 Sing-box 及配置的有效性</h3><p>网络审查技术和代理协议本身都在不断发展和演变。为了保持代理服务的有效性和安全性，需要进行持续的维护：</p>\n<ul>\n<li><strong>定期更新 Sing-box:</strong> 关注 SagerNet/sing-box 的 GitHub Releases 页面，及时将 sing-box 程序更新到最新的稳定版本。新版本通常包含 bug 修复、性能优化、安全更新以及对新特性或协议的支持。可以通过重新运行安装脚本或使用系统的包管理器进行更新。</li>\n<li><strong>关注社区动态:</strong> 留意 sing-box 的 GitHub Issues 、官方文档更新以及相关的技术社区和论坛。这些渠道通常会讨论最新的审查手段、协议的有效性变化以及新的规避策略。</li>\n<li><strong>更新路由规则集:</strong> 如果在路由配置中使用了 GeoIP、Geosite 等远程规则集，应确保这些规则集能够定期更新，以保证分流的准确性。部分客户端或辅助工具可能提供自动更新规则集的功能 。</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>Sing-box 作为一个强大且灵活的通用代理平台，为用户提供了构建自定义“科学上网”节点的坚实基础。通过本教程的指引，用户应能掌握从服务器准备、sing-box 安装、核心协议配置到客户端设置的完整流程。无论是追求极致隐蔽性的 VLESS+Reality、模仿 HTTPS 的 Trojan，还是经典高效的 Shadowsocks，亦或是面向特定网络优化的 Hysteria2 和 TUIC，sing-box 都能提供良好的支持。</p>\n<p>然而，需要强调的是，网络审查与规避技术之间的博弈是一个持续动态的过程。今天有效的协议或配置，明天可能就会面临新的挑战。因此，保持学习的热情，关注技术前沿，并根据实际情况灵活调整策略，是确保长期顺畅访问互联网的关键。</p>\n<p>最后，请负责任地使用本教程提供的知识和工具，遵守当地法律法规，并将其用于促进信息自由交流和个人学习研究等正当目的。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"A-1-Sing-box-常用命令行-CLI-命令参考\"><a href=\"#A-1-Sing-box-常用命令行-CLI-命令参考\" class=\"headerlink\" title=\"A.1. Sing-box 常用命令行 (CLI) 命令参考\"></a>A.1. Sing-box 常用命令行 (CLI) 命令参考</h3><p>尽管 sing-box 的命令行参数和子命令的官方集中文档尚不完善，但通过分析其源码、社区讨论和实际使用，可以总结出以下常用命令：</p>\n<ul>\n<li><p><strong>核心操作:</strong></p>\n<ul>\n<li><pre><code>sing-box run [options]\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n  : 运行 sing-box 实例。\n\n  - `-c, --config &lt;path&gt;`: 指定一个或多个配置文件路径（JSON 或 SJSON 格式）。可以指定目录，sing-box 会加载目录内所有 `.json` 文件 22。\n  - `-D, --directory &lt;path&gt;`: 指定配置文件目录，与 `-c` 配合使用。\n  - `--disable-color`: 禁用彩色日志输出。\n\n- ```\n  sing-box check [options]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n: 检查配置文件的有效性。\n\n- `-c, --config &lt;path&gt;`: 同 `run` 命令。\n- `-D, --directory &lt;path&gt;`: 同 `run` 命令。\n- `--format`: 检查后自动格式化配置文件。\n</code></pre>\n</li>\n<li><pre><code>sing-box format [options]\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n  : 格式化（美化）配置文件。\n\n  - `-c, --config &lt;path&gt;`: 指定输入配置文件。\n  - `-D, --directory &lt;path&gt;`: 指定配置文件目录。\n  - `-w, --write`: 将格式化后的内容写回原文件 5。\n  - `-o, --output &lt;path&gt;`: 将格式化后的内容输出到指定文件。\n\n- ```\n  sing-box version<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n: 显示版本信息，包括构建标签 。\n\n\n\n- `-n, --name`: 只显示版本名称。\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>密钥生成:</strong></p>\n<ul>\n<li><code>sing-box generate uuid</code>: 生成一个 UUID 11。</li>\n<li><code>sing-box generate reality-keypair</code>: 生成 Reality 公私钥对 11。</li>\n<li><code>sing-box generate rand &lt;length&gt;</code>: 生成指定长度的随机字符串（可用于密码）。</li>\n</ul>\n</li>\n<li><p><strong>其他 (可能存在或特定构建中包含):</strong></p>\n<ul>\n<li><code>sing-box geoip export &lt;path&gt;</code>: 导出 GeoIP 数据。</li>\n<li><code>sing-box geosite export &lt;path&gt;</code>: 导出 Geosite 数据。</li>\n<li><code>sing-box rule-set compile</code>: 编译规则集。</li>\n<li><code>sing-box rule-set merge</code>: 合并规则集。</li>\n</ul>\n</li>\n<li><p><strong>通过 <code>systemd</code> 进行服务管理 (Linux):</strong></p>\n<ul>\n<li><code>sudo systemctl start sing-box</code></li>\n<li><code>sudo systemctl stop sing-box</code></li>\n<li><code>sudo systemctl restart sing-box</code></li>\n<li><code>sudo systemctl enable sing-box</code></li>\n<li><code>sudo systemctl disable sing-box</code></li>\n<li><code>sudo systemctl status sing-box</code></li>\n<li><code>sudo journalctl -u sing-box -f --output cat</code> 11</li>\n</ul>\n</li>\n</ul>\n<p>目前关于 sing-box 命令行工具的详细信息较为分散，可见于 GitHub issue 讨论 24、博客文章 19、官方文档的特定子页面 5 以及 Go 语言的源代码文件 22。尚无一个统一、详尽的“man page”式参考手册。上述列表整合了目前已知的主要命令及其功能，对于习惯使用命令行的用户而言，这是一个实用的快速参考。最准确和完整的参数列表，理论上可以通过 <code>sing-box --help</code> 或 <code>sing-box &lt;subcommand&gt; --help</code> 获取，但具体输出内容未在本次研究资料中直接提供。</p>\n<h3 id=\"A-2-关键术语解释\"><a href=\"#A-2-关键术语解释\" class=\"headerlink\" title=\"A.2. 关键术语解释\"></a>A.2. 关键术语解释</h3><ul>\n<li><strong>CDN (Content Delivery Network, 内容分发网络):</strong> 一组分布在不同地理位置的服务器，用于缓存和加速网站内容的传递。在代理场景中，可用于隐藏源服务器 IP。</li>\n<li><strong>DPI (Deep Packet Inspection, 深度包检测):</strong> 一种网络数据包过滤技术，通过检查数据包的内容来识别协议类型、应用或特定数据模式，常用于网络审查。</li>\n<li><strong>GFW (Great Firewall, 防火长城):</strong> 指中国大陆用于互联网审查和内容过滤的一系列技术和行政手段的俗称。</li>\n<li><strong>GeoIP:</strong> 基于 IP 地址确定其地理位置的技术或数据库。</li>\n<li><strong>Geosite:</strong> 预定义的网站域名分类列表，常用于路由规则中对特定类型的网站进行分流。</li>\n<li><strong>Inbound (入站):</strong> Sing-box 中处理传入连接的配置模块。</li>\n<li><strong>Outbound (出站):</strong> Sing-box 中处理传出连接的配置模块。</li>\n<li><strong>Multiplexing (多路复用):</strong> 在单个网络连接（通常是 TCP 连接）上承载多个独立的逻辑数据流的技术，可以提高连接效率和并发性能。</li>\n<li><strong>QUIC (Quick UDP Internet Connections):</strong> 一种基于 UDP 的新型传输层网络协议，旨在提供比 TCP 更低的延迟和更好的拥塞控制，是 HTTP/3 的基础。</li>\n<li><strong>Reality:</strong> 一种 VLESS 协议的扩展，通过模拟真实网站的 TLS 握手来增强代理服务器的隐蔽性，抵抗主动探测。</li>\n<li><strong>SNI (Server Name Indication):</strong> TLS 协议的一个扩展，允许客户端在 TLS 握手初期就告知服务器其希望连接的域名，使得同一 IP 地址可以托管多个 HTTPS 网站。</li>\n<li><strong>TLS (Transport Layer Security, 传输层安全协议):</strong> 用于在两个通信应用程序之间提供私密性和数据完整性的加密协议，是 HTTPS 的基础。</li>\n<li><strong>UDP (User Datagram Protocol, 用户数据报协议):</strong> 一种无连接的传输层协议，提供快速但不可靠的数据传输。</li>\n<li><strong>UUID (Universally Unique Identifier, 通用唯一识别码):</strong> 一个128位的数字，用于在计算机系统中唯一地标识信息。在代理协议中常用作用户ID。</li>\n<li><strong>WebSocket (WS):</strong> 一种在单个 TCP 连接上进行全双工通信的协议，常用于 Web 应用。在代理中，可将流量封装在类似 HTTP 的连接中，便于穿透防火墙或通过 CDN。</li>\n<li><strong>XTLS-Vision:</strong> VLESS 协议的一种流控模式，旨在减少加密开销，提高性能。</li>\n</ul>\n<h3 id=\"A-3-进一步学习资源\"><a href=\"#A-3-进一步学习资源\" class=\"headerlink\" title=\"A.3. 进一步学习资源\"></a>A.3. 进一步学习资源</h3><ul>\n<li><strong>Sing-box 官方文档:</strong> <a href=\"https://sing-box.sagernet.org/\">https://sing-box.sagernet.org/</a> 5</li>\n<li><strong>Sing-box GitHub 仓库:</strong>(<a href=\"https://github.com/SagerNet/sing-box\">https://github.com/SagerNet/sing-box</a>) 7</li>\n<li><strong>GUI.for.SingBox (图形化客户端):</strong>(<a href=\"https://github.com/GUI-for-Cores/GUI.for.SingBox\">https://github.com/GUI-for-Cores/GUI.for.SingBox</a>) 56</li>\n<li><strong>Nekoray / NekoBox (图形化客户端):</strong>(<a href=\"https://github.com/MatsuriDayo/nekoray\">https://github.com/MatsuriDayo/nekoray</a>) (原版，新版可搜索 NekoBox)</li>\n<li><strong>Hiddify-Next (图形化客户端):</strong> <a href=\"https://github.com/hiddify/hiddify-next\">https://github.com/hiddify/hiddify-next</a></li>\n</ul>\n",
            "tags": [
                "教程"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/25/zheng-shu-hou-zhui/",
            "url": "https://0xdadream.github.io/2025/05/25/zheng-shu-hou-zhui/",
            "title": "证书后缀",
            "date_published": "2025-05-25T04:25:00.000Z",
            "content_html": "<h1 id=\"证书后缀\"><a href=\"#证书后缀\" class=\"headerlink\" title=\"证书后缀\"></a>证书后缀</h1><p>我们来详细解释一下 <code>key</code> / <code>crt</code> / <code>pem</code> 之间的关系：</p>\n<hr>\n<h2 id=\"一、三种常见文件类型的说明\"><a href=\"#一、三种常见文件类型的说明\" class=\"headerlink\" title=\"一、三种常见文件类型的说明\"></a>一、三种常见文件类型的说明</h2><table>\n<thead>\n<tr>\n<th>文件名扩展名</th>\n<th>作用</th>\n<th>内容</th>\n<th>是否可以互相转换</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.key</code></td>\n<td><strong>私钥文件</strong></td>\n<td>通常是 RSA 或 ECC 私钥（PEM 格式）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><code>.crt</code></td>\n<td><strong>证书文件</strong></td>\n<td>公钥证书，通常是 PEM 编码的 X.509</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><code>.pem</code></td>\n<td><strong>通用容器格式</strong>（推荐）</td>\n<td>可以包含私钥、证书、CA链等内容</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"二、-pem-是通用格式（包括-key-和-crt）\"><a href=\"#二、-pem-是通用格式（包括-key-和-crt）\" class=\"headerlink\" title=\"二、.pem 是通用格式（包括 .key 和 .crt）\"></a>二、<code>.pem</code> 是通用格式（包括 <code>.key</code> 和 <code>.crt</code>）</h2><p><code>.pem</code>（Privacy-Enhanced Mail）是一种 <strong>Base64 编码的 ASCII 文本格式</strong>，广泛用于存储各种加密材料。</p>\n<p>它的内容可能是：</p>\n<ul>\n<li>只包含私钥（相当于 <code>.key</code>）</li>\n<li>只包含证书（相当于 <code>.crt</code>）</li>\n<li>包含完整的证书链（即 fullchain.pem）</li>\n</ul>\n<h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><h4 id=\"1-私钥-key-key-pem\"><a href=\"#1-私钥-key-key-pem\" class=\"headerlink\" title=\"1. 私钥 .key / key.pem\"></a>1. 私钥 <code>.key</code> / <code>key.pem</code></h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9<span class=\"token punctuation\">..</span>.\n-----END PRIVATE KEY-----<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2-证书-crt-cert-pem\"><a href=\"#2-证书-crt-cert-pem\" class=\"headerlink\" title=\"2. 证书 .crt / cert.pem\"></a>2. 证书 <code>.crt</code> / <code>cert.pem</code></h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">-----BEGIN CERTIFICATE-----\nMIIDdTCCAl2gAwIBAgIJ<span class=\"token punctuation\">..</span>.\n-----END CERTIFICATE-----<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"3-完整链-fullchain-pem\"><a href=\"#3-完整链-fullchain-pem\" class=\"headerlink\" title=\"3. 完整链 .fullchain.pem\"></a>3. 完整链 <code>.fullchain.pem</code></h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">-----BEGIN CERTIFICATE-----   <span class=\"token comment\"># leaf cert</span>\n<span class=\"token punctuation\">..</span>.\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----   <span class=\"token comment\"># intermediate cert</span>\n<span class=\"token punctuation\">..</span>.\n-----END CERTIFICATE-----<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"三、Nginx-Apache-Java-各如何使用\"><a href=\"#三、Nginx-Apache-Java-各如何使用\" class=\"headerlink\" title=\"三、Nginx / Apache / Java 各如何使用\"></a>三、Nginx / Apache / Java 各如何使用</h2><table>\n<thead>\n<tr>\n<th>应用</th>\n<th>需要什么文件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Nginx</strong></td>\n<td><code>ssl_certificate</code> 用 <code>.crt</code> 或 <code>.pem</code>   <code>ssl_certificate_key</code> 用 <code>.key</code> 或 <code>.key.pem</code></td>\n</tr>\n<tr>\n<td><strong>Apache</strong></td>\n<td>类似，支持 <code>.pem</code> 更推荐</td>\n</tr>\n<tr>\n<td><strong>Java keystore</strong></td>\n<td>需要转换成 <code>.p12</code> 或 <code>.jks</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"四、转换方法\"><a href=\"#四、转换方法\" class=\"headerlink\" title=\"四、转换方法\"></a>四、转换方法</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 分离 fullchain.pem 为单独证书和中间证书</span>\nopenssl x509 <span class=\"token parameter variable\">-in</span> fullchain.pem <span class=\"token parameter variable\">-out</span> cert.crt\n\n<span class=\"token comment\"># 转换 PEM -&gt; PFX（含私钥）</span>\nopenssl pkcs12 <span class=\"token parameter variable\">-export</span> <span class=\"token parameter variable\">-out</span> cert.pfx <span class=\"token parameter variable\">-inkey</span> key.pem <span class=\"token parameter variable\">-in</span> fullchain.pem<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><code>.pem</code> 是一种格式，而 <code>.key</code> / <code>.crt</code> 是常见用途的命名方式。</li>\n<li><code>fullchain.pem</code> 包含了完整的证书链。</li>\n<li>所有这些文件 <strong>实际内容可能都是 PEM 格式</strong>，只是用途不同。</li>\n<li>使用时只要指定路径正确、软件支持即可，无论扩展名叫啥。</li>\n</ul>\n",
            "tags": [
                "证书"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/25/sha-si-ju-ti-jin-cheng/",
            "url": "https://0xdadream.github.io/2025/05/25/sha-si-ju-ti-jin-cheng/",
            "title": "杀死具体进程",
            "date_published": "2025-05-25T01:25:00.000Z",
            "content_html": "<h1 id=\"杀死具体进程\"><a href=\"#杀死具体进程\" class=\"headerlink\" title=\"杀死具体进程\"></a>杀死具体进程</h1><p>执行了 <code>systemctl stop httpd</code> 来关闭 <code>httpd</code>（Apache）服务，但仍然看到类似：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">httpd <span class=\"token punctuation\">(</span>pid <span class=\"token number\">1785910</span><span class=\"token punctuation\">)</span> already running<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>表示进程还在运行，说明 <strong><code>httpd</code> 没有被完全停止</strong>。</p>\n<hr>\n<h2 id=\"✅-解决步骤如下：\"><a href=\"#✅-解决步骤如下：\" class=\"headerlink\" title=\"✅ 解决步骤如下：\"></a>✅ 解决步骤如下：</h2><h3 id=\"🔍-第一步：确认并查找-httpd-是否仍有残留进程\"><a href=\"#🔍-第一步：确认并查找-httpd-是否仍有残留进程\" class=\"headerlink\" title=\"🔍 第一步：确认并查找 httpd 是否仍有残留进程\"></a>🔍 第一步：确认并查找 <code>httpd</code> 是否仍有残留进程</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">ps</span> aux <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> httpd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>示例输出：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root     <span class=\"token number\">1785910</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.2</span> <span class=\"token number\">123456</span>  <span class=\"token number\">7890</span> ?        Ss   <span class=\"token number\">12</span>:34   <span class=\"token number\">0</span>:00 /usr/sbin/httpd <span class=\"token parameter variable\">-DFOREGROUND</span>\napache   <span class=\"token number\">1785911</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.1</span> <span class=\"token number\">123456</span>  <span class=\"token number\">4567</span> ?        S    <span class=\"token number\">12</span>:34   <span class=\"token number\">0</span>:00 /usr/sbin/httpd <span class=\"token parameter variable\">-DFOREGROUND</span>\n<span class=\"token punctuation\">..</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"🧨-第二步：强制杀死所有-httpd-相关进程\"><a href=\"#🧨-第二步：强制杀死所有-httpd-相关进程\" class=\"headerlink\" title=\"🧨 第二步：强制杀死所有 httpd 相关进程\"></a>🧨 第二步：强制杀死所有 httpd 相关进程</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">pkill</span> httpd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或者使用 <code>killall</code>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">killall</span> httpd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果仍然存在僵尸进程，可以手动 kill：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">kill</span> <span class=\"token parameter variable\">-9</span> <span class=\"token number\">1785910</span> <span class=\"token number\">1785911</span> <span class=\"token punctuation\">..</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"🔁-第三步：再次确认是否彻底关闭\"><a href=\"#🔁-第三步：再次确认是否彻底关闭\" class=\"headerlink\" title=\"🔁 第三步：再次确认是否彻底关闭\"></a>🔁 第三步：再次确认是否彻底关闭</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">ps</span> aux <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> httpd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果没有输出（或只有 grep 本身），说明服务已完全停止。</p>\n<hr>\n<h3 id=\"🧪-第四步：确认端口是否仍被占用（例如-80-端口）\"><a href=\"#🧪-第四步：确认端口是否仍被占用（例如-80-端口）\" class=\"headerlink\" title=\"🧪 第四步：确认端口是否仍被占用（例如 80 端口）\"></a>🧪 第四步：确认端口是否仍被占用（例如 80 端口）</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">lsof</span> <span class=\"token parameter variable\">-i</span> :80<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果发现仍有服务监听 80 端口，你可以确认是哪个程序占用了：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">netstat</span> <span class=\"token parameter variable\">-tulnp</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> :80<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或者：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ss <span class=\"token parameter variable\">-tulnp</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> :80<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<hr>\n<p>如你希望彻底禁用 <code>httpd</code>，可以执行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl disable httpd\n<span class=\"token function\">sudo</span> systemctl mask httpd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><code>mask</code> 会阻止任何方式启动它，包括依赖项。</p>\n",
            "tags": [
                "命令"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/21/parsec-shi-yong-jiao-cheng/",
            "url": "https://0xdadream.github.io/2025/05/21/parsec-shi-yong-jiao-cheng/",
            "title": "parsec使用教程",
            "date_published": "2025-05-21T04:25:00.000Z",
            "content_html": "<h1 id=\"parsec使用教程\"><a href=\"#parsec使用教程\" class=\"headerlink\" title=\"parsec使用教程\"></a>parsec使用教程</h1><h2 id=\"如何在-Parsec-中把-Alt-Tab-传给远程主机\"><a href=\"#如何在-Parsec-中把-Alt-Tab-传给远程主机\" class=\"headerlink\" title=\"如何在 Parsec 中把 Alt+Tab 传给远程主机\"></a>如何在 Parsec 中把 Alt+Tab 传给远程主机</h2><h3 id=\"启用快捷键传递\"><a href=\"#启用快捷键传递\" class=\"headerlink\" title=\"启用快捷键传递\"></a>启用快捷键传递</h3><ol>\n<li>在 本机，点击 Parsec 窗口左上角的 <strong>菜单图标（三道杠）</strong>。</li>\n<li>选择 <code>Settings</code>（设置）。</li>\n<li>在设置中，点击左边的 **”Client”**（客户端）标签。</li>\n<li>找到 Immersive Mode 一栏。</li>\n<li><strong>启用</strong>：Keyboard</li>\n</ol>\n",
            "tags": [
                "远程"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/20/yt-dlp-shi-yong/",
            "url": "https://0xdadream.github.io/2025/05/20/yt-dlp-shi-yong/",
            "title": "yt-dlp 全功能实战教程",
            "date_published": "2025-05-20T01:25:00.000Z",
            "content_html": "<h1 id=\"yt-dlp-全功能实战教程（含-TikTok-下载、脚本自动化）\"><a href=\"#yt-dlp-全功能实战教程（含-TikTok-下载、脚本自动化）\" class=\"headerlink\" title=\"yt-dlp 全功能实战教程（含 TikTok 下载、脚本自动化）\"></a>yt-dlp 全功能实战教程（含 TikTok 下载、脚本自动化）</h1><hr>\n<h2 id=\"1-🧰-工具简介\"><a href=\"#1-🧰-工具简介\" class=\"headerlink\" title=\"1. 🧰 工具简介\"></a>1. 🧰 工具简介</h2><p><code>yt-dlp</code> 是 <code>youtube-dl</code> 的增强版本，支持更多网站、功能更强大、速度更快。支持 TikTok、YouTube、Bilibili、Twitter、Instagram、Twitch 等超多站点。</p>\n<hr>\n<h2 id=\"2-⚙️-安装方法\"><a href=\"#2-⚙️-安装方法\" class=\"headerlink\" title=\"2. ⚙️ 安装方法\"></a>2. ⚙️ 安装方法</h2><h3 id=\"🪟-Windows\"><a href=\"#🪟-Windows\" class=\"headerlink\" title=\"🪟 Windows\"></a>🪟 Windows</h3><ol>\n<li>下载地址：<a href=\"https://github.com/yt-dlp/yt-dlp/releases/latest\">https://github.com/yt-dlp/yt-dlp/releases/latest</a></li>\n<li>重命名为 <code>yt-dlp.exe</code>，放入环境变量或下载目录</li>\n</ol>\n<h3 id=\"🐧-Linux-macOS\"><a href=\"#🐧-Linux-macOS\" class=\"headerlink\" title=\"🐧 Linux/macOS\"></a>🐧 Linux/macOS</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">curl</span> <span class=\"token parameter variable\">-L</span> https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp <span class=\"token parameter variable\">-o</span> /usr/local/bin/yt-dlp\n<span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> a+rx /usr/local/bin/yt-dlp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"3-🏁-基础用法\"><a href=\"#3-🏁-基础用法\" class=\"headerlink\" title=\"3. 🏁 基础用法\"></a>3. 🏁 基础用法</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yt-dlp <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span>URL<span class=\"token operator\">&gt;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>例如：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yt-dlp https://www.tiktok.com/@xxx/video/1234567890123<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"4-🧩-参数全分类详解\"><a href=\"#4-🧩-参数全分类详解\" class=\"headerlink\" title=\"4. 🧩 参数全分类详解\"></a>4. 🧩 参数全分类详解</h2><h3 id=\"📥-下载控制\"><a href=\"#📥-下载控制\" class=\"headerlink\" title=\"📥 下载控制\"></a>📥 下载控制</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>-f FORMAT</code></td>\n<td>指定视频/音频格式，如 <code>bestvideo+bestaudio</code>、<code>mp4</code></td>\n</tr>\n<tr>\n<td><code>--no-playlist</code></td>\n<td>禁止下载播放列表</td>\n</tr>\n<tr>\n<td><code>--playlist-items 1,3,5</code></td>\n<td>下载指定序号</td>\n</tr>\n<tr>\n<td><code>--max-downloads N</code></td>\n<td>最多下载 N 个视频</td>\n</tr>\n<tr>\n<td><code>--download-archive FILE</code></td>\n<td>记录已下载内容，避免重复下载</td>\n</tr>\n<tr>\n<td><code>--match-filter</code></td>\n<td>过滤下载，如 <code>duration &lt; 300</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"💾-保存与命名\"><a href=\"#💾-保存与命名\" class=\"headerlink\" title=\"💾 保存与命名\"></a>💾 保存与命名</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>-o \"%(title)s.%(ext)s\"</code></td>\n<td>自定义保存文件名</td>\n</tr>\n<tr>\n<td><code>--output-na-placeholder \"NA\"</code></td>\n<td>没有信息时的默认值</td>\n</tr>\n<tr>\n<td><code>--paths PATH/</code></td>\n<td>统一指定保存路径</td>\n</tr>\n</tbody></table>\n<p>支持的字段有：</p>\n<ul>\n<li><code>%(title)s</code> 视频标题</li>\n<li><code>%(uploader)s</code> 上传者</li>\n<li><code>%(id)s</code> 视频ID</li>\n<li><code>%(upload_date)s</code> 上传日期等</li>\n</ul>\n<h3 id=\"📺-视频-音频格式\"><a href=\"#📺-视频-音频格式\" class=\"headerlink\" title=\"📺 视频/音频格式\"></a>📺 视频/音频格式</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>--recode-video mp4</code></td>\n<td>转换输出为 mp4</td>\n</tr>\n<tr>\n<td><code>-x</code> 或 <code>--extract-audio</code></td>\n<td>提取音频</td>\n</tr>\n<tr>\n<td><code>--audio-format mp3</code></td>\n<td>转为 mp3</td>\n</tr>\n<tr>\n<td><code>--audio-quality 0</code></td>\n<td>设置音质 0=最佳 9=最低</td>\n</tr>\n<tr>\n<td><code>--merge-output-format mp4</code></td>\n<td>视频合并输出为 mp4</td>\n</tr>\n</tbody></table>\n<h3 id=\"🌐-网络连接\"><a href=\"#🌐-网络连接\" class=\"headerlink\" title=\"🌐 网络连接\"></a>🌐 网络连接</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>--proxy http://127.0.0.1:7890</code></td>\n<td>设置代理</td>\n</tr>\n<tr>\n<td><code>--user-agent UA</code></td>\n<td>模拟浏览器</td>\n</tr>\n<tr>\n<td><code>--cookies cookies.txt</code></td>\n<td>加载登录 Cookie 下载私密视频</td>\n</tr>\n<tr>\n<td><code>--source-address IP</code></td>\n<td>多网卡选择出口IP</td>\n</tr>\n<tr>\n<td><code>--limit-rate 2M</code></td>\n<td>限速</td>\n</tr>\n<tr>\n<td><code>--fragment-retries 3</code></td>\n<td>分段重试次数</td>\n</tr>\n</tbody></table>\n<h3 id=\"💬-字幕与封面\"><a href=\"#💬-字幕与封面\" class=\"headerlink\" title=\"💬 字幕与封面\"></a>💬 字幕与封面</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>--write-subs</code></td>\n<td>下载字幕</td>\n</tr>\n<tr>\n<td><code>--write-auto-sub</code></td>\n<td>下载自动字幕</td>\n</tr>\n<tr>\n<td><code>--sub-lang en,zh</code></td>\n<td>多语言字幕</td>\n</tr>\n<tr>\n<td><code>--embed-subs</code></td>\n<td>将字幕嵌入视频</td>\n</tr>\n<tr>\n<td><code>--write-thumbnail</code></td>\n<td>下载封面</td>\n</tr>\n<tr>\n<td><code>--embed-thumbnail</code></td>\n<td>将封面嵌入视频文件</td>\n</tr>\n</tbody></table>\n<h3 id=\"🧾-元数据与信息\"><a href=\"#🧾-元数据与信息\" class=\"headerlink\" title=\"🧾 元数据与信息\"></a>🧾 元数据与信息</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>--write-info-json</code></td>\n<td>写出 json 格式的所有元信息</td>\n</tr>\n<tr>\n<td><code>--print \"%(title)s\"</code></td>\n<td>打印元数据信息</td>\n</tr>\n<tr>\n<td><code>--get-duration</code></td>\n<td>获取视频时长</td>\n</tr>\n<tr>\n<td><code>--get-description</code></td>\n<td>获取视频简介</td>\n</tr>\n<tr>\n<td><code>--get-filename</code></td>\n<td>获取保存路径而不下载</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"5-📚-实践案例\"><a href=\"#5-📚-实践案例\" class=\"headerlink\" title=\"5. 📚 实践案例\"></a>5. 📚 实践案例</h2><h3 id=\"📽-TikTok-下载最佳视频-音频合并输出\"><a href=\"#📽-TikTok-下载最佳视频-音频合并输出\" class=\"headerlink\" title=\"📽 TikTok 下载最佳视频 + 音频合并输出\"></a>📽 TikTok 下载最佳视频 + 音频合并输出</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yt-dlp <span class=\"token parameter variable\">-f</span> bestvideo+bestaudio --merge-output-format mp4 https://www.tiktok.com/@scout2015/video/7041234567890123456<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"📂-批量下载-TikTok-视频-避免重复-封面元数据\"><a href=\"#📂-批量下载-TikTok-视频-避免重复-封面元数据\" class=\"headerlink\" title=\"📂 批量下载 TikTok 视频 + 避免重复 + 封面元数据\"></a>📂 批量下载 TikTok 视频 + 避免重复 + 封面元数据</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yt-dlp <span class=\"token parameter variable\">-a</span> tiktok_links.txt --download-archive downloaded.txt ^\n<span class=\"token parameter variable\">-o</span> <span class=\"token string\">\"Videos/%(uploader)s_%(id)s.%(ext)s\"</span> ^\n--write-thumbnail --embed-thumbnail --write-info-json ^\n--merge-output-format mp4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"🎧-提取-TikTok-音频为-MP3\"><a href=\"#🎧-提取-TikTok-音频为-MP3\" class=\"headerlink\" title=\"🎧 提取 TikTok 音频为 MP3\"></a>🎧 提取 TikTok 音频为 MP3</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yt-dlp <span class=\"token parameter variable\">-x</span> --audio-format mp3 https://www.tiktok.com/@user/video/1234567890123<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"6-📜-批处理-Shell-脚本模板\"><a href=\"#6-📜-批处理-Shell-脚本模板\" class=\"headerlink\" title=\"6. 📜 批处理 &amp; Shell 脚本模板\"></a>6. 📜 批处理 &amp; Shell 脚本模板</h2><h3 id=\"🪟-Windows-bat\"><a href=\"#🪟-Windows-bat\" class=\"headerlink\" title=\"🪟 Windows .bat\"></a>🪟 Windows <code>.bat</code></h3><pre class=\"line-numbers language-bat\" data-language=\"bat\"><code class=\"language-bat\">@echo off\nset YTDLP=yt-dlp.exe\nset LINK_FILE=tiktok_links.txt\nset ARCHIVE=archive.txt\nset OUTPUT=Videos\n\n%YTDLP% -a %LINK_FILE% --download-archive %ARCHIVE% ^\n-o \"%OUTPUT%\\%%(uploader)s_%%(id)s.%%(ext)s\" ^\n--write-info-json --write-thumbnail --embed-thumbnail ^\n--merge-output-format mp4\npause<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"🐧-Linux-macOS-sh\"><a href=\"#🐧-Linux-macOS-sh\" class=\"headerlink\" title=\"🐧 Linux/macOS .sh\"></a>🐧 Linux/macOS <code>.sh</code></h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">LINK_FILE</span><span class=\"token operator\">=</span><span class=\"token string\">\"tiktok_links.txt\"</span>\n<span class=\"token assign-left variable\">ARCHIVE</span><span class=\"token operator\">=</span><span class=\"token string\">\"archive.txt\"</span>\n<span class=\"token assign-left variable\">OUTPUT</span><span class=\"token operator\">=</span><span class=\"token string\">\"Videos\"</span>\n\n<span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"<span class=\"token variable\">$OUTPUT</span>\"</span>\n\nyt-dlp <span class=\"token parameter variable\">-a</span> <span class=\"token string\">\"<span class=\"token variable\">$LINK_FILE</span>\"</span> --download-archive <span class=\"token string\">\"<span class=\"token variable\">$ARCHIVE</span>\"</span> <span class=\"token punctuation\">\\</span>\n<span class=\"token parameter variable\">-o</span> <span class=\"token string\">\"<span class=\"token variable\">$OUTPUT</span>/%(uploader)s_%(id)s.%(ext)s\"</span> <span class=\"token punctuation\">\\</span>\n--write-info-json --write-thumbnail --embed-thumbnail <span class=\"token punctuation\">\\</span>\n--merge-output-format mp4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"7-🕒-定时下载任务（Windows-示例）\"><a href=\"#7-🕒-定时下载任务（Windows-示例）\" class=\"headerlink\" title=\"7. 🕒 定时下载任务（Windows 示例）\"></a>7. 🕒 定时下载任务（Windows 示例）</h2><ol>\n<li>写一个 <code>.bat</code> 脚本：<code>auto_download.bat</code></li>\n<li>打开计划任务 -&gt; 创建基本任务 -&gt; 设置定时执行 <code>.bat</code></li>\n</ol>\n<hr>\n<h2 id=\"8-🔑-私密视频下载（TikTok-登录）\"><a href=\"#8-🔑-私密视频下载（TikTok-登录）\" class=\"headerlink\" title=\"8. 🔑 私密视频下载（TikTok 登录）\"></a>8. 🔑 私密视频下载（TikTok 登录）</h2><h3 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><ol>\n<li>登录 TikTok 网页</li>\n<li>使用浏览器插件导出 Cookie（如 EditThisCookie）</li>\n<li>保存为 <code>cookies.txt</code></li>\n<li>命令中加参数：</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yt-dlp <span class=\"token parameter variable\">--cookies</span> cookies.txt https://www.tiktok.com/<span class=\"token punctuation\">..</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"9-🧠-高级技巧：GUI-API-集成\"><a href=\"#9-🧠-高级技巧：GUI-API-集成\" class=\"headerlink\" title=\"9. 🧠 高级技巧：GUI / API 集成\"></a>9. 🧠 高级技巧：GUI / API 集成</h2><ul>\n<li>GUI 工具：<code>yt-dlg</code>（<a href=\"https://github.com/oleksis/ytdl-gui%EF%BC%89\">https://github.com/oleksis/ytdl-gui）</a></li>\n<li>与 Python 脚本结合（通过 <code>subprocess.run</code> 调用 yt-dlp）</li>\n<li>使用 <code>--print</code> + <code>--dump-json</code> 获取结构化数据用于网站抓取分析</li>\n</ul>\n<hr>\n<h2 id=\"10-🧯-常见问题汇总\"><a href=\"#10-🧯-常见问题汇总\" class=\"headerlink\" title=\"10. 🧯 常见问题汇总\"></a>10. 🧯 常见问题汇总</h2><table>\n<thead>\n<tr>\n<th>问题</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP 403 Forbidden</td>\n<td>添加代理或 cookies</td>\n</tr>\n<tr>\n<td>视频 ID 错误或跳转</td>\n<td>确保 URL 为标准 TikTok 网页格式</td>\n</tr>\n<tr>\n<td>格式不兼容</td>\n<td>使用 <code>--merge-output-format mp4</code></td>\n</tr>\n<tr>\n<td>速度慢</td>\n<td>使用代理 <code>--proxy</code>，或添加并发参数</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "下载"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/15/shen-qing-mian-fei-zheng-shu/",
            "url": "https://0xdadream.github.io/2025/05/15/shen-qing-mian-fei-zheng-shu/",
            "title": "申请免费证书",
            "date_published": "2025-05-15T14:25:00.000Z",
            "content_html": "<h1 id=\"申请免费证书\"><a href=\"#申请免费证书\" class=\"headerlink\" title=\"申请免费证书\"></a>申请免费证书</h1><p>【增强版 Bash 脚本】：交互选择使用 Cloudflare DNS 或 HTTP 验证，支持三大 CA</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"====== Acme.sh 证书申请一键脚本 ======\"</span>\n\n<span class=\"token comment\"># ===== 输入基本信息 =====</span>\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"请输入你的主域名（如 example.com）: \"</span> DOMAIN\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"是否使用泛域名（*.<span class=\"token variable\">${DOMAIN}</span>)? [y/N]: \"</span> WILDCARD\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"请输入你的邮箱地址（如 me@example.com）: \"</span> EMAIL\n\n<span class=\"token comment\"># ===== 选择 CA 机构 =====</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>请选择你要使用的证书颁发机构（CA）:\"</span>\n<span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">CA_PROVIDER</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"Let's Encrypt\"</span> <span class=\"token string\">\"ZeroSSL\"</span> <span class=\"token string\">\"Buypass\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  <span class=\"token keyword\">case</span> <span class=\"token environment constant\">$REPLY</span> <span class=\"token keyword\">in</span>\n    <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">CA_SERVER</span><span class=\"token operator\">=</span><span class=\"token string\">\"letsencrypt\"</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">CA_SERVER</span><span class=\"token operator\">=</span><span class=\"token string\">\"zerossl\"</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">CA_SERVER</span><span class=\"token operator\">=</span><span class=\"token string\">\"buypass\"</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"请输入 1-3 的数字\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">esac</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token comment\"># ===== 选择验证方式 =====</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>请选择验证方式:\"</span>\n<span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">VERIFY_METHOD</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"Cloudflare DNS 验证（推荐用于泛域名）\"</span> <span class=\"token string\">\"Standalone HTTP 验证（监听80端口）\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  <span class=\"token keyword\">case</span> <span class=\"token environment constant\">$REPLY</span> <span class=\"token keyword\">in</span>\n    <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">VERIFY_METHOD</span><span class=\"token operator\">=</span><span class=\"token string\">\"dns_cf\"</span><span class=\"token punctuation\">;</span> <span class=\"token assign-left variable\">DNS_MODE</span><span class=\"token operator\">=</span>true<span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">VERIFY_METHOD</span><span class=\"token operator\">=</span><span class=\"token string\">\"standalone\"</span><span class=\"token punctuation\">;</span> <span class=\"token assign-left variable\">DNS_MODE</span><span class=\"token operator\">=</span>false<span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"请输入 1 或 2\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">esac</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token comment\"># ===== 安装 acme.sh =====</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"<span class=\"token environment constant\">$HOME</span>/.acme.sh\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"[+] 安装 acme.sh ...\"</span>\n  <span class=\"token function\">curl</span> https://get.acme.sh <span class=\"token operator\">|</span> <span class=\"token function\">sh</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token builtin class-name\">source</span> <span class=\"token string\">\"<span class=\"token environment constant\">$HOME</span>/.acme.sh/acme.sh.env\"</span>\n\n<span class=\"token comment\"># ===== 注册账户 =====</span>\nacme.sh --set-default-ca <span class=\"token parameter variable\">--server</span> <span class=\"token variable\">$CA_SERVER</span>\nacme.sh --register-account <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"<span class=\"token variable\">$EMAIL</span>\"</span>\n\n<span class=\"token comment\"># ===== 处理域名格式 =====</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$WILDCARD</span>\"</span> <span class=\"token operator\">=~</span> ^<span class=\"token punctuation\">[</span>Yy<span class=\"token punctuation\">]</span>$ <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token assign-left variable\">CERT_DOMAIN</span><span class=\"token operator\">=</span><span class=\"token string\">\"*.<span class=\"token variable\">$DOMAIN</span>\"</span>\n<span class=\"token keyword\">else</span>\n  <span class=\"token assign-left variable\">CERT_DOMAIN</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$DOMAIN</span>\"</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token comment\"># ===== 如果使用 Cloudflare，输入 Token =====</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$DNS_MODE</span>\"</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"请输入你的 Cloudflare API Token: \"</span> CF_API_TOKEN\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-z</span> <span class=\"token string\">\"<span class=\"token variable\">$CF_API_TOKEN</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"[✗] Token 不能为空！\"</span>\n    <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">fi</span>\n  <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">CF_Token</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$CF_API_TOKEN</span>\"</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token comment\"># ===== 执行证书申请 =====</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"[+] 开始申请证书: <span class=\"token variable\">$CERT_DOMAIN</span>\"</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$DNS_MODE</span>\"</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  acme.sh <span class=\"token parameter variable\">--issue</span> <span class=\"token parameter variable\">--dns</span> <span class=\"token string\">\"<span class=\"token variable\">$VERIFY_METHOD</span>\"</span> <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"<span class=\"token variable\">$CERT_DOMAIN</span>\"</span> <span class=\"token parameter variable\">--force</span>\n<span class=\"token keyword\">else</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"[!] 请确保 80 端口未被占用（如 nginx），或已临时关闭\"</span>\n  <span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"确认后按回车继续...\"</span>\n  acme.sh <span class=\"token parameter variable\">--issue</span> <span class=\"token parameter variable\">--standalone</span> <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"<span class=\"token variable\">$CERT_DOMAIN</span>\"</span> <span class=\"token parameter variable\">--force</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token comment\"># ===== 安装证书到系统路径 =====</span>\n<span class=\"token assign-left variable\">REAL_DOMAIN</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">${DOMAIN<span class=\"token operator\">#</span>*.}</span>\"</span>  <span class=\"token comment\"># 去掉 *.</span>\n<span class=\"token assign-left variable\">CERT_DIR</span><span class=\"token operator\">=</span><span class=\"token string\">\"/etc/ssl/<span class=\"token variable\">$REAL_DOMAIN</span>\"</span>\n<span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"<span class=\"token variable\">$CERT_DIR</span>\"</span>\n\nacme.sh --install-cert <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"<span class=\"token variable\">$CERT_DOMAIN</span>\"</span> <span class=\"token punctuation\">\\</span>\n  --key-file       <span class=\"token string\">\"<span class=\"token variable\">$CERT_DIR</span>/key.pem\"</span> <span class=\"token punctuation\">\\</span>\n  --fullchain-file <span class=\"token string\">\"<span class=\"token variable\">$CERT_DIR</span>/fullchain.pem\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">--reloadcmd</span> <span class=\"token string\">\"echo '[✓] 可配置 nginx reload 命令'\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">--force</span>\n\n<span class=\"token comment\"># ===== 自动更新启用 =====</span>\nacme.sh <span class=\"token parameter variable\">--upgrade</span> --auto-upgrade\n\n<span class=\"token comment\"># ===== 成功信息 =====</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>[✓] 证书申请成功！\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"私钥路径:      <span class=\"token variable\">$CERT_DIR</span>/key.pem\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"完整证书路径:  <span class=\"token variable\">$CERT_DIR</span>/fullchain.pem\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"自动续期:      已启用（每天检测）\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>保存为xxx.sh，执行</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x acme_cert_auto.sh\n<span class=\"token function\">sudo</span> ./acme_cert_auto.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n",
            "tags": [
                "证书"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/05/15/lun-wen-yin-yong-xia-biao/",
            "url": "https://0xdadream.github.io/2025/05/15/lun-wen-yin-yong-xia-biao/",
            "title": "",
            "date_published": "2025-05-15T14:19:01.610Z",
            "content_html": "<h1 id=\"论文引用下标\"><a href=\"#论文引用下标\" class=\"headerlink\" title=\"论文引用下标\"></a>论文引用下标</h1><h2 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1. 准备工作\"></a>1. 准备工作</h2><h3 id=\"1-1-导入论文并整理参考文献列表\"><a href=\"#1-1-导入论文并整理参考文献列表\" class=\"headerlink\" title=\"1.1 导入论文并整理参考文献列表\"></a>1.1 导入论文并整理参考文献列表</h3><ol>\n<li>将已完成正文的论文文档打开或复制到 Microsoft Word 中，以便统一管理<a href=\"https://blog.csdn.net/weixin_36072709/article/details/112605694?utm_source=chatgpt.com\">CSDN</a>。</li>\n<li>在文档末尾粘贴或输入完整的参考文献条目列表，确保所有条目按预期样式（例如：[1]、(1) 等）占位<a href=\"https://jingyan.baidu.com/article/90bc8fc8a2ce58f652640c53.html?utm_source=chatgpt.com\">百度经验</a>。</li>\n</ol>\n<h2 id=\"2-确保参考文献编号自动生成\"><a href=\"#2-确保参考文献编号自动生成\" class=\"headerlink\" title=\"2. 确保参考文献编号自动生成\"></a>2. 确保参考文献编号自动生成</h2><h3 id=\"2-1-启用自动编号\"><a href=\"#2-1-启用自动编号\" class=\"headerlink\" title=\"2.1 启用自动编号\"></a>2.1 启用自动编号</h3><ol>\n<li>选中参考文献列表中的第一条目，切换到“开始”选项卡 → “编号”下拉，选择期望的编号样式（如纯数字、方括号等）<a href=\"https://blog.csdn.net/weixin_36072709/article/details/112605694?utm_source=chatgpt.com\">CSDN</a>。</li>\n<li>若内置样式不符，可在“定义新编号格式”中自定义编号前后符号、对齐方式等，确保与期刊或学校要求一致<a href=\"https://blog.csdn.net/weixin_36072709/article/details/112605694?utm_source=chatgpt.com\">CSDN</a>。</li>\n<li>确保整个参考文献段落都处于同一编号序列中，Word 将自动为后续条目顺序编号，无需手动输入<a href=\"https://jingyan.baidu.com/article/90bc8fc8a2ce58f652640c53.html?utm_source=chatgpt.com\">百度经验</a>。</li>\n</ol>\n<h2 id=\"3-插入交叉引用（Cross‑Reference）\"><a href=\"#3-插入交叉引用（Cross‑Reference）\" class=\"headerlink\" title=\"3. 插入交叉引用（Cross‑Reference）\"></a>3. 插入交叉引用（Cross‑Reference）</h2><p>交叉引用可将正文中的文献标号与末尾列表动态关联，自动更新编号。</p>\n<ol>\n<li>在正文中，光标置于需插入引用处，切换到“引用”选项卡 → “交叉引用”<a href=\"https://blog.csdn.net/weixin_39757169/article/details/110236875?utm_source=chatgpt.com\">CSDN</a>。</li>\n<li>在“引用类型”选择“编号项”，在“引用内容”中选“仅插入编号”，然后在列表中点击对应参考文献条目→“插入”<a href=\"https://blog.csdn.net/weixin_39757169/article/details/110236875?utm_source=chatgpt.com\">CSDN</a>。</li>\n<li>完成后，Word 会在文中插入如“[1]”的标号，且编号与参考文献列表联动。若列表重排，交叉引用编号将自动更新<a href=\"https://jingyan.baidu.com/article/90bc8fc8a2ce58f652640c53.html?utm_source=chatgpt.com\">百度经验</a>。</li>\n<li>若需同时插入多条引用，可重复上述步骤，或在“交叉引用”对话框中多选条目后批量插入<a href=\"https://blog.csdn.net/weixin_39757169/article/details/110236875?utm_source=chatgpt.com\">CSDN</a>。</li>\n</ol>\n<h2 id=\"4-使用-Word-内置“引文-书目”功能\"><a href=\"#4-使用-Word-内置“引文-书目”功能\" class=\"headerlink\" title=\"4. 使用 Word 内置“引文 &amp; 书目”功能\"></a>4. 使用 Word 内置“引文 &amp; 书目”功能</h2><p>对于规范化较高的期刊或教材写作，建议使用 Word 的“引文 &amp; 书目”模块：</p>\n<ol>\n<li>切换到“引用”选项卡，在“引文 &amp; 书目”组中选择合适的引用样式（APA、IEEE、MLA 等）<a href=\"https://support.microsoft.com/zh-cn/office/%E5%9C%A8-word-%E6%96%87%E6%A1%A3%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%BC%95%E6%96%87-ab9322bb-a8d3-47f4-80c8-63c06779f127?utm_source=chatgpt.com\">微软支持</a>。</li>\n<li>在正文光标处点击“插入引文”→“添加新源”，在弹出对话框中填写作者、标题、年份、期刊等信息→确定，Word 即插入 <code>(作者, 年份)</code> 或 <code>[编号]</code> 格式的引用<a href=\"https://support.microsoft.com/zh-cn/office/%E5%9C%A8-word-%E6%96%87%E6%A1%A3%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%BC%95%E6%96%87-ab9322bb-a8d3-47f4-80c8-63c06779f127?utm_source=chatgpt.com\">微软支持</a>。</li>\n<li>会在“当前列表”中生成对应条目，文中再次引用时可直接从“插入引文”列表中选择，无需重复录入<a href=\"https://support.microsoft.com/zh-cn/office/%E5%9C%A8-word-%E6%96%87%E6%A1%A3%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%BC%95%E6%96%87-ab9322bb-a8d3-47f4-80c8-63c06779f127?utm_source=chatgpt.com\">微软支持</a>。</li>\n<li>文末点击“书目”或“参考文献”按钮，Word 将根据所选样式自动生成并更新完整的参考文献列表<a href=\"https://support.microsoft.com/zh-cn/office/%E5%9C%A8-word-%E6%96%87%E6%A1%A3%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%BC%95%E6%96%87-ab9322bb-a8d3-47f4-80c8-63c06779f127?utm_source=chatgpt.com\">微软支持</a>。</li>\n</ol>\n<h2 id=\"5-可选：使用-Zotero-插件管理引用\"><a href=\"#5-可选：使用-Zotero-插件管理引用\" class=\"headerlink\" title=\"5. 可选：使用 Zotero 插件管理引用\"></a>5. 可选：使用 Zotero 插件管理引用</h2><p>对于文献量大或团队协作写作，推荐文献管理工具：</p>\n<ol>\n<li><p>安装 Zotero 客户端及其 Word 插件，打开 Word 后可见“Zotero”选项卡<a href=\"https://zotero-chinese.com/user-guide/ms-word-plugin?utm_source=chatgpt.com\">Zotero 中文社区</a>。</p>\n</li>\n<li><p>在 Zotero 中导入或手动添加文献信息（支持 DOI、ISBN 自动抓取元数据）<a href=\"https://zotero-chinese.com/user-guide/ms-word-plugin?utm_source=chatgpt.com\">Zotero 中文社区</a>。</p>\n</li>\n<li><p>Word 中点击“Add/Edit Citation”，首次选择引用样式后，可按作者名或关键词检索条目并插入文内引用<a href=\"https://zotero-chinese.com/user-guide/ms-word-plugin?utm_source=chatgpt.com\">Zotero 中文社区</a>。</p>\n</li>\n<li><p>文末点击“Add/Edit Bibliography”，Zotero 会自动汇总文中所有引用并按选定格式生成参考文献列表，随后若有新增引用可一键更新列表<a href=\"https://zotero-chinese.com/user-guide/ms-word-plugin?utm_source=chatgpt.com\">Zotero 中文社区</a>。</p>\n<p>参考链接：<a href=\"https://zhuanlan.zhihu.com/p/309606954\">论文写作中怎样正确插入参考文献，引用文献如何标注？ - 知乎</a></p>\n</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://0xdadream.github.io/2025/05/02/whl-wen-jian-ming-hou-zhui/",
            "url": "https://0xdadream.github.io/2025/05/02/whl-wen-jian-ming-hou-zhui/",
            "title": "whl文件名后缀",
            "date_published": "2025-05-02T04:25:00.000Z",
            "content_html": "<h1 id=\"whl文件名后缀\"><a href=\"#whl文件名后缀\" class=\"headerlink\" title=\"whl文件名后缀\"></a>whl文件名后缀</h1><h2 id=\"1-Wheel-文件名的基本格式\"><a href=\"#1-Wheel-文件名的基本格式\" class=\"headerlink\" title=\"1. Wheel 文件名的基本格式\"></a>1. Wheel 文件名的基本格式</h2><p>Wheel 名称遵循 PEP 427 规范，通用格式为：</p>\n<pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\"><span class=\"token punctuation\">{</span>distribution<span class=\"token punctuation\">}</span><span class=\"token operator\">-</span><span class=\"token punctuation\">{</span>version<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token punctuation\">{</span>build tag<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token operator\">-</span><span class=\"token punctuation\">{</span>python tag<span class=\"token punctuation\">}</span><span class=\"token operator\">-</span><span class=\"token punctuation\">{</span>abi tag<span class=\"token punctuation\">}</span><span class=\"token operator\">-</span><span class=\"token punctuation\">{</span>platform tag<span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span>whl<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><strong>distribution</strong>：包名</li>\n<li><strong>version</strong>：包版本</li>\n<li><strong>build tag</strong>（可选）：构建号</li>\n<li><strong>python tag</strong>：支持的 Python 解释器及版本</li>\n<li><strong>abi tag</strong>：二进制兼容的 ABI（应用二进制接口）</li>\n<li><strong>platform tag</strong>：目标操作系统和硬件平台</li>\n</ul>\n<p>例子：</p>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\">mypkg-1.2.3-1-cp39-cp39-manylinux2014_x86_64.whl\n       │    │   │    │            └──── platform tag\n       │    │   │    └──────────────── abi tag\n       │    │   └─────────────────────── python tag\n       │    └─────────────────────────── build tag\n       └─────────────────────────────── distribution-version<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"2-build-tag\"><a href=\"#2-build-tag\" class=\"headerlink\" title=\"2. build tag\"></a>2. build tag</h2><ul>\n<li>格式：一个整数，有时候也会带字母或其他标识</li>\n<li>用途：同一版本的多次编译时区分，比如针对不同源或依赖变动的二进制重构</li>\n<li>示例：<ul>\n<li><code>mypkg-1.0-1-...</code> 与 <code>mypkg-1.0-2-...</code> 表示同一版本的第 1 次和第 2 次构建</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-python-tag\"><a href=\"#3-python-tag\" class=\"headerlink\" title=\"3. python tag\"></a>3. python tag</h2><p>指明哪些 Python 解释器及版本可以安装该 Wheel。常见格式及含义：</p>\n<table>\n<thead>\n<tr>\n<th>tag 示例</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>py3</code></td>\n<td>支持所有 Python 3.x</td>\n</tr>\n<tr>\n<td><code>py36</code> 、<code>py37</code>…</td>\n<td>专用于 Python 3.6、3.7 等</td>\n</tr>\n<tr>\n<td><code>py2.py3</code></td>\n<td>同时支持 Python 2.x 和 3.x</td>\n</tr>\n<tr>\n<td><code>cp39</code></td>\n<td>CPython 3.9</td>\n</tr>\n<tr>\n<td><code>cp310</code></td>\n<td>CPython 3.10</td>\n</tr>\n<tr>\n<td><code>pp37</code></td>\n<td>PyPy 3.7</td>\n</tr>\n<tr>\n<td><code>jy37</code></td>\n<td>Jython 2.7（标识为 <code>jy27</code>）等</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>前缀</strong><ul>\n<li><code>py</code>：纯 Python 实现</li>\n<li><code>cp</code>：CPython（二进制扩展）</li>\n<li><code>pp</code>：PyPy</li>\n<li><code>jy</code>：Jython</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"4-abi-tag\"><a href=\"#4-abi-tag\" class=\"headerlink\" title=\"4. abi tag\"></a>4. abi tag</h2><p>ABI（Application Binary Interface）决定了编译的 C 扩展与解释器的二进制兼容性。常见 ABI tag：</p>\n<table>\n<thead>\n<tr>\n<th>tag 示例</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>none</code></td>\n<td>纯 Python 包，不含 C 扩展</td>\n</tr>\n<tr>\n<td><code>abi3</code></td>\n<td>使用了稳定的“limited API”（PEP 384），跨多个 CPython 版本兼容</td>\n</tr>\n<tr>\n<td><code>cp39</code></td>\n<td>针对 CPython 3.9 标准 ABI 编译</td>\n</tr>\n<tr>\n<td><code>cp39m</code></td>\n<td>CPython 3.9 + pymalloc enabled（<code>m</code>）</td>\n</tr>\n<tr>\n<td><code>cp310d</code></td>\n<td>CPython 3.10 Debug build（<code>d</code>）</td>\n</tr>\n</tbody></table>\n<ul>\n<li>如果 <code>python tag</code> 与 <code>abi tag</code> 一致（如 <code>cp39-cp39</code>），表示该包针对该版本的标准 ABI 编译</li>\n<li>带后缀的如 <code>m</code>、<code>d</code>、<code>u</code> 等表示特定的编译选项</li>\n</ul>\n<hr>\n<h2 id=\"5-platform-tag\"><a href=\"#5-platform-tag\" class=\"headerlink\" title=\"5. platform tag\"></a>5. platform tag</h2><p>描述该 Wheel 的目标操作系统、系统版本和 CPU 架构。常见平台 tag 及示例：</p>\n<table>\n<thead>\n<tr>\n<th>platform tag 示例</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>manylinux1_x86_64</code></td>\n<td>Linux x86_64，符合 Manylinux1 标准</td>\n</tr>\n<tr>\n<td><code>manylinux2014_aarch64</code></td>\n<td>Linux ARM64，符合 Manylinux2014 标准</td>\n</tr>\n<tr>\n<td><code>win_amd64</code></td>\n<td>Windows 64 位</td>\n</tr>\n<tr>\n<td><code>win32</code></td>\n<td>Windows 32 位</td>\n</tr>\n<tr>\n<td><code>macosx_10_9_x86_64</code></td>\n<td>macOS 10.9+ on x86_64</td>\n</tr>\n<tr>\n<td><code>macosx_11_0_arm64</code></td>\n<td>macOS 11+ on Apple Silicon (ARM64)</td>\n</tr>\n<tr>\n<td><code>any</code></td>\n<td>平台无关（纯 Python 包）</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>manylinux</strong> 系列：用于在大多数 Linux 发行版上安装二进制扩展</li>\n<li><strong>macosx</strong>：通常还会带上最低支持的 macOS 版本号</li>\n<li><strong>any</strong>：完全纯 Python，无平台限制</li>\n</ul>\n<hr>\n<h2 id=\"6-综合示例解析\"><a href=\"#6-综合示例解析\" class=\"headerlink\" title=\"6. 综合示例解析\"></a>6. 综合示例解析</h2><table>\n<thead>\n<tr>\n<th>Wheel 名称</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>requests-2.28.1-py3-none-any.whl</code></td>\n<td>纯 Python 包 <code>requests</code> v2.28.1，支持所有 Python 3，平台无关</td>\n</tr>\n<tr>\n<td><code>numpy-1.24.0-cp39-cp39-manylinux2014_x86_64.whl</code></td>\n<td><code>numpy</code> v1.24.0，CPython 3.9 标准 ABI，Linux x86_64 二进制</td>\n</tr>\n<tr>\n<td><code>Pillow-9.3.0-cp310-cp310-win_amd64.whl</code></td>\n<td><code>Pillow</code> v9.3.0，CPython 3.10，Windows 64 位</td>\n</tr>\n<tr>\n<td><code>somepkg-0.1.0-2-cp38-abi3-manylinux1_x86_64.whl</code></td>\n<td><code>somepkg</code> v0.1.0，第 2 次构建，CPython 3.8 编译但使用 abi3，Linux x86_64</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-为什么要了解这些后缀\"><a href=\"#7-为什么要了解这些后缀\" class=\"headerlink\" title=\"7. 为什么要了解这些后缀\"></a>7. 为什么要了解这些后缀</h2><ol>\n<li><strong>避免安装失败</strong><ul>\n<li><code>pip install package.whl</code> 时，若当前环境的 Python 版本、ABI 或平台与 Wheel 不匹配，安装会被跳过或报错。</li>\n</ul>\n</li>\n<li><strong>提高下载速度</strong><ul>\n<li>选择预编译好的 <code>.whl</code>，可免去源码编译时间，尤其是大型 C 扩展库（如 NumPy、SciPy）。</li>\n</ul>\n</li>\n<li><strong>跨平台兼容</strong><ul>\n<li>理解 <code>manylinux</code>、<code>macosx</code>、<code>win</code> 等标签，有助于在不同系统间无痛部署。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"8-查找可用的-Wheel\"><a href=\"#8-查找可用的-Wheel\" class=\"headerlink\" title=\"8. 查找可用的 Wheel\"></a>8. 查找可用的 Wheel</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pip index versions PACKAGE_NAME<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pip <span class=\"token function\">install</span> PACKAGE_NAME --only-binary<span class=\"token operator\">=</span>:all:<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>第一个命令列出所有可用版本及对应的 Wheel</li>\n<li>第二个命令强制只使用二进制 Wheel 安装</li>\n</ul>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/04/10/linux-an-zhuang-conda-jiao-cheng/",
            "url": "https://0xdadream.github.io/2025/04/10/linux-an-zhuang-conda-jiao-cheng/",
            "title": "Linux安装Conda教程",
            "date_published": "2025-04-10T05:25:00.000Z",
            "content_html": "<h1 id=\"Linux安装Conda教程\"><a href=\"#Linux安装Conda教程\" class=\"headerlink\" title=\"Linux安装Conda教程\"></a>Linux安装Conda教程</h1><h2 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1. 准备工作\"></a>1. 准备工作</h2><h3 id=\"1-1-系统要求\"><a href=\"#1-1-系统要求\" class=\"headerlink\" title=\"1.1 系统要求\"></a>1.1 系统要求</h3><ul>\n<li>操作系统：大多数 Linux 发行版（如 Ubuntu、Debian、CentOS、Fedora 等）都可使用。</li>\n<li>权限：建议使用普通用户（避免使用 root 权限直接安装）来安装并管理 conda 环境。</li>\n<li>网络连接：需要下载安装脚本，可以使用 <code>wget</code> 或 <code>curl</code> 工具。</li>\n</ul>\n<h3 id=\"1-2-安装前依赖（可选）\"><a href=\"#1-2-安装前依赖（可选）\" class=\"headerlink\" title=\"1.2 安装前依赖（可选）\"></a>1.2 安装前依赖（可选）</h3><p>大多数 Linux 系统都自带 <code>bash</code> 和基本工具。如果你的系统缺少 wget 或 curl，可以使用包管理器安装，例如：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># Ubuntu / Debian 系统</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">wget</span> <span class=\"token function\">curl</span>\n\n<span class=\"token comment\"># CentOS / Fedora 系统</span>\n<span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> <span class=\"token function\">wget</span> <span class=\"token function\">curl</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"2-下载-Miniconda-安装脚本\"><a href=\"#2-下载-Miniconda-安装脚本\" class=\"headerlink\" title=\"2. 下载 Miniconda 安装脚本\"></a>2. 下载 Miniconda 安装脚本</h2><p>Miniconda 提供了适用于 Linux 的安装脚本。可以按以下步骤操作：</p>\n<h3 id=\"2-1-选择合适的安装程序\"><a href=\"#2-1-选择合适的安装程序\" class=\"headerlink\" title=\"2.1 选择合适的安装程序\"></a>2.1 选择合适的安装程序</h3><p>对于大多数 64 位系统，下载最新的 Miniconda3 版本。安装脚本文件名为 <code>Miniconda3-latest-Linux-x86_64.sh</code>。</p>\n<h3 id=\"2-2-使用-wget-或-curl-下载\"><a href=\"#2-2-使用-wget-或-curl-下载\" class=\"headerlink\" title=\"2.2 使用 wget 或 curl 下载\"></a>2.2 使用 wget 或 curl 下载</h3><p>使用 <code>wget</code>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">wget</span> https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或使用 <code>curl</code>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-O</span> https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"3-验证安装包完整性（可选）\"><a href=\"#3-验证安装包完整性（可选）\" class=\"headerlink\" title=\"3. 验证安装包完整性（可选）\"></a>3. 验证安装包完整性（可选）</h2><p>为确保下载的文件未被破坏或篡改，可以检查 SHA256 校验和。你需要从 Miniconda 官方页面 查看对应版本的正确 SHA256 值，然后执行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">sha256sum Miniconda3-latest-Linux-x86_64.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>比较输出结果和官方提供的校验和。如果一致，则可以继续安装。</p>\n<hr>\n<h2 id=\"4-安装-Miniconda\"><a href=\"#4-安装-Miniconda\" class=\"headerlink\" title=\"4. 安装 Miniconda\"></a>4. 安装 Miniconda</h2><h3 id=\"4-1-赋予执行权限\"><a href=\"#4-1-赋予执行权限\" class=\"headerlink\" title=\"4.1 赋予执行权限\"></a>4.1 赋予执行权限</h3><p>首先为下载的脚本添加执行权限：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x Miniconda3-latest-Linux-x86_64.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"4-2-运行安装脚本\"><a href=\"#4-2-运行安装脚本\" class=\"headerlink\" title=\"4.2 运行安装脚本\"></a>4.2 运行安装脚本</h3><p>使用 bash 执行安装脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">./Miniconda3-latest-Linux-x86_64.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"4-3-安装过程中注意事项\"><a href=\"#4-3-安装过程中注意事项\" class=\"headerlink\" title=\"4.3 安装过程中注意事项\"></a>4.3 安装过程中注意事项</h3><ol>\n<li><strong>阅读许可协议</strong>：安装脚本开始时会显示许可协议，需要按下 <code>Enter</code> 浏览内容，然后输入 <code>yes</code> 接受许可协议。</li>\n<li><strong>选择安装路径</strong>：脚本默认建议安装到用户主目录下的 <code>miniconda3</code> 目录。你可以按回车键接受默认设置，也可以输入自定义路径。</li>\n<li><strong>初始化 conda</strong>：安装过程中会询问是否初始化 conda（即修改 shell 启动文件，如 <code>~/.bashrc</code>）。推荐选择 “yes”，这样每次登录时都会自动加载 conda 环境配置。</li>\n</ol>\n<p>安装完成后，安装脚本会显示 “installation finished.” 的提示。</p>\n<hr>\n<h2 id=\"5-激活-conda-环境\"><a href=\"#5-激活-conda-环境\" class=\"headerlink\" title=\"5. 激活 conda 环境\"></a>5. 激活 conda 环境</h2><p>如果安装时选择了初始化，则会自动在 <code>~/.bashrc</code> 中添加必要的配置，通常类似如下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span>\n<span class=\"token comment\"># !! Contents within this block are managed by 'conda init' !!</span>\n<span class=\"token assign-left variable\">__conda_setup</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>'/home/your_username/miniconda3/bin/conda<span class=\"token string\">' '</span>shell.bash<span class=\"token string\">' '</span>hook' <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>&gt;</span> /dev/null<span class=\"token variable\">)</span></span>\"</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">eval</span> <span class=\"token string\">\"<span class=\"token variable\">$__conda_setup</span>\"</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-f</span> <span class=\"token string\">\"/home/your_username/miniconda3/etc/profile.d/conda.sh\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">.</span> <span class=\"token string\">\"/home/your_username/miniconda3/etc/profile.d/conda.sh\"</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token string\">\"/home/your_username/miniconda3/bin:<span class=\"token environment constant\">$PATH</span>\"</span>\n    <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token builtin class-name\">unset</span> __conda_setup\n<span class=\"token comment\"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果你没有选择自动初始化，可以手动执行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">source</span> ~/miniconda3/etc/profile.d/conda.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或者直接将 conda 的路径添加到你的 PATH 环境变量中：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=~</span>/miniconda3/bin:<span class=\"token environment constant\">$PATH</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>建议将上述命令添加到 <code>~/.bashrc</code> 或其他相应的 shell 配置文件中。</p>\n<hr>\n<h2 id=\"6-验证安装\"><a href=\"#6-验证安装\" class=\"headerlink\" title=\"6. 验证安装\"></a>6. 验证安装</h2><p>打开一个新的终端或在当前终端执行激活命令后，运行以下命令检查 conda 是否安装成功：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">conda <span class=\"token parameter variable\">--version</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>正常情况下，会输出类似 <code>conda 4.x.x</code> 版本信息。</p>\n<hr>\n<h2 id=\"7-基本使用\"><a href=\"#7-基本使用\" class=\"headerlink\" title=\"7. 基本使用\"></a>7. 基本使用</h2><h3 id=\"7-1-创建虚拟环境\"><a href=\"#7-1-创建虚拟环境\" class=\"headerlink\" title=\"7.1 创建虚拟环境\"></a>7.1 创建虚拟环境</h3><p>例如，创建一个名为 <code>myenv</code> 的环境，并安装 Python 3.9：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">conda create <span class=\"token parameter variable\">-n</span> myenv <span class=\"token assign-left variable\">python</span><span class=\"token operator\">=</span><span class=\"token number\">3.9</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"7-2-激活虚拟环境\"><a href=\"#7-2-激活虚拟环境\" class=\"headerlink\" title=\"7.2 激活虚拟环境\"></a>7.2 激活虚拟环境</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">conda activate myenv<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>激活后，命令提示符中会显示环境名称。</p>\n<h3 id=\"7-3-安装其他包\"><a href=\"#7-3-安装其他包\" class=\"headerlink\" title=\"7.3 安装其他包\"></a>7.3 安装其他包</h3><p>可以直接使用 conda 安装需要的包，例如安装 numpy：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">conda <span class=\"token function\">install</span> numpy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>此外，也可以使用 pip 安装不在 conda 仓库里的包，但推荐先查找 conda 仓库，因为 conda 可能已经进行了优化和依赖管理。</p>\n<h3 id=\"7-4-更新-conda\"><a href=\"#7-4-更新-conda\" class=\"headerlink\" title=\"7.4 更新 conda\"></a>7.4 更新 conda</h3><p>建议定期更新 conda 以确保使用最新的功能和安全补丁：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">conda update conda<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"8-常见问题排查\"><a href=\"#8-常见问题排查\" class=\"headerlink\" title=\"8. 常见问题排查\"></a>8. 常见问题排查</h2><h3 id=\"8-1-conda-命令未找到\"><a href=\"#8-1-conda-命令未找到\" class=\"headerlink\" title=\"8.1 conda 命令未找到\"></a>8.1 conda 命令未找到</h3><ul>\n<li><p>请确保你的 <code>~/.bashrc</code> 文件已正确载入，可以执行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">source</span> ~/.bashrc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>检查是否正确添加了 conda 的安装路径至 PATH 环境变量中。</p>\n</li>\n</ul>\n<h3 id=\"8-2-安装或更新失败\"><a href=\"#8-2-安装或更新失败\" class=\"headerlink\" title=\"8.2 安装或更新失败\"></a>8.2 安装或更新失败</h3><ul>\n<li>检查网络连接或国内用户是否需要配置代理或使用镜像源（例如清华、阿里等提供的 conda 镜像）。</li>\n<li>参考官方文档（conda 官方文档）获取更多帮助和说明。</li>\n</ul>\n<hr>\n<h2 id=\"9-参考资料\"><a href=\"#9-参考资料\" class=\"headerlink\" title=\"9. 参考资料\"></a>9. 参考资料</h2><ul>\n<li></li>\n<li></li>\n</ul>\n",
            "tags": [
                "conda"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/04/10/an-zhuang-wsl-zi-xi-tong-jiao-cheng/",
            "url": "https://0xdadream.github.io/2025/04/10/an-zhuang-wsl-zi-xi-tong-jiao-cheng/",
            "title": "安装WSL子系统教程",
            "date_published": "2025-04-10T04:25:00.000Z",
            "content_html": "<h1 id=\"安装WSL子系统教程\"><a href=\"#安装WSL子系统教程\" class=\"headerlink\" title=\"安装WSL子系统教程\"></a>安装WSL子系统教程</h1><hr>\n<h2 id=\"1-前提条件与准备工作\"><a href=\"#1-前提条件与准备工作\" class=\"headerlink\" title=\"1. 前提条件与准备工作\"></a>1. 前提条件与准备工作</h2><ul>\n<li><strong>操作系统要求</strong>：<ul>\n<li>Windows 10：要求版本 2004 及 Build 19041 以上，或</li>\n<li>Windows 11</li>\n</ul>\n</li>\n<li><strong>网络环境</strong>：部分地区需要设置代理。</li>\n<li><strong>管理员权限</strong>：安装及部分配置需要以管理员身份运行 PowerShell 或 CMD。</li>\n<li><strong>存储空间及磁盘规划</strong>：WSL 会在系统盘或你指定的目录中保存 Linux 文件系统，提前规划好存储位置与空间。</li>\n</ul>\n<hr>\n<h2 id=\"2-WSL-安装方法\"><a href=\"#2-WSL-安装方法\" class=\"headerlink\" title=\"2. WSL 安装方法\"></a>2. WSL 安装方法</h2><h3 id=\"2-1-一键安装（推荐）\"><a href=\"#2-1-一键安装（推荐）\" class=\"headerlink\" title=\"2.1 一键安装（推荐）\"></a>2.1 一键安装（推荐）</h3><p>适用于 Windows 10 21H2 及之后版本以及 Windows 11。步骤如下：</p>\n<ol>\n<li><p><strong>打开 PowerShell（管理员模式）</strong>：<br> 在开始菜单搜索 “PowerShell”，右键选择“以管理员身份运行”。</p>\n</li>\n<li><p><strong>执行安装命令</strong>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>install<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>此命令会自动启用 WSL 相关组件、虚拟机平台，并默认安装最新的 WSL 版本（通常为 WSL2）和默认 Linux 发行版（一般为 Ubuntu）。</p>\n</li>\n<li><p><strong>重启电脑</strong>：安装完成后系统会提示重启以完成配置。</p>\n</li>\n</ol>\n<h3 id=\"2-2-手动安装\"><a href=\"#2-2-手动安装\" class=\"headerlink\" title=\"2.2 手动安装\"></a>2.2 手动安装</h3><p>对于需要更多自定义选项的用户，手动安装步骤如下：</p>\n<h4 id=\"（1）启用-WSL-和虚拟机平台功能\"><a href=\"#（1）启用-WSL-和虚拟机平台功能\" class=\"headerlink\" title=\"（1）启用 WSL 和虚拟机平台功能\"></a>（1）启用 WSL 和虚拟机平台功能</h4><p>在管理员模式下打开 PowerShell，依次执行：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">dism<span class=\"token punctuation\">.</span>exe <span class=\"token operator\">/</span>online <span class=\"token operator\">/</span><span class=\"token function\">enable-feature</span> <span class=\"token operator\">/</span>featurename:Microsoft-Windows-Subsystem-Linux <span class=\"token operator\">/</span>all <span class=\"token operator\">/</span>norestart\ndism<span class=\"token punctuation\">.</span>exe <span class=\"token operator\">/</span>online <span class=\"token operator\">/</span><span class=\"token function\">enable-feature</span> <span class=\"token operator\">/</span>featurename:VirtualMachinePlatform <span class=\"token operator\">/</span>all <span class=\"token operator\">/</span>norestart<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>执行后重启计算机。</p>\n<h4 id=\"（2）安装-WSL2-内核更新包\"><a href=\"#（2）安装-WSL2-内核更新包\" class=\"headerlink\" title=\"（2）安装 WSL2 内核更新包\"></a>（2）安装 WSL2 内核更新包</h4><p>前往 WSL2 内核更新包下载链接 ，下载并运行安装包，更新 Linux 内核。</p>\n<h4 id=\"（3）设置默认-WSL-版本为-WSL2\"><a href=\"#（3）设置默认-WSL-版本为-WSL2\" class=\"headerlink\" title=\"（3）设置默认 WSL 版本为 WSL2\"></a>（3）设置默认 WSL 版本为 WSL2</h4><p>再次打开 PowerShell（无需管理员模式也可），执行：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span><span class=\"token function\">set-default</span><span class=\"token operator\">-</span>version 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"（4）安装-Linux-发行版\"><a href=\"#（4）安装-Linux-发行版\" class=\"headerlink\" title=\"（4）安装 Linux 发行版\"></a>（4）安装 Linux 发行版</h4><p>有两种方式：</p>\n<ul>\n<li><p><strong>通过 Microsoft Store</strong>：搜索 <code>Ubuntu</code>、<code>Debian</code> 等，选择版本（如 Ubuntu 22.04 LTS），点击“获取”安装，推荐这个，然后再执行命令行安装。</p>\n</li>\n<li><p><strong>命令行安装</strong>：查看支持的在线发行版列表：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>list <span class=\"token operator\">--</span>online<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>安装指定版本（例如 Ubuntu 20.04）：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>install <span class=\"token operator\">-</span>d Ubuntu-20<span class=\"token punctuation\">.</span>04<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"3-Linux-发行版安装及首次使用\"><a href=\"#3-Linux-发行版安装及首次使用\" class=\"headerlink\" title=\"3. Linux 发行版安装及首次使用\"></a>3. Linux 发行版安装及首次使用</h2><ol>\n<li><p><strong>首次启动</strong>：安装完成后，从“开始菜单”启动对应 Linux 发行版。</p>\n</li>\n<li><p><strong>创建用户</strong>：系统会提示你为 Linux 系统创建用户名（须为小写）和密码，这样你就可以使用 <code>sudo</code> 提权操作。</p>\n</li>\n<li><p><strong>更新系统</strong>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> upgrade<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>安装常用软件</strong>：根据需要安装 <code>git</code>、<code>vim</code>、<code>python3</code> 等：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">git</span> <span class=\"token function\">vim</span> python3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<hr>\n<h2 id=\"4-WSL-版本切换：WSL1-与-WSL2\"><a href=\"#4-WSL-版本切换：WSL1-与-WSL2\" class=\"headerlink\" title=\"4. WSL 版本切换：WSL1 与 WSL2\"></a>4. WSL 版本切换：WSL1 与 WSL2</h2><p>WSL 中各发行版可以独立设置为 WSL1 或 WSL2。查看所有已安装发行版及其版本：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">-</span>l <span class=\"token operator\">-</span>v<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>输出示例：</p>\n<pre class=\"line-numbers language-pgsql\" data-language=\"pgsql\"><code class=\"language-pgsql\"> NAME            STATE           VERSION\n* Ubuntu-22.04    Running         2\n  Ubuntu-20.04    Stopped         2\n  Debian          Stopped         1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"切换版本\"><a href=\"#切换版本\" class=\"headerlink\" title=\"切换版本\"></a>切换版本</h3><ul>\n<li><p><strong>将发行版切换为 WSL2</strong>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span><span class=\"token function\">set-version</span> &lt;发行版名称&gt; 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>例如：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span><span class=\"token function\">set-version</span> Debian 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>将发行版切换为 WSL1</strong>（如有需求）：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span><span class=\"token function\">set-version</span> &lt;发行版名称&gt; 1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>设置默认安装版本</strong>：在安装新发行版时，可以用下面命令设置默认版本：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span><span class=\"token function\">set-default</span><span class=\"token operator\">-</span>version 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<p>切换版本过程中，转换时间与系统数据量有关，部分较大发行版可能需要几分钟。</p>\n<hr>\n<h2 id=\"5-附加功能与进阶用法\"><a href=\"#5-附加功能与进阶用法\" class=\"headerlink\" title=\"5. 附加功能与进阶用法\"></a>5. 附加功能与进阶用法</h2><h3 id=\"5-1-Windows-与-WSL-文件共享\"><a href=\"#5-1-Windows-与-WSL-文件共享\" class=\"headerlink\" title=\"5.1 Windows 与 WSL 文件共享\"></a>5.1 Windows 与 WSL 文件共享</h3><ul>\n<li><p><strong>WSL 文件系统访问</strong>：<br> 在 WSL 中可通过 <code>/mnt/c/</code> 等路径访问 Windows 磁盘。例如访问 <code>C:\\Users\\YourName</code>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">cd <span class=\"token operator\">/</span>mnt/c/Users/YourName<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>在 Windows 中访问 WSL 文件</strong>：<br> 可使用 File Explorer 直接访问：在地址栏输入 <code>\\\\wsl$</code>，会显示所有已安装的 WSL 发行版及其文件系统。</p>\n</li>\n<li><p><strong>同步代码与项目文件</strong>：<br> 可以将项目文件放在 Windows 共享目录中，再在 WSL 中编辑、执行，这样两个系统间文件同步简单且快速。</p>\n</li>\n</ul>\n<h3 id=\"5-2-WSL-GUI-应用（WSLg）\"><a href=\"#5-2-WSL-GUI-应用（WSLg）\" class=\"headerlink\" title=\"5.2 WSL GUI 应用（WSLg）\"></a>5.2 WSL GUI 应用（WSLg）</h3><p>在最新版本的 Windows 10 和 Windows 11 上，WSL 支持 Linux 图形界面应用（WSLg）。配置方法如下：</p>\n<ol>\n<li><p><strong>确保 WSL 更新至最新版本</strong>：执行</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>update<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>启动 GUI 应用</strong>（如 Firefox）：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> firefox\nfirefox <span class=\"token operator\">&amp;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n<p>WSLg 会自动启动并显示 Linux GUI 应用，无需额外配置 X 服务器。</p>\n<h3 id=\"5-3-代理设置\"><a href=\"#5-3-代理设置\" class=\"headerlink\" title=\"5.3 代理设置\"></a>5.3 代理设置</h3><p>如果你处于网络环境受限或想加快下载速度，可以设置代理。</p>\n<h4 id=\"（1）设置-Windows-系统代理\"><a href=\"#（1）设置-Windows-系统代理\" class=\"headerlink\" title=\"（1）设置 Windows 系统代理\"></a>（1）设置 Windows 系统代理</h4><p>如果使用科学上网工具（如 Clash、V2Ray、VPN），确保系统代理已启用。可在 Windows 设置 → 网络和 Internet → 代理中配置，也可以通过命令设置环境变量：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">setx http_proxy http://127.0.0.1:7890 /m\nsetx https_proxy http://127.0.0.1:7890 /m<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"（2）在-WSL-中设置代理\"><a href=\"#（2）在-WSL-中设置代理\" class=\"headerlink\" title=\"（2）在 WSL 中设置代理\"></a>（2）在 WSL 中设置代理</h4><p>在 WSL 中使用环境变量：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">http_proxy</span><span class=\"token operator\">=</span><span class=\"token string\">\"http://127.0.0.1:7890\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">https_proxy</span><span class=\"token operator\">=</span><span class=\"token string\">\"http://127.0.0.1:7890\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>若需要全局生效，在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 文件末尾加入以上配置，并执行 <code>source ~/.bashrc</code> 使其生效。</p>\n<h4 id=\"（3）apt-专用代理配置\"><a href=\"#（3）apt-专用代理配置\" class=\"headerlink\" title=\"（3）apt 专用代理配置\"></a>（3）apt 专用代理配置</h4><p>创建或编辑 apt 配置文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">nano</span> /etc/apt/apt.conf.d/proxy.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>添加内容：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Acquire<span class=\"token double-colon punctuation\">::</span>http<span class=\"token double-colon punctuation\">::</span>Proxy <span class=\"token string\">\"http://127.0.0.1:7890\"</span><span class=\"token punctuation\">;</span>\nAcquire<span class=\"token double-colon punctuation\">::</span>https<span class=\"token double-colon punctuation\">::</span>Proxy <span class=\"token string\">\"http://127.0.0.1:7890\"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>保存后，<code>sudo apt update</code> 将走代理。</p>\n<h3 id=\"5-4-多实例安装（同一版本多个副本）\"><a href=\"#5-4-多实例安装（同一版本多个副本）\" class=\"headerlink\" title=\"5.4 多实例安装（同一版本多个副本）\"></a>5.4 多实例安装（同一版本多个副本）</h3><p>WSL 允许你导入同一 Linux 发行版的多个副本，便于隔离不同任务。操作步骤如下：</p>\n<ol>\n<li><p><strong>导出已有实例</strong><br> 假设已安装 <code>Ubuntu-20.04</code>，用以下命令导出为 <code>.tar</code> 文件：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>export Ubuntu-20<span class=\"token punctuation\">.</span>04 D:\\wsl-backups\\ubuntu-20<span class=\"token punctuation\">.</span>04<span class=\"token punctuation\">.</span>tar<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>导入为新实例</strong><br> 用新名称（例如 <code>Ubuntu-Dev</code>）创建副本：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>import Ubuntu-Dev D:\\WSL\\Ubuntu-Dev D:\\wsl-backups\\ubuntu-20<span class=\"token punctuation\">.</span>04<span class=\"token punctuation\">.</span>tar <span class=\"token operator\">--</span>version 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>启动新实例</strong><br> 使用下面命令启动新导入的实例：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">-</span>d Ubuntu-Dev<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<p>这样你就可以在同一台机器上同时运行多个独立的 Linux 环境。</p>\n<hr>\n<h2 id=\"6-常用命令与管理技巧\"><a href=\"#6-常用命令与管理技巧\" class=\"headerlink\" title=\"6. 常用命令与管理技巧\"></a>6. 常用命令与管理技巧</h2><ul>\n<li><p><strong>查看已安装发行版及版本</strong>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">-</span>l <span class=\"token operator\">-</span>v<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>启动指定发行版</strong>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">-</span>d &lt;发行版名称&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>设置默认发行版（直接运行 wsl 时启动的系统）</strong>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>setdefault &lt;发行版名称&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>切换 WSL 版本</strong>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span><span class=\"token function\">set-version</span> &lt;发行版名称&gt; <span class=\"token punctuation\">[</span>1<span class=\"token punctuation\">|</span>2<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>更新 WSL 内核</strong>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>update<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>关闭所有运行中的 WSL 实例</strong>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>shutdown<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>卸载某个发行版</strong>：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">wsl <span class=\"token operator\">--</span>unregister &lt;发行版名称&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n",
            "tags": [
                "linux"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/04/08/pycharm-bao-cun-xu-ke-zheng-shu-ju-shi-chu-cuo/",
            "url": "https://0xdadream.github.io/2025/04/08/pycharm-bao-cun-xu-ke-zheng-shu-ju-shi-chu-cuo/",
            "title": "pycharm保存许可证数据时出错",
            "date_published": "2025-04-08T04:25:00.000Z",
            "content_html": "<h1 id=\"pycharm保存许可证数据时出错\"><a href=\"#pycharm保存许可证数据时出错\" class=\"headerlink\" title=\"pycharm保存许可证数据时出错\"></a>pycharm保存许可证数据时出错</h1><p>报错</p>\n<p> C:\\Users\\xxx\\AppData\\Roaming\\JetBrains\\PyCharm2024.2\\pycharm.key (拒绝访问)</p>\n<p>去这个目录下把这个文件改成<code>pycharm.key.bak</code>做一个备份，然后新建一个文件空<code>pycharm.key</code>，不创建好像也能自己创建，我没试过</p>\n",
            "tags": [
                "tools"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/04/07/google-nei-rong-zai-xin-biao-qian-ye-da-kai/",
            "url": "https://0xdadream.github.io/2025/04/07/google-nei-rong-zai-xin-biao-qian-ye-da-kai/",
            "title": "Google内容在新标签页打开",
            "date_published": "2025-04-07T04:25:00.000Z",
            "content_html": "<h1 id=\"Google内容在新标签页打开\"><a href=\"#Google内容在新标签页打开\" class=\"headerlink\" title=\"Google内容在新标签页打开\"></a>Google内容在新标签页打开</h1><p>进入<code>google.com</code>，右下角找到设置，搜索设置，找到在新的浏览器窗口中打开所选的每条搜索结果勾选</p>\n",
            "tags": [
                "tips"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/04/05/clash-verge-jie-dian-quan-bu-chao-shi/",
            "url": "https://0xdadream.github.io/2025/04/05/clash-verge-jie-dian-quan-bu-chao-shi/",
            "title": "clash_verge节点全部超时",
            "date_published": "2025-04-05T04:25:00.000Z",
            "content_html": "<h1 id=\"clash-verge节点全部超时\"><a href=\"#clash-verge节点全部超时\" class=\"headerlink\" title=\"clash_verge节点全部超时\"></a>clash_verge节点全部超时</h1><p>clash_verge正常使用需要确保本地计算机系统时间与服务器上是一致，如果存在一定时差会导致全部服务器连接超时，一般都是标准北京时间可以到系统的 “日期和时间” 设置中同步一下标准时间。</p>\n<p>或者</p>\n<p>关闭DNS，到设置-&gt;DNS覆写-&gt;关闭DNS</p>\n",
            "tags": [
                "wall"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/04/03/jie-jue-bao-cuo-jinja2.exceptions.templatenotfound-index.html/",
            "url": "https://0xdadream.github.io/2025/04/03/jie-jue-bao-cuo-jinja2.exceptions.templatenotfound-index.html/",
            "title": "解决报错jinja2.exceptions.TemplateNotFound_index.html",
            "date_published": "2025-04-03T04:25:00.000Z",
            "content_html": "<h1 id=\"解决报错jinja2-exceptions-TemplateNotFound-index-html\"><a href=\"#解决报错jinja2-exceptions-TemplateNotFound-index-html\" class=\"headerlink\" title=\"解决报错jinja2.exceptions.TemplateNotFound_index.html\"></a>解决报错jinja2.exceptions.TemplateNotFound_index.html</h1><p>templates文件夹需要和xxx.py需要再一级文件夹</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://0xdadream.github.io/2025/03/24/bian-yi-shi-bao-cuo-rootminiconda3compiler-compatld/",
            "url": "https://0xdadream.github.io/2025/03/24/bian-yi-shi-bao-cuo-rootminiconda3compiler-compatld/",
            "title": "编译时报错rootminiconda3compiler_compatld",
            "date_published": "2025-03-24T04:25:00.000Z",
            "content_html": "<h1 id=\"编译时报错rootminiconda3compiler-compatld\"><a href=\"#编译时报错rootminiconda3compiler-compatld\" class=\"headerlink\" title=\"编译时报错rootminiconda3compiler_compatld\"></a>编译时报错rootminiconda3compiler_compatld</h1><h2 id=\"报错描述\"><a href=\"#报错描述\" class=\"headerlink\" title=\"报错描述\"></a>报错描述</h2><p>在执行make安装编译时报错</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">/root/miniconda3/compiler_compat/ld: cannot <span class=\"token function\">find</span> -lpbc: No such <span class=\"token function\">file</span> or directory<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>这个是由于conda环境自带有编译库，你安装的库可能没有</p>\n<h4 id=\"方法-1：退出-Conda-环境\"><a href=\"#方法-1：退出-Conda-环境\" class=\"headerlink\" title=\"方法 1：退出 Conda 环境\"></a><strong>方法 1：退出 Conda 环境</strong></h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">conda deactivate  <span class=\"token comment\"># 确保编译时不在 Conda 环境中</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>退出 Conda 环境后，编译工具链会直接使用系统的 <code>ld</code> 和库路径。</p>\n<h4 id=\"方法-2：手动指定链接器路径\"><a href=\"#方法-2：手动指定链接器路径\" class=\"headerlink\" title=\"方法 2：手动指定链接器路径\"></a><strong>方法 2：手动指定链接器路径</strong></h4><p>在编译命令中强制使用系统链接器（覆盖 Conda 的默认设置）：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 示例：在编译时指定系统 ld</span>\ngcc <span class=\"token punctuation\">..</span>. -B/usr/bin <span class=\"token punctuation\">..</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>或直接调用系统链接器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">/usr/bin/ld <span class=\"token punctuation\">..</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"方法-3：临时移除-Conda-的干扰\"><a href=\"#方法-3：临时移除-Conda-的干扰\" class=\"headerlink\" title=\"方法 3：临时移除 Conda 的干扰\"></a><strong>方法 3：临时移除 Conda 的干扰</strong></h4><p>重命名或删除 <code>compiler_compat</code> 目录（需谨慎操作）：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mv</span> /root/miniconda3/compiler_compat /root/miniconda3/compiler_compat.bak<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>操作后重新编译，但可能影响 Conda 环境内其他包的编译行为。</p>\n<hr>\n<h3 id=\"验证当前使用的-ld\"><a href=\"#验证当前使用的-ld\" class=\"headerlink\" title=\"验证当前使用的 ld\"></a><strong>验证当前使用的 <code>ld</code></strong></h3><p>检查编译时实际调用的 <code>ld</code> 路径：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看编译过程中使用的 ld 路径</span>\ngcc <span class=\"token parameter variable\">-v</span> <span class=\"token punctuation\">..</span>. <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>&gt;</span><span class=\"token file-descriptor important\">&amp;1</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> COLLECT_LTO_WRAPPER<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>",
            "tags": [
                "linux"
            ]
        }
    ]
}